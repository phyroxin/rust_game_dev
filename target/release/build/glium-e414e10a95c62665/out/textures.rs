/// A one-dimensional texture  containing floating-point data.
pub struct Texture1d(TextureAny);

                impl Texture for Texture1d {
                    fn get_width(&self) -> u32 {
                        self.0.get_width()
                    }

                    fn get_height(&self) -> Option<u32> {
                        self.0.get_height()
                    }

                    fn get_depth(&self) -> Option<u32> {
                        self.0.get_depth()
                    }

                    fn get_array_size(&self) -> Option<u32> {
                        self.0.get_array_size()
                    }
                }
            

                impl GlObject for Texture1d {
                    type Id = gl::types::GLuint;
                    fn get_id(&self) -> gl::types::GLuint {
                        self.0.get_id()
                    }
                }
            

                impl ::std::fmt::Debug for Texture1d {
                    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> Result<(), ::std::fmt::Error>
                    {
                        self.0.fmt(f)
                    }
                }
            

                impl ::std::ops::Deref for Texture1d {
                    type Target = TextureAny;
                    
                    fn deref<'a>(&'a self) -> &'a TextureAny {
                        &self.0
                    }
                }
            

                            impl<'a> AsUniformValue for &'a Texture1d {
                                fn as_uniform_value(&self) -> UniformValue {
                                    UniformValue::Texture1d(*self, None)
                                }
                            }

                            impl<'a> AsUniformValue for Sampler<'a, Texture1d> {
                                fn as_uniform_value(&self) -> UniformValue {
                                    UniformValue::Texture1d(self.0, Some(self.1))
                                }
                            }

                            impl Texture1d {
                                /// Builds a `Sampler` marker object that allows you to indicate
                                /// how the texture should be sampled from inside a shader.
                                ///
                                /// # Example
                                ///
                                /// ```no_run
                                /// # #[macro_use] extern crate glium;
                                /// # fn main() {
                                /// # let texture: glium::texture::Texture2d = unsafe {
                                /// # ::std::mem::uninitialized() };
                                /// let uniforms = uniform! {
                                ///     color_texture: texture.sampled().magnify_filter(glium::uniforms::MagnifySamplerFilter::Nearest)
                                /// };
                                /// # }
                                /// ```
                                pub fn sampled(&self) -> Sampler<Texture1d> {
                                    Sampler(self, Default::default())
                                }
                            }
                        
impl Texture1d {

            /// Determines the internal format of this texture.
            ///
            /// The backend may not support querying the actual format, in which case an error
            /// is returned.
            pub fn get_internal_format(&self) -> Result<InternalFormat, GetFormatError> {
                self.0.get_internal_format()
            }
        

                /// Builds a new texture by uploading data.
                ///
                /// This function will automatically generate all mipmaps of the texture.
                pub fn new<'a, F, T>(facade: &F, data: T)
                              -> Result<Texture1d, TextureCreationError>
                              where T: Texture1dDataSource<'a>, F: Facade
                {
                    Texture1d::new_impl(facade, data, None, MipmapsOption::AutoGeneratedMipmaps)
                }
            

                /// Builds a new texture by uploading data.
                pub fn with_mipmaps<'a, F, T>(facade: &F, data: T, mipmaps: MipmapsOption)
                                              -> Result<Texture1d, TextureCreationError>
                                              where T: Texture1dDataSource<'a>, F: Facade
                {
                    Texture1d::new_impl(facade, data, None, mipmaps)
                }
            

                /// Builds a new texture with a specific format.
                pub fn with_format<'a, F, T>(facade: &F, data: T,
                                          format: UncompressedFloatFormat, mipmaps: MipmapsOption)
                                          -> Result<Texture1d, TextureCreationError>
                                          where T: Texture1dDataSource<'a>, F: Facade
                {
                    Texture1d::new_impl(facade, data, Some(format), mipmaps)
                }
            

                fn new_impl<'a, F, T>(facade: &F, data: T,
                                   format: Option<UncompressedFloatFormat>, mipmaps: MipmapsOption)
                                   -> Result<Texture1d, TextureCreationError>
                                   where T: Texture1dDataSource<'a>, F: Facade
                {
            
let format = format.map(|f| {
                           TextureFormatRequest::Specific(f.to_texture_format())
                       }).unwrap_or(TextureFormatRequest::AnyFloatingPoint);
                    let RawImage1d { data, width, format: client_format } = data.into_raw();
                let client_format = ClientFormatAny::ClientFormat(client_format);Ok(Texture1d(try!(any::new_texture(facade, format, Some((client_format, data)), mipmaps.to_regular(), Dimensions::Texture1d { width: width }))))
}

                /// Creates an empty texture.
                ///
                /// No mipmap level (except for the main level) will be allocated or generated.
                ///
                /// The texture will contain undefined data.
                pub fn empty<F>(facade: &F, width: u32)
                                -> Result<Texture1d, TextureCreationError>
                                where F: Facade
                {
                    let format = TextureFormatRequest::AnyFloatingPoint;
            
any::new_texture::<_, u8>(facade, format, None, MipmapsOption::NoMipmap.to_regular(), Dimensions::Texture1d { width: width }).map(|t| Texture1d(t))}

                /// Creates an empty texture with a specific format.
                ///
                /// The texture (and its mipmaps) will contain undefined data.
                pub fn empty_with_format<F>(facade: &F, format: UncompressedFloatFormat, mipmaps: MipmapsOption, width: u32) -> Result<Texture1d, TextureCreationError> where F: Facade {
                    let format = format.to_texture_format();
                    let format = TextureFormatRequest::Specific(format);
            
let t = any::new_texture::<_, u8>(facade, format, None, mipmaps.to_regular(), Dimensions::Texture1d { width: width });
            t.map(|t| Texture1d(t))
}

                /// Creates an empty texture. Specifies whether is has mipmaps.
                ///
                /// The texture (and its mipmaps) will contain undefined data.
                pub fn empty_with_mipmaps<F>(facade: &F, mipmaps: MipmapsOption, width: u32) -> Result<Texture1d, TextureCreationError> where F: Facade {
                    let format = TextureFormatRequest::AnyFloatingPoint;
            
any::new_texture::<_, u8>(facade, format, None, mipmaps.to_regular(), Dimensions::Texture1d { width: width }).map(|t| Texture1d(t))
}

            /// Returns the number of mipmap levels of the texture.
            ///
            /// The minimum value is 1, since there is always a main texture.
            pub fn get_mipmap_levels(&self) -> u32 {
                self.0.get_mipmap_levels()
            }
        
            /// Turns the texture into a `ResidentTexture`.
            ///
            /// This allows you to use the texture in a much more efficient way by storing
            /// a "reference to it" in a buffer (actually not a reference but a raw pointer).
            ///
            /// See the documentation of `ResidentTexture` for more infos.
            pub fn resident(self) -> Result<ResidentTexture, BindlessTexturesNotSupportedError> {
                ResidentTexture::new(self.0)
            }
        
                /// Access a single mipmap level of this texture.
                pub fn mipmap(&self, level: u32) -> Option<Texture1dMipmap> {
                    self.0.mipmap(0, level).map(|m| Texture1dMipmap(m, self))
                }
            
                /// Access the main mipmap level of this texture.
                pub fn main_level(&self) -> Texture1dMipmap {
                    self.mipmap(0).unwrap()
                }
            }

                    /// Represents a single mipmap level of a `Texture1d`.
                    ///
                    /// Can be obtained by calling `Texture1d::mipmap()` or `Texture1d::main_level()`.
                    #[derive(Copy, Clone)]
                    pub struct Texture1dMipmap<'t>(TextureAnyMipmap<'t>, &'t Texture1d);
                impl<'t> Texture1dMipmap<'t> {

                /// Returns the corresponding texture.
                pub fn get_texture(&self) -> &'t Texture1d {
                    self.1
                }

                /// Returns the texture level.
                pub fn get_level(&self) -> u32 {
                    self.0.get_level()
                }
            }
/// A compressed one-dimensional texture  containing floating-point data.
pub struct CompressedTexture1d(TextureAny);

                impl Texture for CompressedTexture1d {
                    fn get_width(&self) -> u32 {
                        self.0.get_width()
                    }

                    fn get_height(&self) -> Option<u32> {
                        self.0.get_height()
                    }

                    fn get_depth(&self) -> Option<u32> {
                        self.0.get_depth()
                    }

                    fn get_array_size(&self) -> Option<u32> {
                        self.0.get_array_size()
                    }
                }
            

                impl GlObject for CompressedTexture1d {
                    type Id = gl::types::GLuint;
                    fn get_id(&self) -> gl::types::GLuint {
                        self.0.get_id()
                    }
                }
            

                impl ::std::fmt::Debug for CompressedTexture1d {
                    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> Result<(), ::std::fmt::Error>
                    {
                        self.0.fmt(f)
                    }
                }
            

                impl ::std::ops::Deref for CompressedTexture1d {
                    type Target = TextureAny;
                    
                    fn deref<'a>(&'a self) -> &'a TextureAny {
                        &self.0
                    }
                }
            

                            impl<'a> AsUniformValue for &'a CompressedTexture1d {
                                fn as_uniform_value(&self) -> UniformValue {
                                    UniformValue::CompressedTexture1d(*self, None)
                                }
                            }

                            impl<'a> AsUniformValue for Sampler<'a, CompressedTexture1d> {
                                fn as_uniform_value(&self) -> UniformValue {
                                    UniformValue::CompressedTexture1d(self.0, Some(self.1))
                                }
                            }

                            impl CompressedTexture1d {
                                /// Builds a `Sampler` marker object that allows you to indicate
                                /// how the texture should be sampled from inside a shader.
                                ///
                                /// # Example
                                ///
                                /// ```no_run
                                /// # #[macro_use] extern crate glium;
                                /// # fn main() {
                                /// # let texture: glium::texture::Texture2d = unsafe {
                                /// # ::std::mem::uninitialized() };
                                /// let uniforms = uniform! {
                                ///     color_texture: texture.sampled().magnify_filter(glium::uniforms::MagnifySamplerFilter::Nearest)
                                /// };
                                /// # }
                                /// ```
                                pub fn sampled(&self) -> Sampler<CompressedTexture1d> {
                                    Sampler(self, Default::default())
                                }
                            }
                        
impl CompressedTexture1d {

            /// Determines the internal format of this texture.
            ///
            /// The backend may not support querying the actual format, in which case an error
            /// is returned.
            pub fn get_internal_format(&self) -> Result<InternalFormat, GetFormatError> {
                self.0.get_internal_format()
            }
        

                /// Builds a new texture by uploading data.
                ///
                /// No mipmap level (except for the main level) will be allocator nor generated.
                pub fn new<'a, F, T>(facade: &F, data: T)
                              -> Result<CompressedTexture1d, TextureCreationError>
                              where T: Texture1dDataSource<'a>, F: Facade
                {
                    CompressedTexture1d::new_impl(facade, data, None, CompressedMipmapsOption::NoMipmap)
                }
            

                /// Builds a new texture by uploading data.
                pub fn with_mipmaps<'a, F, T>(facade: &F, data: T, mipmaps: CompressedMipmapsOption)
                                              -> Result<CompressedTexture1d, TextureCreationError>
                                              where T: Texture1dDataSource<'a>, F: Facade
                {
                    CompressedTexture1d::new_impl(facade, data, None, mipmaps)
                }
            

                /// Builds a new texture with a specific format. The input data must also be of the
                /// specified compressed format.
                pub fn with_compressed_data<F>(facade: &F, data: &[u8], width: u32,
                                                      format: CompressedFormat, mipmaps: CompressedMipmapsOption)
                                                      -> Result<CompressedTexture1d, TextureCreationError>
                                                       where F: Facade
                {
                    let data = Cow::Borrowed(data.as_ref());
                    let client_format = ClientFormatAny::CompressedFormat(format);
                    Ok(CompressedTexture1d(try!(any::new_texture(facade, TextureFormatRequest::AnyCompressed, Some((client_format, data)),
                                                    mipmaps.to_regular(), Dimensions::Texture1d { width: width }))))
                }
            

                /// Builds a new texture with a specific format.
                pub fn with_format<'a, F, T>(facade: &F, data: T,
                                          format: CompressedFormat, mipmaps: CompressedMipmapsOption)
                                          -> Result<CompressedTexture1d, TextureCreationError>
                                          where T: Texture1dDataSource<'a>, F: Facade
                {
                    CompressedTexture1d::new_impl(facade, data, Some(format), mipmaps)
                }
            

                fn new_impl<'a, F, T>(facade: &F, data: T,
                                   format: Option<CompressedFormat>, mipmaps: CompressedMipmapsOption)
                                   -> Result<CompressedTexture1d, TextureCreationError>
                                   where T: Texture1dDataSource<'a>, F: Facade
                {
            
let format = format.map(|f| {
                           TextureFormatRequest::Specific(f.to_texture_format())
                       }).unwrap_or(TextureFormatRequest::AnyCompressed);
                    let RawImage1d { data, width, format: client_format } = data.into_raw();
                let client_format = ClientFormatAny::ClientFormat(client_format);Ok(CompressedTexture1d(try!(any::new_texture(facade, format, Some((client_format, data)), mipmaps.to_regular(), Dimensions::Texture1d { width: width }))))
}

                /// Creates an empty texture with a specific format.
                ///
                /// The texture (and its mipmaps) will contain undefined data.
                pub fn empty_with_format<F>(facade: &F, format: CompressedFormat, mipmaps: CompressedMipmapsOption, width: u32) -> Result<CompressedTexture1d, TextureCreationError> where F: Facade {
                    let format = format.to_texture_format();
                    let format = TextureFormatRequest::Specific(format);
            
let t = any::new_texture::<_, u8>(facade, format, None, mipmaps.to_regular(), Dimensions::Texture1d { width: width });
            t.map(|t| CompressedTexture1d(t))
}

            /// Returns the number of mipmap levels of the texture.
            ///
            /// The minimum value is 1, since there is always a main texture.
            pub fn get_mipmap_levels(&self) -> u32 {
                self.0.get_mipmap_levels()
            }
        
                /// Reads the content of the texture to RAM without decompressing it before.
                ///
                /// You should avoid doing this at all cost during performance-critical
                /// operations (for example, while you're drawing).
                ///
                /// Returns the compressed format of the texture and the compressed data, gives
                /// `None` when the internal compression format is generic or unknown.
                pub fn read_compressed_data(&self) -> Option<(CompressedFormat, Vec<u8>)> {
                    self.main_level().read_compressed_data()
                }
            
            /// Turns the texture into a `ResidentTexture`.
            ///
            /// This allows you to use the texture in a much more efficient way by storing
            /// a "reference to it" in a buffer (actually not a reference but a raw pointer).
            ///
            /// See the documentation of `ResidentTexture` for more infos.
            pub fn resident(self) -> Result<ResidentTexture, BindlessTexturesNotSupportedError> {
                ResidentTexture::new(self.0)
            }
        
                /// Access a single mipmap level of this texture.
                pub fn mipmap(&self, level: u32) -> Option<CompressedTexture1dMipmap> {
                    self.0.mipmap(0, level).map(|m| CompressedTexture1dMipmap(m, self))
                }
            
                /// Access the main mipmap level of this texture.
                pub fn main_level(&self) -> CompressedTexture1dMipmap {
                    self.mipmap(0).unwrap()
                }
            }

                    /// Represents a single mipmap level of a `CompressedTexture1d`.
                    ///
                    /// Can be obtained by calling `CompressedTexture1d::mipmap()` or `CompressedTexture1d::main_level()`.
                    #[derive(Copy, Clone)]
                    pub struct CompressedTexture1dMipmap<'t>(TextureAnyMipmap<'t>, &'t CompressedTexture1d);
                impl<'t> CompressedTexture1dMipmap<'t> {

                    /// Reads the content of the texture level to RAM without decompressing it before.
                    ///
                    /// You should avoid doing this at all cost during performance-critical
                    /// operations (for example, while you're drawing).
                    ///
                    /// Returns the compressed format of the texture and the compressed data, gives
                    /// `None` when the internal compression format is generic or unknown.
                    pub fn read_compressed_data(&self) -> Option<(CompressedFormat, Vec<u8>)> {
                        match self.0.download_compressed_data() {
                            Some((ClientFormatAny::CompressedFormat(format), buf)) => Some((format, buf)),
                            None => None,
                            _ => unreachable!(),
                        }
                    }
                
                /// Returns the corresponding texture.
                pub fn get_texture(&self) -> &'t CompressedTexture1d {
                    self.1
                }

                /// Returns the texture level.
                pub fn get_level(&self) -> u32 {
                    self.0.get_level()
                }
            }
/// A one-dimensional texture  containing sRGB floating-point data.
pub struct SrgbTexture1d(TextureAny);

                impl Texture for SrgbTexture1d {
                    fn get_width(&self) -> u32 {
                        self.0.get_width()
                    }

                    fn get_height(&self) -> Option<u32> {
                        self.0.get_height()
                    }

                    fn get_depth(&self) -> Option<u32> {
                        self.0.get_depth()
                    }

                    fn get_array_size(&self) -> Option<u32> {
                        self.0.get_array_size()
                    }
                }
            

                impl GlObject for SrgbTexture1d {
                    type Id = gl::types::GLuint;
                    fn get_id(&self) -> gl::types::GLuint {
                        self.0.get_id()
                    }
                }
            

                impl ::std::fmt::Debug for SrgbTexture1d {
                    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> Result<(), ::std::fmt::Error>
                    {
                        self.0.fmt(f)
                    }
                }
            

                impl ::std::ops::Deref for SrgbTexture1d {
                    type Target = TextureAny;
                    
                    fn deref<'a>(&'a self) -> &'a TextureAny {
                        &self.0
                    }
                }
            

                            impl<'a> AsUniformValue for &'a SrgbTexture1d {
                                fn as_uniform_value(&self) -> UniformValue {
                                    UniformValue::SrgbTexture1d(*self, None)
                                }
                            }

                            impl<'a> AsUniformValue for Sampler<'a, SrgbTexture1d> {
                                fn as_uniform_value(&self) -> UniformValue {
                                    UniformValue::SrgbTexture1d(self.0, Some(self.1))
                                }
                            }

                            impl SrgbTexture1d {
                                /// Builds a `Sampler` marker object that allows you to indicate
                                /// how the texture should be sampled from inside a shader.
                                ///
                                /// # Example
                                ///
                                /// ```no_run
                                /// # #[macro_use] extern crate glium;
                                /// # fn main() {
                                /// # let texture: glium::texture::Texture2d = unsafe {
                                /// # ::std::mem::uninitialized() };
                                /// let uniforms = uniform! {
                                ///     color_texture: texture.sampled().magnify_filter(glium::uniforms::MagnifySamplerFilter::Nearest)
                                /// };
                                /// # }
                                /// ```
                                pub fn sampled(&self) -> Sampler<SrgbTexture1d> {
                                    Sampler(self, Default::default())
                                }
                            }
                        
impl SrgbTexture1d {

            /// Determines the internal format of this texture.
            ///
            /// The backend may not support querying the actual format, in which case an error
            /// is returned.
            pub fn get_internal_format(&self) -> Result<InternalFormat, GetFormatError> {
                self.0.get_internal_format()
            }
        

                /// Builds a new texture by uploading data.
                ///
                /// This function will automatically generate all mipmaps of the texture.
                pub fn new<'a, F, T>(facade: &F, data: T)
                              -> Result<SrgbTexture1d, TextureCreationError>
                              where T: Texture1dDataSource<'a>, F: Facade
                {
                    SrgbTexture1d::new_impl(facade, data, None, MipmapsOption::AutoGeneratedMipmaps)
                }
            

                /// Builds a new texture by uploading data.
                pub fn with_mipmaps<'a, F, T>(facade: &F, data: T, mipmaps: MipmapsOption)
                                              -> Result<SrgbTexture1d, TextureCreationError>
                                              where T: Texture1dDataSource<'a>, F: Facade
                {
                    SrgbTexture1d::new_impl(facade, data, None, mipmaps)
                }
            

                /// Builds a new texture with a specific format.
                pub fn with_format<'a, F, T>(facade: &F, data: T,
                                          format: SrgbFormat, mipmaps: MipmapsOption)
                                          -> Result<SrgbTexture1d, TextureCreationError>
                                          where T: Texture1dDataSource<'a>, F: Facade
                {
                    SrgbTexture1d::new_impl(facade, data, Some(format), mipmaps)
                }
            

                fn new_impl<'a, F, T>(facade: &F, data: T,
                                   format: Option<SrgbFormat>, mipmaps: MipmapsOption)
                                   -> Result<SrgbTexture1d, TextureCreationError>
                                   where T: Texture1dDataSource<'a>, F: Facade
                {
            
let format = format.map(|f| {
                           TextureFormatRequest::Specific(f.to_texture_format())
                       }).unwrap_or(TextureFormatRequest::AnySrgb);
                    let RawImage1d { data, width, format: client_format } = data.into_raw();
                let client_format = ClientFormatAny::ClientFormat(client_format);Ok(SrgbTexture1d(try!(any::new_texture(facade, format, Some((client_format, data)), mipmaps.to_regular(), Dimensions::Texture1d { width: width }))))
}

                /// Creates an empty texture.
                ///
                /// No mipmap level (except for the main level) will be allocated or generated.
                ///
                /// The texture will contain undefined data.
                pub fn empty<F>(facade: &F, width: u32)
                                -> Result<SrgbTexture1d, TextureCreationError>
                                where F: Facade
                {
                    let format = TextureFormatRequest::AnySrgb;
            
any::new_texture::<_, u8>(facade, format, None, MipmapsOption::NoMipmap.to_regular(), Dimensions::Texture1d { width: width }).map(|t| SrgbTexture1d(t))}

                /// Creates an empty texture with a specific format.
                ///
                /// The texture (and its mipmaps) will contain undefined data.
                pub fn empty_with_format<F>(facade: &F, format: SrgbFormat, mipmaps: MipmapsOption, width: u32) -> Result<SrgbTexture1d, TextureCreationError> where F: Facade {
                    let format = format.to_texture_format();
                    let format = TextureFormatRequest::Specific(format);
            
let t = any::new_texture::<_, u8>(facade, format, None, mipmaps.to_regular(), Dimensions::Texture1d { width: width });
            t.map(|t| SrgbTexture1d(t))
}

                /// Creates an empty texture. Specifies whether is has mipmaps.
                ///
                /// The texture (and its mipmaps) will contain undefined data.
                pub fn empty_with_mipmaps<F>(facade: &F, mipmaps: MipmapsOption, width: u32) -> Result<SrgbTexture1d, TextureCreationError> where F: Facade {
                    let format = TextureFormatRequest::AnySrgb;
            
any::new_texture::<_, u8>(facade, format, None, mipmaps.to_regular(), Dimensions::Texture1d { width: width }).map(|t| SrgbTexture1d(t))
}

            /// Returns the number of mipmap levels of the texture.
            ///
            /// The minimum value is 1, since there is always a main texture.
            pub fn get_mipmap_levels(&self) -> u32 {
                self.0.get_mipmap_levels()
            }
        
            /// Turns the texture into a `ResidentTexture`.
            ///
            /// This allows you to use the texture in a much more efficient way by storing
            /// a "reference to it" in a buffer (actually not a reference but a raw pointer).
            ///
            /// See the documentation of `ResidentTexture` for more infos.
            pub fn resident(self) -> Result<ResidentTexture, BindlessTexturesNotSupportedError> {
                ResidentTexture::new(self.0)
            }
        
                /// Access a single mipmap level of this texture.
                pub fn mipmap(&self, level: u32) -> Option<SrgbTexture1dMipmap> {
                    self.0.mipmap(0, level).map(|m| SrgbTexture1dMipmap(m, self))
                }
            
                /// Access the main mipmap level of this texture.
                pub fn main_level(&self) -> SrgbTexture1dMipmap {
                    self.mipmap(0).unwrap()
                }
            }

                    /// Represents a single mipmap level of a `SrgbTexture1d`.
                    ///
                    /// Can be obtained by calling `SrgbTexture1d::mipmap()` or `SrgbTexture1d::main_level()`.
                    #[derive(Copy, Clone)]
                    pub struct SrgbTexture1dMipmap<'t>(TextureAnyMipmap<'t>, &'t SrgbTexture1d);
                impl<'t> SrgbTexture1dMipmap<'t> {

                /// Returns the corresponding texture.
                pub fn get_texture(&self) -> &'t SrgbTexture1d {
                    self.1
                }

                /// Returns the texture level.
                pub fn get_level(&self) -> u32 {
                    self.0.get_level()
                }
            }
/// A compressed one-dimensional texture  containing sRGB floating-point data.
pub struct CompressedSrgbTexture1d(TextureAny);

                impl Texture for CompressedSrgbTexture1d {
                    fn get_width(&self) -> u32 {
                        self.0.get_width()
                    }

                    fn get_height(&self) -> Option<u32> {
                        self.0.get_height()
                    }

                    fn get_depth(&self) -> Option<u32> {
                        self.0.get_depth()
                    }

                    fn get_array_size(&self) -> Option<u32> {
                        self.0.get_array_size()
                    }
                }
            

                impl GlObject for CompressedSrgbTexture1d {
                    type Id = gl::types::GLuint;
                    fn get_id(&self) -> gl::types::GLuint {
                        self.0.get_id()
                    }
                }
            

                impl ::std::fmt::Debug for CompressedSrgbTexture1d {
                    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> Result<(), ::std::fmt::Error>
                    {
                        self.0.fmt(f)
                    }
                }
            

                impl ::std::ops::Deref for CompressedSrgbTexture1d {
                    type Target = TextureAny;
                    
                    fn deref<'a>(&'a self) -> &'a TextureAny {
                        &self.0
                    }
                }
            

                            impl<'a> AsUniformValue for &'a CompressedSrgbTexture1d {
                                fn as_uniform_value(&self) -> UniformValue {
                                    UniformValue::CompressedSrgbTexture1d(*self, None)
                                }
                            }

                            impl<'a> AsUniformValue for Sampler<'a, CompressedSrgbTexture1d> {
                                fn as_uniform_value(&self) -> UniformValue {
                                    UniformValue::CompressedSrgbTexture1d(self.0, Some(self.1))
                                }
                            }

                            impl CompressedSrgbTexture1d {
                                /// Builds a `Sampler` marker object that allows you to indicate
                                /// how the texture should be sampled from inside a shader.
                                ///
                                /// # Example
                                ///
                                /// ```no_run
                                /// # #[macro_use] extern crate glium;
                                /// # fn main() {
                                /// # let texture: glium::texture::Texture2d = unsafe {
                                /// # ::std::mem::uninitialized() };
                                /// let uniforms = uniform! {
                                ///     color_texture: texture.sampled().magnify_filter(glium::uniforms::MagnifySamplerFilter::Nearest)
                                /// };
                                /// # }
                                /// ```
                                pub fn sampled(&self) -> Sampler<CompressedSrgbTexture1d> {
                                    Sampler(self, Default::default())
                                }
                            }
                        
impl CompressedSrgbTexture1d {

            /// Determines the internal format of this texture.
            ///
            /// The backend may not support querying the actual format, in which case an error
            /// is returned.
            pub fn get_internal_format(&self) -> Result<InternalFormat, GetFormatError> {
                self.0.get_internal_format()
            }
        

                /// Builds a new texture by uploading data.
                ///
                /// No mipmap level (except for the main level) will be allocator nor generated.
                pub fn new<'a, F, T>(facade: &F, data: T)
                              -> Result<CompressedSrgbTexture1d, TextureCreationError>
                              where T: Texture1dDataSource<'a>, F: Facade
                {
                    CompressedSrgbTexture1d::new_impl(facade, data, None, CompressedMipmapsOption::NoMipmap)
                }
            

                /// Builds a new texture by uploading data.
                pub fn with_mipmaps<'a, F, T>(facade: &F, data: T, mipmaps: CompressedMipmapsOption)
                                              -> Result<CompressedSrgbTexture1d, TextureCreationError>
                                              where T: Texture1dDataSource<'a>, F: Facade
                {
                    CompressedSrgbTexture1d::new_impl(facade, data, None, mipmaps)
                }
            

                /// Builds a new texture with a specific format. The input data must also be of the
                /// specified compressed format.
                pub fn with_compressed_data<F>(facade: &F, data: &[u8], width: u32,
                                                      format: CompressedSrgbFormat, mipmaps: CompressedMipmapsOption)
                                                      -> Result<CompressedSrgbTexture1d, TextureCreationError>
                                                       where F: Facade
                {
                    let data = Cow::Borrowed(data.as_ref());
                    let client_format = ClientFormatAny::CompressedSrgbFormat(format);
                    Ok(CompressedSrgbTexture1d(try!(any::new_texture(facade, TextureFormatRequest::AnyCompressedSrgb, Some((client_format, data)),
                                                    mipmaps.to_regular(), Dimensions::Texture1d { width: width }))))
                }
            

                /// Builds a new texture with a specific format.
                pub fn with_format<'a, F, T>(facade: &F, data: T,
                                          format: CompressedSrgbFormat, mipmaps: CompressedMipmapsOption)
                                          -> Result<CompressedSrgbTexture1d, TextureCreationError>
                                          where T: Texture1dDataSource<'a>, F: Facade
                {
                    CompressedSrgbTexture1d::new_impl(facade, data, Some(format), mipmaps)
                }
            

                fn new_impl<'a, F, T>(facade: &F, data: T,
                                   format: Option<CompressedSrgbFormat>, mipmaps: CompressedMipmapsOption)
                                   -> Result<CompressedSrgbTexture1d, TextureCreationError>
                                   where T: Texture1dDataSource<'a>, F: Facade
                {
            
let format = format.map(|f| {
                           TextureFormatRequest::Specific(f.to_texture_format())
                       }).unwrap_or(TextureFormatRequest::AnyCompressedSrgb);
                    let RawImage1d { data, width, format: client_format } = data.into_raw();
                let client_format = ClientFormatAny::ClientFormat(client_format);Ok(CompressedSrgbTexture1d(try!(any::new_texture(facade, format, Some((client_format, data)), mipmaps.to_regular(), Dimensions::Texture1d { width: width }))))
}

                /// Creates an empty texture with a specific format.
                ///
                /// The texture (and its mipmaps) will contain undefined data.
                pub fn empty_with_format<F>(facade: &F, format: CompressedSrgbFormat, mipmaps: CompressedMipmapsOption, width: u32) -> Result<CompressedSrgbTexture1d, TextureCreationError> where F: Facade {
                    let format = format.to_texture_format();
                    let format = TextureFormatRequest::Specific(format);
            
let t = any::new_texture::<_, u8>(facade, format, None, mipmaps.to_regular(), Dimensions::Texture1d { width: width });
            t.map(|t| CompressedSrgbTexture1d(t))
}

            /// Returns the number of mipmap levels of the texture.
            ///
            /// The minimum value is 1, since there is always a main texture.
            pub fn get_mipmap_levels(&self) -> u32 {
                self.0.get_mipmap_levels()
            }
        
                /// Reads the content of the texture to RAM without decompressing it before.
                ///
                /// You should avoid doing this at all cost during performance-critical
                /// operations (for example, while you're drawing).
                ///
                /// Returns the compressed format of the texture and the compressed data, gives
                /// `None` when the internal compression format is generic or unknown.
                pub fn read_compressed_data(&self) -> Option<(CompressedSrgbFormat, Vec<u8>)> {
                    self.main_level().read_compressed_data()
                }
            
            /// Turns the texture into a `ResidentTexture`.
            ///
            /// This allows you to use the texture in a much more efficient way by storing
            /// a "reference to it" in a buffer (actually not a reference but a raw pointer).
            ///
            /// See the documentation of `ResidentTexture` for more infos.
            pub fn resident(self) -> Result<ResidentTexture, BindlessTexturesNotSupportedError> {
                ResidentTexture::new(self.0)
            }
        
                /// Access a single mipmap level of this texture.
                pub fn mipmap(&self, level: u32) -> Option<CompressedSrgbTexture1dMipmap> {
                    self.0.mipmap(0, level).map(|m| CompressedSrgbTexture1dMipmap(m, self))
                }
            
                /// Access the main mipmap level of this texture.
                pub fn main_level(&self) -> CompressedSrgbTexture1dMipmap {
                    self.mipmap(0).unwrap()
                }
            }

                    /// Represents a single mipmap level of a `CompressedSrgbTexture1d`.
                    ///
                    /// Can be obtained by calling `CompressedSrgbTexture1d::mipmap()` or `CompressedSrgbTexture1d::main_level()`.
                    #[derive(Copy, Clone)]
                    pub struct CompressedSrgbTexture1dMipmap<'t>(TextureAnyMipmap<'t>, &'t CompressedSrgbTexture1d);
                impl<'t> CompressedSrgbTexture1dMipmap<'t> {

                    /// Reads the content of the texture level to RAM without decompressing it before.
                    ///
                    /// You should avoid doing this at all cost during performance-critical
                    /// operations (for example, while you're drawing).
                    ///
                    /// Returns the compressed format of the texture and the compressed data, gives
                    /// `None` when the internal compression format is generic or unknown.
                    pub fn read_compressed_data(&self) -> Option<(CompressedSrgbFormat, Vec<u8>)> {
                        match self.0.download_compressed_data() {
                            Some((ClientFormatAny::CompressedSrgbFormat(format), buf)) => Some((format, buf)),
                            None => None,
                            _ => unreachable!(),
                        }
                    }
                
                /// Returns the corresponding texture.
                pub fn get_texture(&self) -> &'t CompressedSrgbTexture1d {
                    self.1
                }

                /// Returns the texture level.
                pub fn get_level(&self) -> u32 {
                    self.0.get_level()
                }
            }
/// A one-dimensional texture  containing signed integral data.
pub struct IntegralTexture1d(TextureAny);

                impl Texture for IntegralTexture1d {
                    fn get_width(&self) -> u32 {
                        self.0.get_width()
                    }

                    fn get_height(&self) -> Option<u32> {
                        self.0.get_height()
                    }

                    fn get_depth(&self) -> Option<u32> {
                        self.0.get_depth()
                    }

                    fn get_array_size(&self) -> Option<u32> {
                        self.0.get_array_size()
                    }
                }
            

                impl GlObject for IntegralTexture1d {
                    type Id = gl::types::GLuint;
                    fn get_id(&self) -> gl::types::GLuint {
                        self.0.get_id()
                    }
                }
            

                impl ::std::fmt::Debug for IntegralTexture1d {
                    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> Result<(), ::std::fmt::Error>
                    {
                        self.0.fmt(f)
                    }
                }
            

                impl ::std::ops::Deref for IntegralTexture1d {
                    type Target = TextureAny;
                    
                    fn deref<'a>(&'a self) -> &'a TextureAny {
                        &self.0
                    }
                }
            

                            impl<'a> AsUniformValue for &'a IntegralTexture1d {
                                fn as_uniform_value(&self) -> UniformValue {
                                    UniformValue::IntegralTexture1d(*self, None)
                                }
                            }

                            impl<'a> AsUniformValue for Sampler<'a, IntegralTexture1d> {
                                fn as_uniform_value(&self) -> UniformValue {
                                    UniformValue::IntegralTexture1d(self.0, Some(self.1))
                                }
                            }

                            impl IntegralTexture1d {
                                /// Builds a `Sampler` marker object that allows you to indicate
                                /// how the texture should be sampled from inside a shader.
                                ///
                                /// # Example
                                ///
                                /// ```no_run
                                /// # #[macro_use] extern crate glium;
                                /// # fn main() {
                                /// # let texture: glium::texture::Texture2d = unsafe {
                                /// # ::std::mem::uninitialized() };
                                /// let uniforms = uniform! {
                                ///     color_texture: texture.sampled().magnify_filter(glium::uniforms::MagnifySamplerFilter::Nearest)
                                /// };
                                /// # }
                                /// ```
                                pub fn sampled(&self) -> Sampler<IntegralTexture1d> {
                                    Sampler(self, Default::default())
                                }
                            }
                        
impl IntegralTexture1d {

            /// Determines the internal format of this texture.
            ///
            /// The backend may not support querying the actual format, in which case an error
            /// is returned.
            pub fn get_internal_format(&self) -> Result<InternalFormat, GetFormatError> {
                self.0.get_internal_format()
            }
        

                /// Builds a new texture by uploading data.
                ///
                /// This function will automatically generate all mipmaps of the texture.
                pub fn new<'a, F, T>(facade: &F, data: T)
                              -> Result<IntegralTexture1d, TextureCreationError>
                              where T: Texture1dDataSource<'a>, F: Facade
                {
                    IntegralTexture1d::new_impl(facade, data, None, MipmapsOption::AutoGeneratedMipmaps)
                }
            

                /// Builds a new texture by uploading data.
                pub fn with_mipmaps<'a, F, T>(facade: &F, data: T, mipmaps: MipmapsOption)
                                              -> Result<IntegralTexture1d, TextureCreationError>
                                              where T: Texture1dDataSource<'a>, F: Facade
                {
                    IntegralTexture1d::new_impl(facade, data, None, mipmaps)
                }
            

                /// Builds a new texture with a specific format.
                pub fn with_format<'a, F, T>(facade: &F, data: T,
                                          format: UncompressedIntFormat, mipmaps: MipmapsOption)
                                          -> Result<IntegralTexture1d, TextureCreationError>
                                          where T: Texture1dDataSource<'a>, F: Facade
                {
                    IntegralTexture1d::new_impl(facade, data, Some(format), mipmaps)
                }
            

                fn new_impl<'a, F, T>(facade: &F, data: T,
                                   format: Option<UncompressedIntFormat>, mipmaps: MipmapsOption)
                                   -> Result<IntegralTexture1d, TextureCreationError>
                                   where T: Texture1dDataSource<'a>, F: Facade
                {
            
let format = format.map(|f| {
                           TextureFormatRequest::Specific(f.to_texture_format())
                       }).unwrap_or(TextureFormatRequest::AnyIntegral);
                    let RawImage1d { data, width, format: client_format } = data.into_raw();
                let client_format = ClientFormatAny::ClientFormat(client_format);Ok(IntegralTexture1d(try!(any::new_texture(facade, format, Some((client_format, data)), mipmaps.to_regular(), Dimensions::Texture1d { width: width }))))
}

                /// Creates an empty texture.
                ///
                /// No mipmap level (except for the main level) will be allocated or generated.
                ///
                /// The texture will contain undefined data.
                pub fn empty<F>(facade: &F, width: u32)
                                -> Result<IntegralTexture1d, TextureCreationError>
                                where F: Facade
                {
                    let format = TextureFormatRequest::AnyIntegral;
            
any::new_texture::<_, u8>(facade, format, None, MipmapsOption::NoMipmap.to_regular(), Dimensions::Texture1d { width: width }).map(|t| IntegralTexture1d(t))}

                /// Creates an empty texture with a specific format.
                ///
                /// The texture (and its mipmaps) will contain undefined data.
                pub fn empty_with_format<F>(facade: &F, format: UncompressedIntFormat, mipmaps: MipmapsOption, width: u32) -> Result<IntegralTexture1d, TextureCreationError> where F: Facade {
                    let format = format.to_texture_format();
                    let format = TextureFormatRequest::Specific(format);
            
let t = any::new_texture::<_, u8>(facade, format, None, mipmaps.to_regular(), Dimensions::Texture1d { width: width });
            t.map(|t| IntegralTexture1d(t))
}

                /// Creates an empty texture. Specifies whether is has mipmaps.
                ///
                /// The texture (and its mipmaps) will contain undefined data.
                pub fn empty_with_mipmaps<F>(facade: &F, mipmaps: MipmapsOption, width: u32) -> Result<IntegralTexture1d, TextureCreationError> where F: Facade {
                    let format = TextureFormatRequest::AnyIntegral;
            
any::new_texture::<_, u8>(facade, format, None, mipmaps.to_regular(), Dimensions::Texture1d { width: width }).map(|t| IntegralTexture1d(t))
}

            /// Returns the number of mipmap levels of the texture.
            ///
            /// The minimum value is 1, since there is always a main texture.
            pub fn get_mipmap_levels(&self) -> u32 {
                self.0.get_mipmap_levels()
            }
        
            /// Turns the texture into a `ResidentTexture`.
            ///
            /// This allows you to use the texture in a much more efficient way by storing
            /// a "reference to it" in a buffer (actually not a reference but a raw pointer).
            ///
            /// See the documentation of `ResidentTexture` for more infos.
            pub fn resident(self) -> Result<ResidentTexture, BindlessTexturesNotSupportedError> {
                ResidentTexture::new(self.0)
            }
        
                /// Access a single mipmap level of this texture.
                pub fn mipmap(&self, level: u32) -> Option<IntegralTexture1dMipmap> {
                    self.0.mipmap(0, level).map(|m| IntegralTexture1dMipmap(m, self))
                }
            
                /// Access the main mipmap level of this texture.
                pub fn main_level(&self) -> IntegralTexture1dMipmap {
                    self.mipmap(0).unwrap()
                }
            }

                    /// Represents a single mipmap level of a `IntegralTexture1d`.
                    ///
                    /// Can be obtained by calling `IntegralTexture1d::mipmap()` or `IntegralTexture1d::main_level()`.
                    #[derive(Copy, Clone)]
                    pub struct IntegralTexture1dMipmap<'t>(TextureAnyMipmap<'t>, &'t IntegralTexture1d);
                impl<'t> IntegralTexture1dMipmap<'t> {

                /// Returns the corresponding texture.
                pub fn get_texture(&self) -> &'t IntegralTexture1d {
                    self.1
                }

                /// Returns the texture level.
                pub fn get_level(&self) -> u32 {
                    self.0.get_level()
                }
            }
/// A one-dimensional texture  containing unsigned integral data.
pub struct UnsignedTexture1d(TextureAny);

                impl Texture for UnsignedTexture1d {
                    fn get_width(&self) -> u32 {
                        self.0.get_width()
                    }

                    fn get_height(&self) -> Option<u32> {
                        self.0.get_height()
                    }

                    fn get_depth(&self) -> Option<u32> {
                        self.0.get_depth()
                    }

                    fn get_array_size(&self) -> Option<u32> {
                        self.0.get_array_size()
                    }
                }
            

                impl GlObject for UnsignedTexture1d {
                    type Id = gl::types::GLuint;
                    fn get_id(&self) -> gl::types::GLuint {
                        self.0.get_id()
                    }
                }
            

                impl ::std::fmt::Debug for UnsignedTexture1d {
                    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> Result<(), ::std::fmt::Error>
                    {
                        self.0.fmt(f)
                    }
                }
            

                impl ::std::ops::Deref for UnsignedTexture1d {
                    type Target = TextureAny;
                    
                    fn deref<'a>(&'a self) -> &'a TextureAny {
                        &self.0
                    }
                }
            

                            impl<'a> AsUniformValue for &'a UnsignedTexture1d {
                                fn as_uniform_value(&self) -> UniformValue {
                                    UniformValue::UnsignedTexture1d(*self, None)
                                }
                            }

                            impl<'a> AsUniformValue for Sampler<'a, UnsignedTexture1d> {
                                fn as_uniform_value(&self) -> UniformValue {
                                    UniformValue::UnsignedTexture1d(self.0, Some(self.1))
                                }
                            }

                            impl UnsignedTexture1d {
                                /// Builds a `Sampler` marker object that allows you to indicate
                                /// how the texture should be sampled from inside a shader.
                                ///
                                /// # Example
                                ///
                                /// ```no_run
                                /// # #[macro_use] extern crate glium;
                                /// # fn main() {
                                /// # let texture: glium::texture::Texture2d = unsafe {
                                /// # ::std::mem::uninitialized() };
                                /// let uniforms = uniform! {
                                ///     color_texture: texture.sampled().magnify_filter(glium::uniforms::MagnifySamplerFilter::Nearest)
                                /// };
                                /// # }
                                /// ```
                                pub fn sampled(&self) -> Sampler<UnsignedTexture1d> {
                                    Sampler(self, Default::default())
                                }
                            }
                        
impl UnsignedTexture1d {

            /// Determines the internal format of this texture.
            ///
            /// The backend may not support querying the actual format, in which case an error
            /// is returned.
            pub fn get_internal_format(&self) -> Result<InternalFormat, GetFormatError> {
                self.0.get_internal_format()
            }
        

                /// Builds a new texture by uploading data.
                ///
                /// This function will automatically generate all mipmaps of the texture.
                pub fn new<'a, F, T>(facade: &F, data: T)
                              -> Result<UnsignedTexture1d, TextureCreationError>
                              where T: Texture1dDataSource<'a>, F: Facade
                {
                    UnsignedTexture1d::new_impl(facade, data, None, MipmapsOption::AutoGeneratedMipmaps)
                }
            

                /// Builds a new texture by uploading data.
                pub fn with_mipmaps<'a, F, T>(facade: &F, data: T, mipmaps: MipmapsOption)
                                              -> Result<UnsignedTexture1d, TextureCreationError>
                                              where T: Texture1dDataSource<'a>, F: Facade
                {
                    UnsignedTexture1d::new_impl(facade, data, None, mipmaps)
                }
            

                /// Builds a new texture with a specific format.
                pub fn with_format<'a, F, T>(facade: &F, data: T,
                                          format: UncompressedUintFormat, mipmaps: MipmapsOption)
                                          -> Result<UnsignedTexture1d, TextureCreationError>
                                          where T: Texture1dDataSource<'a>, F: Facade
                {
                    UnsignedTexture1d::new_impl(facade, data, Some(format), mipmaps)
                }
            

                fn new_impl<'a, F, T>(facade: &F, data: T,
                                   format: Option<UncompressedUintFormat>, mipmaps: MipmapsOption)
                                   -> Result<UnsignedTexture1d, TextureCreationError>
                                   where T: Texture1dDataSource<'a>, F: Facade
                {
            
let format = format.map(|f| {
                           TextureFormatRequest::Specific(f.to_texture_format())
                       }).unwrap_or(TextureFormatRequest::AnyUnsigned);
                    let RawImage1d { data, width, format: client_format } = data.into_raw();
                let client_format = ClientFormatAny::ClientFormat(client_format);Ok(UnsignedTexture1d(try!(any::new_texture(facade, format, Some((client_format, data)), mipmaps.to_regular(), Dimensions::Texture1d { width: width }))))
}

                /// Creates an empty texture.
                ///
                /// No mipmap level (except for the main level) will be allocated or generated.
                ///
                /// The texture will contain undefined data.
                pub fn empty<F>(facade: &F, width: u32)
                                -> Result<UnsignedTexture1d, TextureCreationError>
                                where F: Facade
                {
                    let format = TextureFormatRequest::AnyUnsigned;
            
any::new_texture::<_, u8>(facade, format, None, MipmapsOption::NoMipmap.to_regular(), Dimensions::Texture1d { width: width }).map(|t| UnsignedTexture1d(t))}

                /// Creates an empty texture with a specific format.
                ///
                /// The texture (and its mipmaps) will contain undefined data.
                pub fn empty_with_format<F>(facade: &F, format: UncompressedUintFormat, mipmaps: MipmapsOption, width: u32) -> Result<UnsignedTexture1d, TextureCreationError> where F: Facade {
                    let format = format.to_texture_format();
                    let format = TextureFormatRequest::Specific(format);
            
let t = any::new_texture::<_, u8>(facade, format, None, mipmaps.to_regular(), Dimensions::Texture1d { width: width });
            t.map(|t| UnsignedTexture1d(t))
}

                /// Creates an empty texture. Specifies whether is has mipmaps.
                ///
                /// The texture (and its mipmaps) will contain undefined data.
                pub fn empty_with_mipmaps<F>(facade: &F, mipmaps: MipmapsOption, width: u32) -> Result<UnsignedTexture1d, TextureCreationError> where F: Facade {
                    let format = TextureFormatRequest::AnyUnsigned;
            
any::new_texture::<_, u8>(facade, format, None, mipmaps.to_regular(), Dimensions::Texture1d { width: width }).map(|t| UnsignedTexture1d(t))
}

            /// Returns the number of mipmap levels of the texture.
            ///
            /// The minimum value is 1, since there is always a main texture.
            pub fn get_mipmap_levels(&self) -> u32 {
                self.0.get_mipmap_levels()
            }
        
            /// Turns the texture into a `ResidentTexture`.
            ///
            /// This allows you to use the texture in a much more efficient way by storing
            /// a "reference to it" in a buffer (actually not a reference but a raw pointer).
            ///
            /// See the documentation of `ResidentTexture` for more infos.
            pub fn resident(self) -> Result<ResidentTexture, BindlessTexturesNotSupportedError> {
                ResidentTexture::new(self.0)
            }
        
                /// Access a single mipmap level of this texture.
                pub fn mipmap(&self, level: u32) -> Option<UnsignedTexture1dMipmap> {
                    self.0.mipmap(0, level).map(|m| UnsignedTexture1dMipmap(m, self))
                }
            
                /// Access the main mipmap level of this texture.
                pub fn main_level(&self) -> UnsignedTexture1dMipmap {
                    self.mipmap(0).unwrap()
                }
            }

                    /// Represents a single mipmap level of a `UnsignedTexture1d`.
                    ///
                    /// Can be obtained by calling `UnsignedTexture1d::mipmap()` or `UnsignedTexture1d::main_level()`.
                    #[derive(Copy, Clone)]
                    pub struct UnsignedTexture1dMipmap<'t>(TextureAnyMipmap<'t>, &'t UnsignedTexture1d);
                impl<'t> UnsignedTexture1dMipmap<'t> {

                /// Returns the corresponding texture.
                pub fn get_texture(&self) -> &'t UnsignedTexture1d {
                    self.1
                }

                /// Returns the texture level.
                pub fn get_level(&self) -> u32 {
                    self.0.get_level()
                }
            }
/// A one-dimensional texture  containing depth data.
pub struct DepthTexture1d(TextureAny);

                impl Texture for DepthTexture1d {
                    fn get_width(&self) -> u32 {
                        self.0.get_width()
                    }

                    fn get_height(&self) -> Option<u32> {
                        self.0.get_height()
                    }

                    fn get_depth(&self) -> Option<u32> {
                        self.0.get_depth()
                    }

                    fn get_array_size(&self) -> Option<u32> {
                        self.0.get_array_size()
                    }
                }
            

                impl GlObject for DepthTexture1d {
                    type Id = gl::types::GLuint;
                    fn get_id(&self) -> gl::types::GLuint {
                        self.0.get_id()
                    }
                }
            

                impl ::std::fmt::Debug for DepthTexture1d {
                    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> Result<(), ::std::fmt::Error>
                    {
                        self.0.fmt(f)
                    }
                }
            

                impl ::std::ops::Deref for DepthTexture1d {
                    type Target = TextureAny;
                    
                    fn deref<'a>(&'a self) -> &'a TextureAny {
                        &self.0
                    }
                }
            

                            impl<'a> AsUniformValue for &'a DepthTexture1d {
                                fn as_uniform_value(&self) -> UniformValue {
                                    UniformValue::DepthTexture1d(*self, None)
                                }
                            }

                            impl<'a> AsUniformValue for Sampler<'a, DepthTexture1d> {
                                fn as_uniform_value(&self) -> UniformValue {
                                    UniformValue::DepthTexture1d(self.0, Some(self.1))
                                }
                            }

                            impl DepthTexture1d {
                                /// Builds a `Sampler` marker object that allows you to indicate
                                /// how the texture should be sampled from inside a shader.
                                ///
                                /// # Example
                                ///
                                /// ```no_run
                                /// # #[macro_use] extern crate glium;
                                /// # fn main() {
                                /// # let texture: glium::texture::Texture2d = unsafe {
                                /// # ::std::mem::uninitialized() };
                                /// let uniforms = uniform! {
                                ///     color_texture: texture.sampled().magnify_filter(glium::uniforms::MagnifySamplerFilter::Nearest)
                                /// };
                                /// # }
                                /// ```
                                pub fn sampled(&self) -> Sampler<DepthTexture1d> {
                                    Sampler(self, Default::default())
                                }
                            }
                        
impl DepthTexture1d {

            /// Determines the internal format of this texture.
            ///
            /// The backend may not support querying the actual format, in which case an error
            /// is returned.
            pub fn get_internal_format(&self) -> Result<InternalFormat, GetFormatError> {
                self.0.get_internal_format()
            }
        

                /// Builds a new texture by uploading data.
                ///
                /// This function will automatically generate all mipmaps of the texture.
                pub fn new<'a, F, T>(facade: &F, data: T)
                              -> Result<DepthTexture1d, TextureCreationError>
                              where T: Texture1dDataSource<'a>, F: Facade
                {
                    DepthTexture1d::new_impl(facade, data, None, MipmapsOption::AutoGeneratedMipmaps)
                }
            

                /// Builds a new texture by uploading data.
                pub fn with_mipmaps<'a, F, T>(facade: &F, data: T, mipmaps: MipmapsOption)
                                              -> Result<DepthTexture1d, TextureCreationError>
                                              where T: Texture1dDataSource<'a>, F: Facade
                {
                    DepthTexture1d::new_impl(facade, data, None, mipmaps)
                }
            

                /// Builds a new texture with a specific format.
                pub fn with_format<'a, F, T>(facade: &F, data: T,
                                          format: DepthFormat, mipmaps: MipmapsOption)
                                          -> Result<DepthTexture1d, TextureCreationError>
                                          where T: Texture1dDataSource<'a>, F: Facade
                {
                    DepthTexture1d::new_impl(facade, data, Some(format), mipmaps)
                }
            

                fn new_impl<'a, F, T>(facade: &F, data: T,
                                   format: Option<DepthFormat>, mipmaps: MipmapsOption)
                                   -> Result<DepthTexture1d, TextureCreationError>
                                   where T: Texture1dDataSource<'a>, F: Facade
                {
            
let format = format.map(|f| {
                           TextureFormatRequest::Specific(f.to_texture_format())
                       }).unwrap_or(TextureFormatRequest::AnyDepth);
                    let RawImage1d { data, width, format: client_format } = data.into_raw();
                let client_format = ClientFormatAny::ClientFormat(client_format);Ok(DepthTexture1d(try!(any::new_texture(facade, format, Some((client_format, data)), mipmaps.to_regular(), Dimensions::Texture1d { width: width }))))
}

                /// Creates an empty texture.
                ///
                /// No mipmap level (except for the main level) will be allocated or generated.
                ///
                /// The texture will contain undefined data.
                pub fn empty<F>(facade: &F, width: u32)
                                -> Result<DepthTexture1d, TextureCreationError>
                                where F: Facade
                {
                    let format = TextureFormatRequest::AnyDepth;
            
any::new_texture::<_, u8>(facade, format, None, MipmapsOption::NoMipmap.to_regular(), Dimensions::Texture1d { width: width }).map(|t| DepthTexture1d(t))}

                /// Creates an empty texture with a specific format.
                ///
                /// The texture (and its mipmaps) will contain undefined data.
                pub fn empty_with_format<F>(facade: &F, format: DepthFormat, mipmaps: MipmapsOption, width: u32) -> Result<DepthTexture1d, TextureCreationError> where F: Facade {
                    let format = format.to_texture_format();
                    let format = TextureFormatRequest::Specific(format);
            
let t = any::new_texture::<_, u8>(facade, format, None, mipmaps.to_regular(), Dimensions::Texture1d { width: width });
            t.map(|t| DepthTexture1d(t))
}

                /// Creates an empty texture. Specifies whether is has mipmaps.
                ///
                /// The texture (and its mipmaps) will contain undefined data.
                pub fn empty_with_mipmaps<F>(facade: &F, mipmaps: MipmapsOption, width: u32) -> Result<DepthTexture1d, TextureCreationError> where F: Facade {
                    let format = TextureFormatRequest::AnyDepth;
            
any::new_texture::<_, u8>(facade, format, None, mipmaps.to_regular(), Dimensions::Texture1d { width: width }).map(|t| DepthTexture1d(t))
}

            /// Returns the number of mipmap levels of the texture.
            ///
            /// The minimum value is 1, since there is always a main texture.
            pub fn get_mipmap_levels(&self) -> u32 {
                self.0.get_mipmap_levels()
            }
        
            /// Turns the texture into a `ResidentTexture`.
            ///
            /// This allows you to use the texture in a much more efficient way by storing
            /// a "reference to it" in a buffer (actually not a reference but a raw pointer).
            ///
            /// See the documentation of `ResidentTexture` for more infos.
            pub fn resident(self) -> Result<ResidentTexture, BindlessTexturesNotSupportedError> {
                ResidentTexture::new(self.0)
            }
        
                /// Access a single mipmap level of this texture.
                pub fn mipmap(&self, level: u32) -> Option<DepthTexture1dMipmap> {
                    self.0.mipmap(0, level).map(|m| DepthTexture1dMipmap(m, self))
                }
            
                /// Access the main mipmap level of this texture.
                pub fn main_level(&self) -> DepthTexture1dMipmap {
                    self.mipmap(0).unwrap()
                }
            }

                    /// Represents a single mipmap level of a `DepthTexture1d`.
                    ///
                    /// Can be obtained by calling `DepthTexture1d::mipmap()` or `DepthTexture1d::main_level()`.
                    #[derive(Copy, Clone)]
                    pub struct DepthTexture1dMipmap<'t>(TextureAnyMipmap<'t>, &'t DepthTexture1d);
                impl<'t> DepthTexture1dMipmap<'t> {

                /// Returns the corresponding texture.
                pub fn get_texture(&self) -> &'t DepthTexture1d {
                    self.1
                }

                /// Returns the texture level.
                pub fn get_level(&self) -> u32 {
                    self.0.get_level()
                }
            }
/// A one-dimensional texture  containing stencil data.
pub struct StencilTexture1d(TextureAny);

                impl Texture for StencilTexture1d {
                    fn get_width(&self) -> u32 {
                        self.0.get_width()
                    }

                    fn get_height(&self) -> Option<u32> {
                        self.0.get_height()
                    }

                    fn get_depth(&self) -> Option<u32> {
                        self.0.get_depth()
                    }

                    fn get_array_size(&self) -> Option<u32> {
                        self.0.get_array_size()
                    }
                }
            

                impl GlObject for StencilTexture1d {
                    type Id = gl::types::GLuint;
                    fn get_id(&self) -> gl::types::GLuint {
                        self.0.get_id()
                    }
                }
            

                impl ::std::fmt::Debug for StencilTexture1d {
                    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> Result<(), ::std::fmt::Error>
                    {
                        self.0.fmt(f)
                    }
                }
            

                impl ::std::ops::Deref for StencilTexture1d {
                    type Target = TextureAny;
                    
                    fn deref<'a>(&'a self) -> &'a TextureAny {
                        &self.0
                    }
                }
            
impl StencilTexture1d {

            /// Determines the internal format of this texture.
            ///
            /// The backend may not support querying the actual format, in which case an error
            /// is returned.
            pub fn get_internal_format(&self) -> Result<InternalFormat, GetFormatError> {
                self.0.get_internal_format()
            }
        

                /// Builds a new texture by uploading data.
                ///
                /// This function will automatically generate all mipmaps of the texture.
                pub fn new<'a, F, T>(facade: &F, data: T)
                              -> Result<StencilTexture1d, TextureCreationError>
                              where T: Texture1dDataSource<'a>, F: Facade
                {
                    StencilTexture1d::new_impl(facade, data, None, MipmapsOption::AutoGeneratedMipmaps)
                }
            

                /// Builds a new texture by uploading data.
                pub fn with_mipmaps<'a, F, T>(facade: &F, data: T, mipmaps: MipmapsOption)
                                              -> Result<StencilTexture1d, TextureCreationError>
                                              where T: Texture1dDataSource<'a>, F: Facade
                {
                    StencilTexture1d::new_impl(facade, data, None, mipmaps)
                }
            

                /// Builds a new texture with a specific format.
                pub fn with_format<'a, F, T>(facade: &F, data: T,
                                          format: StencilFormat, mipmaps: MipmapsOption)
                                          -> Result<StencilTexture1d, TextureCreationError>
                                          where T: Texture1dDataSource<'a>, F: Facade
                {
                    StencilTexture1d::new_impl(facade, data, Some(format), mipmaps)
                }
            

                fn new_impl<'a, F, T>(facade: &F, data: T,
                                   format: Option<StencilFormat>, mipmaps: MipmapsOption)
                                   -> Result<StencilTexture1d, TextureCreationError>
                                   where T: Texture1dDataSource<'a>, F: Facade
                {
            
let format = format.map(|f| {
                           TextureFormatRequest::Specific(f.to_texture_format())
                       }).unwrap_or(TextureFormatRequest::AnyStencil);
                    let RawImage1d { data, width, format: client_format } = data.into_raw();
                let client_format = ClientFormatAny::ClientFormat(client_format);Ok(StencilTexture1d(try!(any::new_texture(facade, format, Some((client_format, data)), mipmaps.to_regular(), Dimensions::Texture1d { width: width }))))
}

                /// Creates an empty texture.
                ///
                /// No mipmap level (except for the main level) will be allocated or generated.
                ///
                /// The texture will contain undefined data.
                pub fn empty<F>(facade: &F, width: u32)
                                -> Result<StencilTexture1d, TextureCreationError>
                                where F: Facade
                {
                    let format = TextureFormatRequest::AnyStencil;
            
any::new_texture::<_, u8>(facade, format, None, MipmapsOption::NoMipmap.to_regular(), Dimensions::Texture1d { width: width }).map(|t| StencilTexture1d(t))}

                /// Creates an empty texture with a specific format.
                ///
                /// The texture (and its mipmaps) will contain undefined data.
                pub fn empty_with_format<F>(facade: &F, format: StencilFormat, mipmaps: MipmapsOption, width: u32) -> Result<StencilTexture1d, TextureCreationError> where F: Facade {
                    let format = format.to_texture_format();
                    let format = TextureFormatRequest::Specific(format);
            
let t = any::new_texture::<_, u8>(facade, format, None, mipmaps.to_regular(), Dimensions::Texture1d { width: width });
            t.map(|t| StencilTexture1d(t))
}

                /// Creates an empty texture. Specifies whether is has mipmaps.
                ///
                /// The texture (and its mipmaps) will contain undefined data.
                pub fn empty_with_mipmaps<F>(facade: &F, mipmaps: MipmapsOption, width: u32) -> Result<StencilTexture1d, TextureCreationError> where F: Facade {
                    let format = TextureFormatRequest::AnyStencil;
            
any::new_texture::<_, u8>(facade, format, None, mipmaps.to_regular(), Dimensions::Texture1d { width: width }).map(|t| StencilTexture1d(t))
}

            /// Returns the number of mipmap levels of the texture.
            ///
            /// The minimum value is 1, since there is always a main texture.
            pub fn get_mipmap_levels(&self) -> u32 {
                self.0.get_mipmap_levels()
            }
        
            /// Turns the texture into a `ResidentTexture`.
            ///
            /// This allows you to use the texture in a much more efficient way by storing
            /// a "reference to it" in a buffer (actually not a reference but a raw pointer).
            ///
            /// See the documentation of `ResidentTexture` for more infos.
            pub fn resident(self) -> Result<ResidentTexture, BindlessTexturesNotSupportedError> {
                ResidentTexture::new(self.0)
            }
        
                /// Access a single mipmap level of this texture.
                pub fn mipmap(&self, level: u32) -> Option<StencilTexture1dMipmap> {
                    self.0.mipmap(0, level).map(|m| StencilTexture1dMipmap(m, self))
                }
            
                /// Access the main mipmap level of this texture.
                pub fn main_level(&self) -> StencilTexture1dMipmap {
                    self.mipmap(0).unwrap()
                }
            }

                    /// Represents a single mipmap level of a `StencilTexture1d`.
                    ///
                    /// Can be obtained by calling `StencilTexture1d::mipmap()` or `StencilTexture1d::main_level()`.
                    #[derive(Copy, Clone)]
                    pub struct StencilTexture1dMipmap<'t>(TextureAnyMipmap<'t>, &'t StencilTexture1d);
                impl<'t> StencilTexture1dMipmap<'t> {

                /// Returns the corresponding texture.
                pub fn get_texture(&self) -> &'t StencilTexture1d {
                    self.1
                }

                /// Returns the texture level.
                pub fn get_level(&self) -> u32 {
                    self.0.get_level()
                }
            }
/// A one-dimensional texture  containing both depth and stencil data.
pub struct DepthStencilTexture1d(TextureAny);

                impl Texture for DepthStencilTexture1d {
                    fn get_width(&self) -> u32 {
                        self.0.get_width()
                    }

                    fn get_height(&self) -> Option<u32> {
                        self.0.get_height()
                    }

                    fn get_depth(&self) -> Option<u32> {
                        self.0.get_depth()
                    }

                    fn get_array_size(&self) -> Option<u32> {
                        self.0.get_array_size()
                    }
                }
            

                impl GlObject for DepthStencilTexture1d {
                    type Id = gl::types::GLuint;
                    fn get_id(&self) -> gl::types::GLuint {
                        self.0.get_id()
                    }
                }
            

                impl ::std::fmt::Debug for DepthStencilTexture1d {
                    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> Result<(), ::std::fmt::Error>
                    {
                        self.0.fmt(f)
                    }
                }
            

                impl ::std::ops::Deref for DepthStencilTexture1d {
                    type Target = TextureAny;
                    
                    fn deref<'a>(&'a self) -> &'a TextureAny {
                        &self.0
                    }
                }
            
impl DepthStencilTexture1d {

            /// Determines the internal format of this texture.
            ///
            /// The backend may not support querying the actual format, in which case an error
            /// is returned.
            pub fn get_internal_format(&self) -> Result<InternalFormat, GetFormatError> {
                self.0.get_internal_format()
            }
        

                /// Builds a new texture by uploading data.
                ///
                /// This function will automatically generate all mipmaps of the texture.
                pub fn new<'a, F, T>(facade: &F, data: T)
                              -> Result<DepthStencilTexture1d, TextureCreationError>
                              where T: Texture1dDataSource<'a>, F: Facade
                {
                    DepthStencilTexture1d::new_impl(facade, data, None, MipmapsOption::AutoGeneratedMipmaps)
                }
            

                /// Builds a new texture by uploading data.
                pub fn with_mipmaps<'a, F, T>(facade: &F, data: T, mipmaps: MipmapsOption)
                                              -> Result<DepthStencilTexture1d, TextureCreationError>
                                              where T: Texture1dDataSource<'a>, F: Facade
                {
                    DepthStencilTexture1d::new_impl(facade, data, None, mipmaps)
                }
            

                /// Builds a new texture with a specific format.
                pub fn with_format<'a, F, T>(facade: &F, data: T,
                                          format: DepthStencilFormat, mipmaps: MipmapsOption)
                                          -> Result<DepthStencilTexture1d, TextureCreationError>
                                          where T: Texture1dDataSource<'a>, F: Facade
                {
                    DepthStencilTexture1d::new_impl(facade, data, Some(format), mipmaps)
                }
            

                fn new_impl<'a, F, T>(facade: &F, data: T,
                                   format: Option<DepthStencilFormat>, mipmaps: MipmapsOption)
                                   -> Result<DepthStencilTexture1d, TextureCreationError>
                                   where T: Texture1dDataSource<'a>, F: Facade
                {
            
let format = format.map(|f| {
                           TextureFormatRequest::Specific(f.to_texture_format())
                       }).unwrap_or(TextureFormatRequest::AnyDepthStencil);
                    let RawImage1d { data, width, format: client_format } = data.into_raw();
                let client_format = ClientFormatAny::ClientFormat(client_format);Ok(DepthStencilTexture1d(try!(any::new_texture(facade, format, Some((client_format, data)), mipmaps.to_regular(), Dimensions::Texture1d { width: width }))))
}

                /// Creates an empty texture.
                ///
                /// No mipmap level (except for the main level) will be allocated or generated.
                ///
                /// The texture will contain undefined data.
                pub fn empty<F>(facade: &F, width: u32)
                                -> Result<DepthStencilTexture1d, TextureCreationError>
                                where F: Facade
                {
                    let format = TextureFormatRequest::AnyDepthStencil;
            
any::new_texture::<_, u8>(facade, format, None, MipmapsOption::NoMipmap.to_regular(), Dimensions::Texture1d { width: width }).map(|t| DepthStencilTexture1d(t))}

                /// Creates an empty texture with a specific format.
                ///
                /// The texture (and its mipmaps) will contain undefined data.
                pub fn empty_with_format<F>(facade: &F, format: DepthStencilFormat, mipmaps: MipmapsOption, width: u32) -> Result<DepthStencilTexture1d, TextureCreationError> where F: Facade {
                    let format = format.to_texture_format();
                    let format = TextureFormatRequest::Specific(format);
            
let t = any::new_texture::<_, u8>(facade, format, None, mipmaps.to_regular(), Dimensions::Texture1d { width: width });
            t.map(|t| DepthStencilTexture1d(t))
}

                /// Creates an empty texture. Specifies whether is has mipmaps.
                ///
                /// The texture (and its mipmaps) will contain undefined data.
                pub fn empty_with_mipmaps<F>(facade: &F, mipmaps: MipmapsOption, width: u32) -> Result<DepthStencilTexture1d, TextureCreationError> where F: Facade {
                    let format = TextureFormatRequest::AnyDepthStencil;
            
any::new_texture::<_, u8>(facade, format, None, mipmaps.to_regular(), Dimensions::Texture1d { width: width }).map(|t| DepthStencilTexture1d(t))
}

            /// Returns the number of mipmap levels of the texture.
            ///
            /// The minimum value is 1, since there is always a main texture.
            pub fn get_mipmap_levels(&self) -> u32 {
                self.0.get_mipmap_levels()
            }
        
            /// Turns the texture into a `ResidentTexture`.
            ///
            /// This allows you to use the texture in a much more efficient way by storing
            /// a "reference to it" in a buffer (actually not a reference but a raw pointer).
            ///
            /// See the documentation of `ResidentTexture` for more infos.
            pub fn resident(self) -> Result<ResidentTexture, BindlessTexturesNotSupportedError> {
                ResidentTexture::new(self.0)
            }
        
                /// Access a single mipmap level of this texture.
                pub fn mipmap(&self, level: u32) -> Option<DepthStencilTexture1dMipmap> {
                    self.0.mipmap(0, level).map(|m| DepthStencilTexture1dMipmap(m, self))
                }
            
                /// Access the main mipmap level of this texture.
                pub fn main_level(&self) -> DepthStencilTexture1dMipmap {
                    self.mipmap(0).unwrap()
                }
            }

                    /// Represents a single mipmap level of a `DepthStencilTexture1d`.
                    ///
                    /// Can be obtained by calling `DepthStencilTexture1d::mipmap()` or `DepthStencilTexture1d::main_level()`.
                    #[derive(Copy, Clone)]
                    pub struct DepthStencilTexture1dMipmap<'t>(TextureAnyMipmap<'t>, &'t DepthStencilTexture1d);
                impl<'t> DepthStencilTexture1dMipmap<'t> {

                /// Returns the corresponding texture.
                pub fn get_texture(&self) -> &'t DepthStencilTexture1d {
                    self.1
                }

                /// Returns the texture level.
                pub fn get_level(&self) -> u32 {
                    self.0.get_level()
                }
            }
/// A two-dimensional texture  containing floating-point data.
pub struct Texture2d(TextureAny);

                impl Texture for Texture2d {
                    fn get_width(&self) -> u32 {
                        self.0.get_width()
                    }

                    fn get_height(&self) -> Option<u32> {
                        self.0.get_height()
                    }

                    fn get_depth(&self) -> Option<u32> {
                        self.0.get_depth()
                    }

                    fn get_array_size(&self) -> Option<u32> {
                        self.0.get_array_size()
                    }
                }
            

                impl GlObject for Texture2d {
                    type Id = gl::types::GLuint;
                    fn get_id(&self) -> gl::types::GLuint {
                        self.0.get_id()
                    }
                }
            

                impl ::std::fmt::Debug for Texture2d {
                    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> Result<(), ::std::fmt::Error>
                    {
                        self.0.fmt(f)
                    }
                }
            

                impl ::std::ops::Deref for Texture2d {
                    type Target = TextureAny;
                    
                    fn deref<'a>(&'a self) -> &'a TextureAny {
                        &self.0
                    }
                }
            

                            impl<'a> AsUniformValue for &'a Texture2d {
                                fn as_uniform_value(&self) -> UniformValue {
                                    UniformValue::Texture2d(*self, None)
                                }
                            }

                            impl<'a> AsUniformValue for Sampler<'a, Texture2d> {
                                fn as_uniform_value(&self) -> UniformValue {
                                    UniformValue::Texture2d(self.0, Some(self.1))
                                }
                            }

                            impl Texture2d {
                                /// Builds a `Sampler` marker object that allows you to indicate
                                /// how the texture should be sampled from inside a shader.
                                ///
                                /// # Example
                                ///
                                /// ```no_run
                                /// # #[macro_use] extern crate glium;
                                /// # fn main() {
                                /// # let texture: glium::texture::Texture2d = unsafe {
                                /// # ::std::mem::uninitialized() };
                                /// let uniforms = uniform! {
                                ///     color_texture: texture.sampled().magnify_filter(glium::uniforms::MagnifySamplerFilter::Nearest)
                                /// };
                                /// # }
                                /// ```
                                pub fn sampled(&self) -> Sampler<Texture2d> {
                                    Sampler(self, Default::default())
                                }
                            }
                        

                        impl ::framebuffer::ToColorAttachment for Texture2d {
                            fn to_color_attachment(&self) -> ::framebuffer::ColorAttachment {
                                ::framebuffer::ColorAttachment::Texture(self.0.mipmap(0, 0).unwrap())
                            }
                        }
                    
impl Texture2d {

            /// Determines the internal format of this texture.
            ///
            /// The backend may not support querying the actual format, in which case an error
            /// is returned.
            pub fn get_internal_format(&self) -> Result<InternalFormat, GetFormatError> {
                self.0.get_internal_format()
            }
        

                /// Builds a new texture by uploading data.
                ///
                /// This function will automatically generate all mipmaps of the texture.
                pub fn new<'a, F, T>(facade: &F, data: T)
                              -> Result<Texture2d, TextureCreationError>
                              where T: Texture2dDataSource<'a>, F: Facade
                {
                    Texture2d::new_impl(facade, data, None, MipmapsOption::AutoGeneratedMipmaps)
                }
            

                /// Builds a new texture by uploading data.
                pub fn with_mipmaps<'a, F, T>(facade: &F, data: T, mipmaps: MipmapsOption)
                                              -> Result<Texture2d, TextureCreationError>
                                              where T: Texture2dDataSource<'a>, F: Facade
                {
                    Texture2d::new_impl(facade, data, None, mipmaps)
                }
            

                /// Builds a new texture with a specific format.
                pub fn with_format<'a, F, T>(facade: &F, data: T,
                                          format: UncompressedFloatFormat, mipmaps: MipmapsOption)
                                          -> Result<Texture2d, TextureCreationError>
                                          where T: Texture2dDataSource<'a>, F: Facade
                {
                    Texture2d::new_impl(facade, data, Some(format), mipmaps)
                }
            

                fn new_impl<'a, F, T>(facade: &F, data: T,
                                   format: Option<UncompressedFloatFormat>, mipmaps: MipmapsOption)
                                   -> Result<Texture2d, TextureCreationError>
                                   where T: Texture2dDataSource<'a>, F: Facade
                {
            
let format = format.map(|f| {
                           TextureFormatRequest::Specific(f.to_texture_format())
                       }).unwrap_or(TextureFormatRequest::AnyFloatingPoint);
                    let RawImage2d { data, width, height, format: client_format } =
                                            data.into_raw();
                let client_format = ClientFormatAny::ClientFormat(client_format);Ok(Texture2d(try!(any::new_texture(facade, format, Some((client_format, data)), mipmaps.to_regular(), Dimensions::Texture2d { width: width, height: height }))))
}

                /// Creates an empty texture.
                ///
                /// No mipmap level (except for the main level) will be allocated or generated.
                ///
                /// The texture will contain undefined data.
                pub fn empty<F>(facade: &F, width: u32, height: u32)
                                -> Result<Texture2d, TextureCreationError>
                                where F: Facade
                {
                    let format = TextureFormatRequest::AnyFloatingPoint;
            
any::new_texture::<_, u8>(facade, format, None, MipmapsOption::NoMipmap.to_regular(), Dimensions::Texture2d { width: width, height: height }).map(|t| Texture2d(t))}

                /// Creates an empty texture with a specific format.
                ///
                /// The texture (and its mipmaps) will contain undefined data.
                pub fn empty_with_format<F>(facade: &F, format: UncompressedFloatFormat, mipmaps: MipmapsOption, width: u32, height: u32) -> Result<Texture2d, TextureCreationError> where F: Facade {
                    let format = format.to_texture_format();
                    let format = TextureFormatRequest::Specific(format);
            
let t = any::new_texture::<_, u8>(facade, format, None, mipmaps.to_regular(), Dimensions::Texture2d { width: width, height: height });
            t.map(|t| Texture2d(t))
}

                /// Creates an empty texture. Specifies whether is has mipmaps.
                ///
                /// The texture (and its mipmaps) will contain undefined data.
                pub fn empty_with_mipmaps<F>(facade: &F, mipmaps: MipmapsOption, width: u32, height: u32) -> Result<Texture2d, TextureCreationError> where F: Facade {
                    let format = TextureFormatRequest::AnyFloatingPoint;
            
any::new_texture::<_, u8>(facade, format, None, mipmaps.to_regular(), Dimensions::Texture2d { width: width, height: height }).map(|t| Texture2d(t))
}

                /// Starts drawing on the texture.
                ///
                /// All the function calls to the framebuffer will draw on the texture instead
                /// of the screen.
                ///
                /// ## Low-level information
                ///
                /// The first time that this function is called, a FrameBuffer Object will be
                /// created and cached. The following calls to `as_surface` will load the existing
                /// FBO and re-use it. When the texture is destroyed, the FBO is destroyed too.
                ///
                pub fn as_surface<'a>(&'a self) -> framebuffer::SimpleFrameBuffer<'a> {
                    framebuffer::SimpleFrameBuffer::new(self.0.get_context(), self)
                }
            
            /// Returns the number of mipmap levels of the texture.
            ///
            /// The minimum value is 1, since there is always a main texture.
            pub fn get_mipmap_levels(&self) -> u32 {
                self.0.get_mipmap_levels()
            }
        
                /// Reads the content of the texture to RAM.
                ///
                /// You should avoid doing this at all cost during performance-critical
                /// operations (for example, while you're drawing).
                /// Use `read_to_pixel_buffer` instead.
                pub fn read<T>(&self) -> T where T: Texture2dDataSink<(u8, u8, u8, u8)> {
                    self.0.mipmap(0, 0).unwrap().read()
                }
            
                /// Reads the content of the texture into a buffer in video memory.
                ///
                /// This operation copies the texture's data into a buffer in video memory
                /// (a pixel buffer). Contrary to the `read` function, this operation is
                /// done asynchronously and doesn't need a synchronization.
                pub fn read_to_pixel_buffer(&self) -> PixelBuffer<(u8, u8, u8, u8)> {
                    self.0.mipmap(0, 0).unwrap().read_to_pixel_buffer()
                }
            
                /// Uploads some data in the texture.
                ///
                /// Note that this may cause a synchronization if you use the texture right before
                /// or right after this call. Prefer creating a whole new texture if you change a
                /// huge part of it.
                ///
                /// ## Panic
                ///
                /// Panics if the the dimensions of `data` don't match the `Rect`.
                
                pub fn write<'a, T>(&self, rect: Rect, data: T) where T: Texture2dDataSource<'a> {
                    self.main_level().write(rect, data)
                }
            
            /// Turns the texture into a `ResidentTexture`.
            ///
            /// This allows you to use the texture in a much more efficient way by storing
            /// a "reference to it" in a buffer (actually not a reference but a raw pointer).
            ///
            /// See the documentation of `ResidentTexture` for more infos.
            pub fn resident(self) -> Result<ResidentTexture, BindlessTexturesNotSupportedError> {
                ResidentTexture::new(self.0)
            }
        
                /// Access a single mipmap level of this texture.
                pub fn mipmap(&self, level: u32) -> Option<Texture2dMipmap> {
                    self.0.mipmap(0, level).map(|m| Texture2dMipmap(m, self))
                }
            
                /// Access the main mipmap level of this texture.
                pub fn main_level(&self) -> Texture2dMipmap {
                    self.mipmap(0).unwrap()
                }
            }

                    /// Represents a single mipmap level of a `Texture2d`.
                    ///
                    /// Can be obtained by calling `Texture2d::mipmap()` or `Texture2d::main_level()`.
                    #[derive(Copy, Clone)]
                    pub struct Texture2dMipmap<'t>(TextureAnyMipmap<'t>, &'t Texture2d);
                impl<'t> Texture2dMipmap<'t> {

                    /// Uploads some data in the texture level.
                    ///
                    /// Note that this may cause a synchronization if you use the texture right before
                    /// or right after this call.
                    ///
                    /// ## Panic
                    ///
                    /// Panics if the the dimensions of `data` don't match the `Rect`.
                    
                    pub fn write<'a, T>(&self, rect: Rect, data: T) where T: Texture2dDataSource<'a> {
                        let RawImage2d { data, width, height, format: client_format } =
                                                data.into_raw();

                        assert_eq!(width, rect.width);
                        assert_eq!(height, rect.height);

                        let client_format = ClientFormatAny::ClientFormat(client_format);

                        self.0.upload_texture(rect.left, rect.bottom, 0, (client_format, data),
                                              width, Some(height), None, true).unwrap()
                    }
                
                /// Returns the corresponding texture.
                pub fn get_texture(&self) -> &'t Texture2d {
                    self.1
                }

                /// Returns the texture level.
                pub fn get_level(&self) -> u32 {
                    self.0.get_level()
                }
            }
/// A compressed two-dimensional texture  containing floating-point data.
pub struct CompressedTexture2d(TextureAny);

                impl Texture for CompressedTexture2d {
                    fn get_width(&self) -> u32 {
                        self.0.get_width()
                    }

                    fn get_height(&self) -> Option<u32> {
                        self.0.get_height()
                    }

                    fn get_depth(&self) -> Option<u32> {
                        self.0.get_depth()
                    }

                    fn get_array_size(&self) -> Option<u32> {
                        self.0.get_array_size()
                    }
                }
            

                impl GlObject for CompressedTexture2d {
                    type Id = gl::types::GLuint;
                    fn get_id(&self) -> gl::types::GLuint {
                        self.0.get_id()
                    }
                }
            

                impl ::std::fmt::Debug for CompressedTexture2d {
                    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> Result<(), ::std::fmt::Error>
                    {
                        self.0.fmt(f)
                    }
                }
            

                impl ::std::ops::Deref for CompressedTexture2d {
                    type Target = TextureAny;
                    
                    fn deref<'a>(&'a self) -> &'a TextureAny {
                        &self.0
                    }
                }
            

                            impl<'a> AsUniformValue for &'a CompressedTexture2d {
                                fn as_uniform_value(&self) -> UniformValue {
                                    UniformValue::CompressedTexture2d(*self, None)
                                }
                            }

                            impl<'a> AsUniformValue for Sampler<'a, CompressedTexture2d> {
                                fn as_uniform_value(&self) -> UniformValue {
                                    UniformValue::CompressedTexture2d(self.0, Some(self.1))
                                }
                            }

                            impl CompressedTexture2d {
                                /// Builds a `Sampler` marker object that allows you to indicate
                                /// how the texture should be sampled from inside a shader.
                                ///
                                /// # Example
                                ///
                                /// ```no_run
                                /// # #[macro_use] extern crate glium;
                                /// # fn main() {
                                /// # let texture: glium::texture::Texture2d = unsafe {
                                /// # ::std::mem::uninitialized() };
                                /// let uniforms = uniform! {
                                ///     color_texture: texture.sampled().magnify_filter(glium::uniforms::MagnifySamplerFilter::Nearest)
                                /// };
                                /// # }
                                /// ```
                                pub fn sampled(&self) -> Sampler<CompressedTexture2d> {
                                    Sampler(self, Default::default())
                                }
                            }
                        
impl CompressedTexture2d {

            /// Determines the internal format of this texture.
            ///
            /// The backend may not support querying the actual format, in which case an error
            /// is returned.
            pub fn get_internal_format(&self) -> Result<InternalFormat, GetFormatError> {
                self.0.get_internal_format()
            }
        

                /// Builds a new texture by uploading data.
                ///
                /// No mipmap level (except for the main level) will be allocator nor generated.
                pub fn new<'a, F, T>(facade: &F, data: T)
                              -> Result<CompressedTexture2d, TextureCreationError>
                              where T: Texture2dDataSource<'a>, F: Facade
                {
                    CompressedTexture2d::new_impl(facade, data, None, CompressedMipmapsOption::NoMipmap)
                }
            

                /// Builds a new texture by uploading data.
                pub fn with_mipmaps<'a, F, T>(facade: &F, data: T, mipmaps: CompressedMipmapsOption)
                                              -> Result<CompressedTexture2d, TextureCreationError>
                                              where T: Texture2dDataSource<'a>, F: Facade
                {
                    CompressedTexture2d::new_impl(facade, data, None, mipmaps)
                }
            

                /// Builds a new texture with a specific format. The input data must also be of the
                /// specified compressed format.
                pub fn with_compressed_data<F>(facade: &F, data: &[u8], width: u32, height: u32,
                                                      format: CompressedFormat, mipmaps: CompressedMipmapsOption)
                                                      -> Result<CompressedTexture2d, TextureCreationError>
                                                       where F: Facade
                {
                    let data = Cow::Borrowed(data.as_ref());
                    let client_format = ClientFormatAny::CompressedFormat(format);
                    Ok(CompressedTexture2d(try!(any::new_texture(facade, TextureFormatRequest::AnyCompressed, Some((client_format, data)),
                                                    mipmaps.to_regular(), Dimensions::Texture2d { width: width, height: height }))))
                }
            

                /// Builds a new texture with a specific format.
                pub fn with_format<'a, F, T>(facade: &F, data: T,
                                          format: CompressedFormat, mipmaps: CompressedMipmapsOption)
                                          -> Result<CompressedTexture2d, TextureCreationError>
                                          where T: Texture2dDataSource<'a>, F: Facade
                {
                    CompressedTexture2d::new_impl(facade, data, Some(format), mipmaps)
                }
            

                fn new_impl<'a, F, T>(facade: &F, data: T,
                                   format: Option<CompressedFormat>, mipmaps: CompressedMipmapsOption)
                                   -> Result<CompressedTexture2d, TextureCreationError>
                                   where T: Texture2dDataSource<'a>, F: Facade
                {
            
let format = format.map(|f| {
                           TextureFormatRequest::Specific(f.to_texture_format())
                       }).unwrap_or(TextureFormatRequest::AnyCompressed);
                    let RawImage2d { data, width, height, format: client_format } =
                                            data.into_raw();
                let client_format = ClientFormatAny::ClientFormat(client_format);Ok(CompressedTexture2d(try!(any::new_texture(facade, format, Some((client_format, data)), mipmaps.to_regular(), Dimensions::Texture2d { width: width, height: height }))))
}

                /// Creates an empty texture with a specific format.
                ///
                /// The texture (and its mipmaps) will contain undefined data.
                pub fn empty_with_format<F>(facade: &F, format: CompressedFormat, mipmaps: CompressedMipmapsOption, width: u32, height: u32) -> Result<CompressedTexture2d, TextureCreationError> where F: Facade {
                    let format = format.to_texture_format();
                    let format = TextureFormatRequest::Specific(format);
            
let t = any::new_texture::<_, u8>(facade, format, None, mipmaps.to_regular(), Dimensions::Texture2d { width: width, height: height });
            t.map(|t| CompressedTexture2d(t))
}

            /// Returns the number of mipmap levels of the texture.
            ///
            /// The minimum value is 1, since there is always a main texture.
            pub fn get_mipmap_levels(&self) -> u32 {
                self.0.get_mipmap_levels()
            }
        
                /// Reads the content of the texture to RAM.
                ///
                /// You should avoid doing this at all cost during performance-critical
                /// operations (for example, while you're drawing).
                /// Use `read_to_pixel_buffer` instead.
                pub fn read<T>(&self) -> T where T: Texture2dDataSink<(u8, u8, u8, u8)> {
                    self.0.mipmap(0, 0).unwrap().read()
                }
            
                /// Reads the content of the texture into a buffer in video memory.
                ///
                /// This operation copies the texture's data into a buffer in video memory
                /// (a pixel buffer). Contrary to the `read` function, this operation is
                /// done asynchronously and doesn't need a synchronization.
                pub fn read_to_pixel_buffer(&self) -> PixelBuffer<(u8, u8, u8, u8)> {
                    self.0.mipmap(0, 0).unwrap().read_to_pixel_buffer()
                }
            
                /// Reads the content of the texture to RAM without decompressing it before.
                ///
                /// You should avoid doing this at all cost during performance-critical
                /// operations (for example, while you're drawing).
                ///
                /// Returns the compressed format of the texture and the compressed data, gives
                /// `None` when the internal compression format is generic or unknown.
                pub fn read_compressed_data(&self) -> Option<(CompressedFormat, Vec<u8>)> {
                    self.main_level().read_compressed_data()
                }
            
                /// Uploads some data in the texture.
                ///
                /// Note that this may cause a synchronization if you use the texture right before
                /// or right after this call. Prefer creating a whole new texture if you change a
                /// huge part of it.
                ///
                /// ## Panic
                ///
                /// Panics if the the dimensions of `data` don't match the `Rect`.
                 ///
                /// Calling this for compressed textures will result in a panic of type INVALID_OPERATION
                /// if `Rect::bottom` or `Rect::width` is not equal to 0 (border). In addition, the contents
                /// of any texel outside the region modified by such a call are undefined. These
                /// restrictions may be relaxed for specific compressed internal formats whose images
                /// are easily edited.
            
                pub fn write<'a, T>(&self, rect: Rect, data: T) where T: Texture2dDataSource<'a> {
                    self.main_level().write(rect, data)
                }
            
                /// Uploads some data in the texture by using a compressed format as input.
                ///
                /// Note that this may cause a synchronization if you use the texture right before
                /// or right after this call. Prefer creating a whole new texture if you change a
                /// huge part of it.
                ///
                /// ## Panic
                ///
                /// Panics if the the dimensions of `data` don't match the `Rect`.
                ///
                /// Calling this will result in a panic of type INVALID_OPERATION error if `Rect::width`
                /// or `Rect::height` is not equal to 0 (border), or if the written dimensions do not match
                /// the original texture dimensions. The contents of any texel outside the region modified
                /// by the call are undefined. These restrictions may be relaxed for specific compressed
                /// internal formats whose images are easily edited.
                pub fn write_compressed_data(&self, rect: Rect, data: &[u8],
                                             width: u32, height: u32, format: CompressedFormat)
                                             -> Result<(), ()>
                {
                    // FIXME is having width and height as parameter redundant as rect kinda of
                    // already provides them? 
                    self.main_level().write_compressed_data(rect, data, width, height, format)
                }
            
            /// Turns the texture into a `ResidentTexture`.
            ///
            /// This allows you to use the texture in a much more efficient way by storing
            /// a "reference to it" in a buffer (actually not a reference but a raw pointer).
            ///
            /// See the documentation of `ResidentTexture` for more infos.
            pub fn resident(self) -> Result<ResidentTexture, BindlessTexturesNotSupportedError> {
                ResidentTexture::new(self.0)
            }
        
                /// Access a single mipmap level of this texture.
                pub fn mipmap(&self, level: u32) -> Option<CompressedTexture2dMipmap> {
                    self.0.mipmap(0, level).map(|m| CompressedTexture2dMipmap(m, self))
                }
            
                /// Access the main mipmap level of this texture.
                pub fn main_level(&self) -> CompressedTexture2dMipmap {
                    self.mipmap(0).unwrap()
                }
            }

                    /// Represents a single mipmap level of a `CompressedTexture2d`.
                    ///
                    /// Can be obtained by calling `CompressedTexture2d::mipmap()` or `CompressedTexture2d::main_level()`.
                    #[derive(Copy, Clone)]
                    pub struct CompressedTexture2dMipmap<'t>(TextureAnyMipmap<'t>, &'t CompressedTexture2d);
                impl<'t> CompressedTexture2dMipmap<'t> {

                    /// Uploads some data in the texture level.
                    ///
                    /// Note that this may cause a synchronization if you use the texture right before
                    /// or right after this call.
                    ///
                    /// ## Panic
                    ///
                    /// Panics if the the dimensions of `data` don't match the `Rect`.
                     ///
                    /// Calling this for compressed textures will result in a panic of type INVALID_OPERATION
                    /// if `Rect::bottom` or `Rect::width` is not equal to 0 (border). In addition, the contents
                    /// of any texel outside the region modified by such a call are undefined. These
                    /// restrictions may be relaxed for specific compressed internal formats whose images
                    /// are easily edited.
                
                    pub fn write<'a, T>(&self, rect: Rect, data: T) where T: Texture2dDataSource<'a> {
                        let RawImage2d { data, width, height, format: client_format } =
                                                data.into_raw();

                        assert_eq!(width, rect.width);
                        assert_eq!(height, rect.height);

                        let client_format = ClientFormatAny::ClientFormat(client_format);

                        self.0.upload_texture(rect.left, rect.bottom, 0, (client_format, data),
                                              width, Some(height), None, true).unwrap()
                    }
                
                    /// Uploads some data in the texture level by using a compressed format as input.
                    ///
                    /// Note that this may cause a synchronization if you use the texture right before
                    /// or right after this call.
                    ///
                    /// ## Panic
                    ///
                    /// Panics if the the dimensions of `data` don't match the `Rect`.
                    ///
                    /// Calling this will result in a panic of type INVALID_OPERATION error if `Rect::width`
                    /// or `Rect::height` is not equal to 0 (border), or if the written dimensions do not match
                    /// the original texture dimensions. The contents of any texel outside the region modified
                    /// by the call are undefined. These restrictions may be relaxed for specific compressed
                    /// internal formats whose images are easily edited.
                    pub fn write_compressed_data(&self, rect: Rect, data: &[u8],
                                                 width: u32, height: u32, format: CompressedFormat)
                                                 -> Result<(), ()>
                    {
                        // FIXME is having width and height as parameter redundant as rect kinda of
                        // already provides them? 

                        assert_eq!(width, rect.width);
                        assert_eq!(height, rect.height);

                        let data = Cow::Borrowed(data.as_ref());
                        let client_format = ClientFormatAny::CompressedFormat(format);

                        self.0.upload_texture(rect.left, rect.bottom, 0, (client_format, data),
                                              width, Some(height), None, false)
                    }
                
                    /// Reads the content of the texture level to RAM without decompressing it before.
                    ///
                    /// You should avoid doing this at all cost during performance-critical
                    /// operations (for example, while you're drawing).
                    ///
                    /// Returns the compressed format of the texture and the compressed data, gives
                    /// `None` when the internal compression format is generic or unknown.
                    pub fn read_compressed_data(&self) -> Option<(CompressedFormat, Vec<u8>)> {
                        match self.0.download_compressed_data() {
                            Some((ClientFormatAny::CompressedFormat(format), buf)) => Some((format, buf)),
                            None => None,
                            _ => unreachable!(),
                        }
                    }
                
                /// Returns the corresponding texture.
                pub fn get_texture(&self) -> &'t CompressedTexture2d {
                    self.1
                }

                /// Returns the texture level.
                pub fn get_level(&self) -> u32 {
                    self.0.get_level()
                }
            }
/// A two-dimensional texture  containing sRGB floating-point data.
pub struct SrgbTexture2d(TextureAny);

                impl Texture for SrgbTexture2d {
                    fn get_width(&self) -> u32 {
                        self.0.get_width()
                    }

                    fn get_height(&self) -> Option<u32> {
                        self.0.get_height()
                    }

                    fn get_depth(&self) -> Option<u32> {
                        self.0.get_depth()
                    }

                    fn get_array_size(&self) -> Option<u32> {
                        self.0.get_array_size()
                    }
                }
            

                impl GlObject for SrgbTexture2d {
                    type Id = gl::types::GLuint;
                    fn get_id(&self) -> gl::types::GLuint {
                        self.0.get_id()
                    }
                }
            

                impl ::std::fmt::Debug for SrgbTexture2d {
                    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> Result<(), ::std::fmt::Error>
                    {
                        self.0.fmt(f)
                    }
                }
            

                impl ::std::ops::Deref for SrgbTexture2d {
                    type Target = TextureAny;
                    
                    fn deref<'a>(&'a self) -> &'a TextureAny {
                        &self.0
                    }
                }
            

                            impl<'a> AsUniformValue for &'a SrgbTexture2d {
                                fn as_uniform_value(&self) -> UniformValue {
                                    UniformValue::SrgbTexture2d(*self, None)
                                }
                            }

                            impl<'a> AsUniformValue for Sampler<'a, SrgbTexture2d> {
                                fn as_uniform_value(&self) -> UniformValue {
                                    UniformValue::SrgbTexture2d(self.0, Some(self.1))
                                }
                            }

                            impl SrgbTexture2d {
                                /// Builds a `Sampler` marker object that allows you to indicate
                                /// how the texture should be sampled from inside a shader.
                                ///
                                /// # Example
                                ///
                                /// ```no_run
                                /// # #[macro_use] extern crate glium;
                                /// # fn main() {
                                /// # let texture: glium::texture::Texture2d = unsafe {
                                /// # ::std::mem::uninitialized() };
                                /// let uniforms = uniform! {
                                ///     color_texture: texture.sampled().magnify_filter(glium::uniforms::MagnifySamplerFilter::Nearest)
                                /// };
                                /// # }
                                /// ```
                                pub fn sampled(&self) -> Sampler<SrgbTexture2d> {
                                    Sampler(self, Default::default())
                                }
                            }
                        

                        impl ::framebuffer::ToColorAttachment for SrgbTexture2d {
                            fn to_color_attachment(&self) -> ::framebuffer::ColorAttachment {
                                ::framebuffer::ColorAttachment::Texture(self.0.mipmap(0, 0).unwrap())
                            }
                        }
                    
impl SrgbTexture2d {

            /// Determines the internal format of this texture.
            ///
            /// The backend may not support querying the actual format, in which case an error
            /// is returned.
            pub fn get_internal_format(&self) -> Result<InternalFormat, GetFormatError> {
                self.0.get_internal_format()
            }
        

                /// Builds a new texture by uploading data.
                ///
                /// This function will automatically generate all mipmaps of the texture.
                pub fn new<'a, F, T>(facade: &F, data: T)
                              -> Result<SrgbTexture2d, TextureCreationError>
                              where T: Texture2dDataSource<'a>, F: Facade
                {
                    SrgbTexture2d::new_impl(facade, data, None, MipmapsOption::AutoGeneratedMipmaps)
                }
            

                /// Builds a new texture by uploading data.
                pub fn with_mipmaps<'a, F, T>(facade: &F, data: T, mipmaps: MipmapsOption)
                                              -> Result<SrgbTexture2d, TextureCreationError>
                                              where T: Texture2dDataSource<'a>, F: Facade
                {
                    SrgbTexture2d::new_impl(facade, data, None, mipmaps)
                }
            

                /// Builds a new texture with a specific format.
                pub fn with_format<'a, F, T>(facade: &F, data: T,
                                          format: SrgbFormat, mipmaps: MipmapsOption)
                                          -> Result<SrgbTexture2d, TextureCreationError>
                                          where T: Texture2dDataSource<'a>, F: Facade
                {
                    SrgbTexture2d::new_impl(facade, data, Some(format), mipmaps)
                }
            

                fn new_impl<'a, F, T>(facade: &F, data: T,
                                   format: Option<SrgbFormat>, mipmaps: MipmapsOption)
                                   -> Result<SrgbTexture2d, TextureCreationError>
                                   where T: Texture2dDataSource<'a>, F: Facade
                {
            
let format = format.map(|f| {
                           TextureFormatRequest::Specific(f.to_texture_format())
                       }).unwrap_or(TextureFormatRequest::AnySrgb);
                    let RawImage2d { data, width, height, format: client_format } =
                                            data.into_raw();
                let client_format = ClientFormatAny::ClientFormat(client_format);Ok(SrgbTexture2d(try!(any::new_texture(facade, format, Some((client_format, data)), mipmaps.to_regular(), Dimensions::Texture2d { width: width, height: height }))))
}

                /// Creates an empty texture.
                ///
                /// No mipmap level (except for the main level) will be allocated or generated.
                ///
                /// The texture will contain undefined data.
                pub fn empty<F>(facade: &F, width: u32, height: u32)
                                -> Result<SrgbTexture2d, TextureCreationError>
                                where F: Facade
                {
                    let format = TextureFormatRequest::AnySrgb;
            
any::new_texture::<_, u8>(facade, format, None, MipmapsOption::NoMipmap.to_regular(), Dimensions::Texture2d { width: width, height: height }).map(|t| SrgbTexture2d(t))}

                /// Creates an empty texture with a specific format.
                ///
                /// The texture (and its mipmaps) will contain undefined data.
                pub fn empty_with_format<F>(facade: &F, format: SrgbFormat, mipmaps: MipmapsOption, width: u32, height: u32) -> Result<SrgbTexture2d, TextureCreationError> where F: Facade {
                    let format = format.to_texture_format();
                    let format = TextureFormatRequest::Specific(format);
            
let t = any::new_texture::<_, u8>(facade, format, None, mipmaps.to_regular(), Dimensions::Texture2d { width: width, height: height });
            t.map(|t| SrgbTexture2d(t))
}

                /// Creates an empty texture. Specifies whether is has mipmaps.
                ///
                /// The texture (and its mipmaps) will contain undefined data.
                pub fn empty_with_mipmaps<F>(facade: &F, mipmaps: MipmapsOption, width: u32, height: u32) -> Result<SrgbTexture2d, TextureCreationError> where F: Facade {
                    let format = TextureFormatRequest::AnySrgb;
            
any::new_texture::<_, u8>(facade, format, None, mipmaps.to_regular(), Dimensions::Texture2d { width: width, height: height }).map(|t| SrgbTexture2d(t))
}

            /// Returns the number of mipmap levels of the texture.
            ///
            /// The minimum value is 1, since there is always a main texture.
            pub fn get_mipmap_levels(&self) -> u32 {
                self.0.get_mipmap_levels()
            }
        
            /// Turns the texture into a `ResidentTexture`.
            ///
            /// This allows you to use the texture in a much more efficient way by storing
            /// a "reference to it" in a buffer (actually not a reference but a raw pointer).
            ///
            /// See the documentation of `ResidentTexture` for more infos.
            pub fn resident(self) -> Result<ResidentTexture, BindlessTexturesNotSupportedError> {
                ResidentTexture::new(self.0)
            }
        
                /// Access a single mipmap level of this texture.
                pub fn mipmap(&self, level: u32) -> Option<SrgbTexture2dMipmap> {
                    self.0.mipmap(0, level).map(|m| SrgbTexture2dMipmap(m, self))
                }
            
                /// Access the main mipmap level of this texture.
                pub fn main_level(&self) -> SrgbTexture2dMipmap {
                    self.mipmap(0).unwrap()
                }
            }

                    /// Represents a single mipmap level of a `SrgbTexture2d`.
                    ///
                    /// Can be obtained by calling `SrgbTexture2d::mipmap()` or `SrgbTexture2d::main_level()`.
                    #[derive(Copy, Clone)]
                    pub struct SrgbTexture2dMipmap<'t>(TextureAnyMipmap<'t>, &'t SrgbTexture2d);
                impl<'t> SrgbTexture2dMipmap<'t> {

                /// Returns the corresponding texture.
                pub fn get_texture(&self) -> &'t SrgbTexture2d {
                    self.1
                }

                /// Returns the texture level.
                pub fn get_level(&self) -> u32 {
                    self.0.get_level()
                }
            }
/// A compressed two-dimensional texture  containing sRGB floating-point data.
pub struct CompressedSrgbTexture2d(TextureAny);

                impl Texture for CompressedSrgbTexture2d {
                    fn get_width(&self) -> u32 {
                        self.0.get_width()
                    }

                    fn get_height(&self) -> Option<u32> {
                        self.0.get_height()
                    }

                    fn get_depth(&self) -> Option<u32> {
                        self.0.get_depth()
                    }

                    fn get_array_size(&self) -> Option<u32> {
                        self.0.get_array_size()
                    }
                }
            

                impl GlObject for CompressedSrgbTexture2d {
                    type Id = gl::types::GLuint;
                    fn get_id(&self) -> gl::types::GLuint {
                        self.0.get_id()
                    }
                }
            

                impl ::std::fmt::Debug for CompressedSrgbTexture2d {
                    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> Result<(), ::std::fmt::Error>
                    {
                        self.0.fmt(f)
                    }
                }
            

                impl ::std::ops::Deref for CompressedSrgbTexture2d {
                    type Target = TextureAny;
                    
                    fn deref<'a>(&'a self) -> &'a TextureAny {
                        &self.0
                    }
                }
            

                            impl<'a> AsUniformValue for &'a CompressedSrgbTexture2d {
                                fn as_uniform_value(&self) -> UniformValue {
                                    UniformValue::CompressedSrgbTexture2d(*self, None)
                                }
                            }

                            impl<'a> AsUniformValue for Sampler<'a, CompressedSrgbTexture2d> {
                                fn as_uniform_value(&self) -> UniformValue {
                                    UniformValue::CompressedSrgbTexture2d(self.0, Some(self.1))
                                }
                            }

                            impl CompressedSrgbTexture2d {
                                /// Builds a `Sampler` marker object that allows you to indicate
                                /// how the texture should be sampled from inside a shader.
                                ///
                                /// # Example
                                ///
                                /// ```no_run
                                /// # #[macro_use] extern crate glium;
                                /// # fn main() {
                                /// # let texture: glium::texture::Texture2d = unsafe {
                                /// # ::std::mem::uninitialized() };
                                /// let uniforms = uniform! {
                                ///     color_texture: texture.sampled().magnify_filter(glium::uniforms::MagnifySamplerFilter::Nearest)
                                /// };
                                /// # }
                                /// ```
                                pub fn sampled(&self) -> Sampler<CompressedSrgbTexture2d> {
                                    Sampler(self, Default::default())
                                }
                            }
                        
impl CompressedSrgbTexture2d {

            /// Determines the internal format of this texture.
            ///
            /// The backend may not support querying the actual format, in which case an error
            /// is returned.
            pub fn get_internal_format(&self) -> Result<InternalFormat, GetFormatError> {
                self.0.get_internal_format()
            }
        

                /// Builds a new texture by uploading data.
                ///
                /// No mipmap level (except for the main level) will be allocator nor generated.
                pub fn new<'a, F, T>(facade: &F, data: T)
                              -> Result<CompressedSrgbTexture2d, TextureCreationError>
                              where T: Texture2dDataSource<'a>, F: Facade
                {
                    CompressedSrgbTexture2d::new_impl(facade, data, None, CompressedMipmapsOption::NoMipmap)
                }
            

                /// Builds a new texture by uploading data.
                pub fn with_mipmaps<'a, F, T>(facade: &F, data: T, mipmaps: CompressedMipmapsOption)
                                              -> Result<CompressedSrgbTexture2d, TextureCreationError>
                                              where T: Texture2dDataSource<'a>, F: Facade
                {
                    CompressedSrgbTexture2d::new_impl(facade, data, None, mipmaps)
                }
            

                /// Builds a new texture with a specific format. The input data must also be of the
                /// specified compressed format.
                pub fn with_compressed_data<F>(facade: &F, data: &[u8], width: u32, height: u32,
                                                      format: CompressedSrgbFormat, mipmaps: CompressedMipmapsOption)
                                                      -> Result<CompressedSrgbTexture2d, TextureCreationError>
                                                       where F: Facade
                {
                    let data = Cow::Borrowed(data.as_ref());
                    let client_format = ClientFormatAny::CompressedSrgbFormat(format);
                    Ok(CompressedSrgbTexture2d(try!(any::new_texture(facade, TextureFormatRequest::AnyCompressedSrgb, Some((client_format, data)),
                                                    mipmaps.to_regular(), Dimensions::Texture2d { width: width, height: height }))))
                }
            

                /// Builds a new texture with a specific format.
                pub fn with_format<'a, F, T>(facade: &F, data: T,
                                          format: CompressedSrgbFormat, mipmaps: CompressedMipmapsOption)
                                          -> Result<CompressedSrgbTexture2d, TextureCreationError>
                                          where T: Texture2dDataSource<'a>, F: Facade
                {
                    CompressedSrgbTexture2d::new_impl(facade, data, Some(format), mipmaps)
                }
            

                fn new_impl<'a, F, T>(facade: &F, data: T,
                                   format: Option<CompressedSrgbFormat>, mipmaps: CompressedMipmapsOption)
                                   -> Result<CompressedSrgbTexture2d, TextureCreationError>
                                   where T: Texture2dDataSource<'a>, F: Facade
                {
            
let format = format.map(|f| {
                           TextureFormatRequest::Specific(f.to_texture_format())
                       }).unwrap_or(TextureFormatRequest::AnyCompressedSrgb);
                    let RawImage2d { data, width, height, format: client_format } =
                                            data.into_raw();
                let client_format = ClientFormatAny::ClientFormat(client_format);Ok(CompressedSrgbTexture2d(try!(any::new_texture(facade, format, Some((client_format, data)), mipmaps.to_regular(), Dimensions::Texture2d { width: width, height: height }))))
}

                /// Creates an empty texture with a specific format.
                ///
                /// The texture (and its mipmaps) will contain undefined data.
                pub fn empty_with_format<F>(facade: &F, format: CompressedSrgbFormat, mipmaps: CompressedMipmapsOption, width: u32, height: u32) -> Result<CompressedSrgbTexture2d, TextureCreationError> where F: Facade {
                    let format = format.to_texture_format();
                    let format = TextureFormatRequest::Specific(format);
            
let t = any::new_texture::<_, u8>(facade, format, None, mipmaps.to_regular(), Dimensions::Texture2d { width: width, height: height });
            t.map(|t| CompressedSrgbTexture2d(t))
}

            /// Returns the number of mipmap levels of the texture.
            ///
            /// The minimum value is 1, since there is always a main texture.
            pub fn get_mipmap_levels(&self) -> u32 {
                self.0.get_mipmap_levels()
            }
        
                /// Reads the content of the texture to RAM.
                ///
                /// You should avoid doing this at all cost during performance-critical
                /// operations (for example, while you're drawing).
                /// Use `read_to_pixel_buffer` instead.
                pub fn read<T>(&self) -> T where T: Texture2dDataSink<(u8, u8, u8, u8)> {
                    self.0.mipmap(0, 0).unwrap().read()
                }
            
                /// Reads the content of the texture into a buffer in video memory.
                ///
                /// This operation copies the texture's data into a buffer in video memory
                /// (a pixel buffer). Contrary to the `read` function, this operation is
                /// done asynchronously and doesn't need a synchronization.
                pub fn read_to_pixel_buffer(&self) -> PixelBuffer<(u8, u8, u8, u8)> {
                    self.0.mipmap(0, 0).unwrap().read_to_pixel_buffer()
                }
            
                /// Reads the content of the texture to RAM without decompressing it before.
                ///
                /// You should avoid doing this at all cost during performance-critical
                /// operations (for example, while you're drawing).
                ///
                /// Returns the compressed format of the texture and the compressed data, gives
                /// `None` when the internal compression format is generic or unknown.
                pub fn read_compressed_data(&self) -> Option<(CompressedSrgbFormat, Vec<u8>)> {
                    self.main_level().read_compressed_data()
                }
            
                /// Uploads some data in the texture.
                ///
                /// Note that this may cause a synchronization if you use the texture right before
                /// or right after this call. Prefer creating a whole new texture if you change a
                /// huge part of it.
                ///
                /// ## Panic
                ///
                /// Panics if the the dimensions of `data` don't match the `Rect`.
                 ///
                /// Calling this for compressed textures will result in a panic of type INVALID_OPERATION
                /// if `Rect::bottom` or `Rect::width` is not equal to 0 (border). In addition, the contents
                /// of any texel outside the region modified by such a call are undefined. These
                /// restrictions may be relaxed for specific compressed internal formats whose images
                /// are easily edited.
            
                pub fn write<'a, T>(&self, rect: Rect, data: T) where T: Texture2dDataSource<'a> {
                    self.main_level().write(rect, data)
                }
            
                /// Uploads some data in the texture by using a compressed format as input.
                ///
                /// Note that this may cause a synchronization if you use the texture right before
                /// or right after this call. Prefer creating a whole new texture if you change a
                /// huge part of it.
                ///
                /// ## Panic
                ///
                /// Panics if the the dimensions of `data` don't match the `Rect`.
                ///
                /// Calling this will result in a panic of type INVALID_OPERATION error if `Rect::width`
                /// or `Rect::height` is not equal to 0 (border), or if the written dimensions do not match
                /// the original texture dimensions. The contents of any texel outside the region modified
                /// by the call are undefined. These restrictions may be relaxed for specific compressed
                /// internal formats whose images are easily edited.
                pub fn write_compressed_data(&self, rect: Rect, data: &[u8],
                                             width: u32, height: u32, format: CompressedSrgbFormat)
                                             -> Result<(), ()>
                {
                    // FIXME is having width and height as parameter redundant as rect kinda of
                    // already provides them? 
                    self.main_level().write_compressed_data(rect, data, width, height, format)
                }
            
            /// Turns the texture into a `ResidentTexture`.
            ///
            /// This allows you to use the texture in a much more efficient way by storing
            /// a "reference to it" in a buffer (actually not a reference but a raw pointer).
            ///
            /// See the documentation of `ResidentTexture` for more infos.
            pub fn resident(self) -> Result<ResidentTexture, BindlessTexturesNotSupportedError> {
                ResidentTexture::new(self.0)
            }
        
                /// Access a single mipmap level of this texture.
                pub fn mipmap(&self, level: u32) -> Option<CompressedSrgbTexture2dMipmap> {
                    self.0.mipmap(0, level).map(|m| CompressedSrgbTexture2dMipmap(m, self))
                }
            
                /// Access the main mipmap level of this texture.
                pub fn main_level(&self) -> CompressedSrgbTexture2dMipmap {
                    self.mipmap(0).unwrap()
                }
            }

                    /// Represents a single mipmap level of a `CompressedSrgbTexture2d`.
                    ///
                    /// Can be obtained by calling `CompressedSrgbTexture2d::mipmap()` or `CompressedSrgbTexture2d::main_level()`.
                    #[derive(Copy, Clone)]
                    pub struct CompressedSrgbTexture2dMipmap<'t>(TextureAnyMipmap<'t>, &'t CompressedSrgbTexture2d);
                impl<'t> CompressedSrgbTexture2dMipmap<'t> {

                    /// Uploads some data in the texture level.
                    ///
                    /// Note that this may cause a synchronization if you use the texture right before
                    /// or right after this call.
                    ///
                    /// ## Panic
                    ///
                    /// Panics if the the dimensions of `data` don't match the `Rect`.
                     ///
                    /// Calling this for compressed textures will result in a panic of type INVALID_OPERATION
                    /// if `Rect::bottom` or `Rect::width` is not equal to 0 (border). In addition, the contents
                    /// of any texel outside the region modified by such a call are undefined. These
                    /// restrictions may be relaxed for specific compressed internal formats whose images
                    /// are easily edited.
                
                    pub fn write<'a, T>(&self, rect: Rect, data: T) where T: Texture2dDataSource<'a> {
                        let RawImage2d { data, width, height, format: client_format } =
                                                data.into_raw();

                        assert_eq!(width, rect.width);
                        assert_eq!(height, rect.height);

                        let client_format = ClientFormatAny::ClientFormat(client_format);

                        self.0.upload_texture(rect.left, rect.bottom, 0, (client_format, data),
                                              width, Some(height), None, true).unwrap()
                    }
                
                    /// Uploads some data in the texture level by using a compressed format as input.
                    ///
                    /// Note that this may cause a synchronization if you use the texture right before
                    /// or right after this call.
                    ///
                    /// ## Panic
                    ///
                    /// Panics if the the dimensions of `data` don't match the `Rect`.
                    ///
                    /// Calling this will result in a panic of type INVALID_OPERATION error if `Rect::width`
                    /// or `Rect::height` is not equal to 0 (border), or if the written dimensions do not match
                    /// the original texture dimensions. The contents of any texel outside the region modified
                    /// by the call are undefined. These restrictions may be relaxed for specific compressed
                    /// internal formats whose images are easily edited.
                    pub fn write_compressed_data(&self, rect: Rect, data: &[u8],
                                                 width: u32, height: u32, format: CompressedSrgbFormat)
                                                 -> Result<(), ()>
                    {
                        // FIXME is having width and height as parameter redundant as rect kinda of
                        // already provides them? 

                        assert_eq!(width, rect.width);
                        assert_eq!(height, rect.height);

                        let data = Cow::Borrowed(data.as_ref());
                        let client_format = ClientFormatAny::CompressedSrgbFormat(format);

                        self.0.upload_texture(rect.left, rect.bottom, 0, (client_format, data),
                                              width, Some(height), None, false)
                    }
                
                    /// Reads the content of the texture level to RAM without decompressing it before.
                    ///
                    /// You should avoid doing this at all cost during performance-critical
                    /// operations (for example, while you're drawing).
                    ///
                    /// Returns the compressed format of the texture and the compressed data, gives
                    /// `None` when the internal compression format is generic or unknown.
                    pub fn read_compressed_data(&self) -> Option<(CompressedSrgbFormat, Vec<u8>)> {
                        match self.0.download_compressed_data() {
                            Some((ClientFormatAny::CompressedSrgbFormat(format), buf)) => Some((format, buf)),
                            None => None,
                            _ => unreachable!(),
                        }
                    }
                
                /// Returns the corresponding texture.
                pub fn get_texture(&self) -> &'t CompressedSrgbTexture2d {
                    self.1
                }

                /// Returns the texture level.
                pub fn get_level(&self) -> u32 {
                    self.0.get_level()
                }
            }
/// A two-dimensional texture  containing signed integral data.
pub struct IntegralTexture2d(TextureAny);

                impl Texture for IntegralTexture2d {
                    fn get_width(&self) -> u32 {
                        self.0.get_width()
                    }

                    fn get_height(&self) -> Option<u32> {
                        self.0.get_height()
                    }

                    fn get_depth(&self) -> Option<u32> {
                        self.0.get_depth()
                    }

                    fn get_array_size(&self) -> Option<u32> {
                        self.0.get_array_size()
                    }
                }
            

                impl GlObject for IntegralTexture2d {
                    type Id = gl::types::GLuint;
                    fn get_id(&self) -> gl::types::GLuint {
                        self.0.get_id()
                    }
                }
            

                impl ::std::fmt::Debug for IntegralTexture2d {
                    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> Result<(), ::std::fmt::Error>
                    {
                        self.0.fmt(f)
                    }
                }
            

                impl ::std::ops::Deref for IntegralTexture2d {
                    type Target = TextureAny;
                    
                    fn deref<'a>(&'a self) -> &'a TextureAny {
                        &self.0
                    }
                }
            

                            impl<'a> AsUniformValue for &'a IntegralTexture2d {
                                fn as_uniform_value(&self) -> UniformValue {
                                    UniformValue::IntegralTexture2d(*self, None)
                                }
                            }

                            impl<'a> AsUniformValue for Sampler<'a, IntegralTexture2d> {
                                fn as_uniform_value(&self) -> UniformValue {
                                    UniformValue::IntegralTexture2d(self.0, Some(self.1))
                                }
                            }

                            impl IntegralTexture2d {
                                /// Builds a `Sampler` marker object that allows you to indicate
                                /// how the texture should be sampled from inside a shader.
                                ///
                                /// # Example
                                ///
                                /// ```no_run
                                /// # #[macro_use] extern crate glium;
                                /// # fn main() {
                                /// # let texture: glium::texture::Texture2d = unsafe {
                                /// # ::std::mem::uninitialized() };
                                /// let uniforms = uniform! {
                                ///     color_texture: texture.sampled().magnify_filter(glium::uniforms::MagnifySamplerFilter::Nearest)
                                /// };
                                /// # }
                                /// ```
                                pub fn sampled(&self) -> Sampler<IntegralTexture2d> {
                                    Sampler(self, Default::default())
                                }
                            }
                        
impl IntegralTexture2d {

            /// Determines the internal format of this texture.
            ///
            /// The backend may not support querying the actual format, in which case an error
            /// is returned.
            pub fn get_internal_format(&self) -> Result<InternalFormat, GetFormatError> {
                self.0.get_internal_format()
            }
        

                /// Builds a new texture by uploading data.
                ///
                /// This function will automatically generate all mipmaps of the texture.
                pub fn new<'a, F, T>(facade: &F, data: T)
                              -> Result<IntegralTexture2d, TextureCreationError>
                              where T: Texture2dDataSource<'a>, F: Facade
                {
                    IntegralTexture2d::new_impl(facade, data, None, MipmapsOption::AutoGeneratedMipmaps)
                }
            

                /// Builds a new texture by uploading data.
                pub fn with_mipmaps<'a, F, T>(facade: &F, data: T, mipmaps: MipmapsOption)
                                              -> Result<IntegralTexture2d, TextureCreationError>
                                              where T: Texture2dDataSource<'a>, F: Facade
                {
                    IntegralTexture2d::new_impl(facade, data, None, mipmaps)
                }
            

                /// Builds a new texture with a specific format.
                pub fn with_format<'a, F, T>(facade: &F, data: T,
                                          format: UncompressedIntFormat, mipmaps: MipmapsOption)
                                          -> Result<IntegralTexture2d, TextureCreationError>
                                          where T: Texture2dDataSource<'a>, F: Facade
                {
                    IntegralTexture2d::new_impl(facade, data, Some(format), mipmaps)
                }
            

                fn new_impl<'a, F, T>(facade: &F, data: T,
                                   format: Option<UncompressedIntFormat>, mipmaps: MipmapsOption)
                                   -> Result<IntegralTexture2d, TextureCreationError>
                                   where T: Texture2dDataSource<'a>, F: Facade
                {
            
let format = format.map(|f| {
                           TextureFormatRequest::Specific(f.to_texture_format())
                       }).unwrap_or(TextureFormatRequest::AnyIntegral);
                    let RawImage2d { data, width, height, format: client_format } =
                                            data.into_raw();
                let client_format = ClientFormatAny::ClientFormat(client_format);Ok(IntegralTexture2d(try!(any::new_texture(facade, format, Some((client_format, data)), mipmaps.to_regular(), Dimensions::Texture2d { width: width, height: height }))))
}

                /// Creates an empty texture.
                ///
                /// No mipmap level (except for the main level) will be allocated or generated.
                ///
                /// The texture will contain undefined data.
                pub fn empty<F>(facade: &F, width: u32, height: u32)
                                -> Result<IntegralTexture2d, TextureCreationError>
                                where F: Facade
                {
                    let format = TextureFormatRequest::AnyIntegral;
            
any::new_texture::<_, u8>(facade, format, None, MipmapsOption::NoMipmap.to_regular(), Dimensions::Texture2d { width: width, height: height }).map(|t| IntegralTexture2d(t))}

                /// Creates an empty texture with a specific format.
                ///
                /// The texture (and its mipmaps) will contain undefined data.
                pub fn empty_with_format<F>(facade: &F, format: UncompressedIntFormat, mipmaps: MipmapsOption, width: u32, height: u32) -> Result<IntegralTexture2d, TextureCreationError> where F: Facade {
                    let format = format.to_texture_format();
                    let format = TextureFormatRequest::Specific(format);
            
let t = any::new_texture::<_, u8>(facade, format, None, mipmaps.to_regular(), Dimensions::Texture2d { width: width, height: height });
            t.map(|t| IntegralTexture2d(t))
}

                /// Creates an empty texture. Specifies whether is has mipmaps.
                ///
                /// The texture (and its mipmaps) will contain undefined data.
                pub fn empty_with_mipmaps<F>(facade: &F, mipmaps: MipmapsOption, width: u32, height: u32) -> Result<IntegralTexture2d, TextureCreationError> where F: Facade {
                    let format = TextureFormatRequest::AnyIntegral;
            
any::new_texture::<_, u8>(facade, format, None, mipmaps.to_regular(), Dimensions::Texture2d { width: width, height: height }).map(|t| IntegralTexture2d(t))
}

            /// Returns the number of mipmap levels of the texture.
            ///
            /// The minimum value is 1, since there is always a main texture.
            pub fn get_mipmap_levels(&self) -> u32 {
                self.0.get_mipmap_levels()
            }
        
            /// Turns the texture into a `ResidentTexture`.
            ///
            /// This allows you to use the texture in a much more efficient way by storing
            /// a "reference to it" in a buffer (actually not a reference but a raw pointer).
            ///
            /// See the documentation of `ResidentTexture` for more infos.
            pub fn resident(self) -> Result<ResidentTexture, BindlessTexturesNotSupportedError> {
                ResidentTexture::new(self.0)
            }
        
                /// Access a single mipmap level of this texture.
                pub fn mipmap(&self, level: u32) -> Option<IntegralTexture2dMipmap> {
                    self.0.mipmap(0, level).map(|m| IntegralTexture2dMipmap(m, self))
                }
            
                /// Access the main mipmap level of this texture.
                pub fn main_level(&self) -> IntegralTexture2dMipmap {
                    self.mipmap(0).unwrap()
                }
            }

                    /// Represents a single mipmap level of a `IntegralTexture2d`.
                    ///
                    /// Can be obtained by calling `IntegralTexture2d::mipmap()` or `IntegralTexture2d::main_level()`.
                    #[derive(Copy, Clone)]
                    pub struct IntegralTexture2dMipmap<'t>(TextureAnyMipmap<'t>, &'t IntegralTexture2d);
                impl<'t> IntegralTexture2dMipmap<'t> {

                /// Returns the corresponding texture.
                pub fn get_texture(&self) -> &'t IntegralTexture2d {
                    self.1
                }

                /// Returns the texture level.
                pub fn get_level(&self) -> u32 {
                    self.0.get_level()
                }
            }
/// A two-dimensional texture  containing unsigned integral data.
pub struct UnsignedTexture2d(TextureAny);

                impl Texture for UnsignedTexture2d {
                    fn get_width(&self) -> u32 {
                        self.0.get_width()
                    }

                    fn get_height(&self) -> Option<u32> {
                        self.0.get_height()
                    }

                    fn get_depth(&self) -> Option<u32> {
                        self.0.get_depth()
                    }

                    fn get_array_size(&self) -> Option<u32> {
                        self.0.get_array_size()
                    }
                }
            

                impl GlObject for UnsignedTexture2d {
                    type Id = gl::types::GLuint;
                    fn get_id(&self) -> gl::types::GLuint {
                        self.0.get_id()
                    }
                }
            

                impl ::std::fmt::Debug for UnsignedTexture2d {
                    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> Result<(), ::std::fmt::Error>
                    {
                        self.0.fmt(f)
                    }
                }
            

                impl ::std::ops::Deref for UnsignedTexture2d {
                    type Target = TextureAny;
                    
                    fn deref<'a>(&'a self) -> &'a TextureAny {
                        &self.0
                    }
                }
            

                            impl<'a> AsUniformValue for &'a UnsignedTexture2d {
                                fn as_uniform_value(&self) -> UniformValue {
                                    UniformValue::UnsignedTexture2d(*self, None)
                                }
                            }

                            impl<'a> AsUniformValue for Sampler<'a, UnsignedTexture2d> {
                                fn as_uniform_value(&self) -> UniformValue {
                                    UniformValue::UnsignedTexture2d(self.0, Some(self.1))
                                }
                            }

                            impl UnsignedTexture2d {
                                /// Builds a `Sampler` marker object that allows you to indicate
                                /// how the texture should be sampled from inside a shader.
                                ///
                                /// # Example
                                ///
                                /// ```no_run
                                /// # #[macro_use] extern crate glium;
                                /// # fn main() {
                                /// # let texture: glium::texture::Texture2d = unsafe {
                                /// # ::std::mem::uninitialized() };
                                /// let uniforms = uniform! {
                                ///     color_texture: texture.sampled().magnify_filter(glium::uniforms::MagnifySamplerFilter::Nearest)
                                /// };
                                /// # }
                                /// ```
                                pub fn sampled(&self) -> Sampler<UnsignedTexture2d> {
                                    Sampler(self, Default::default())
                                }
                            }
                        
impl UnsignedTexture2d {

            /// Determines the internal format of this texture.
            ///
            /// The backend may not support querying the actual format, in which case an error
            /// is returned.
            pub fn get_internal_format(&self) -> Result<InternalFormat, GetFormatError> {
                self.0.get_internal_format()
            }
        

                /// Builds a new texture by uploading data.
                ///
                /// This function will automatically generate all mipmaps of the texture.
                pub fn new<'a, F, T>(facade: &F, data: T)
                              -> Result<UnsignedTexture2d, TextureCreationError>
                              where T: Texture2dDataSource<'a>, F: Facade
                {
                    UnsignedTexture2d::new_impl(facade, data, None, MipmapsOption::AutoGeneratedMipmaps)
                }
            

                /// Builds a new texture by uploading data.
                pub fn with_mipmaps<'a, F, T>(facade: &F, data: T, mipmaps: MipmapsOption)
                                              -> Result<UnsignedTexture2d, TextureCreationError>
                                              where T: Texture2dDataSource<'a>, F: Facade
                {
                    UnsignedTexture2d::new_impl(facade, data, None, mipmaps)
                }
            

                /// Builds a new texture with a specific format.
                pub fn with_format<'a, F, T>(facade: &F, data: T,
                                          format: UncompressedUintFormat, mipmaps: MipmapsOption)
                                          -> Result<UnsignedTexture2d, TextureCreationError>
                                          where T: Texture2dDataSource<'a>, F: Facade
                {
                    UnsignedTexture2d::new_impl(facade, data, Some(format), mipmaps)
                }
            

                fn new_impl<'a, F, T>(facade: &F, data: T,
                                   format: Option<UncompressedUintFormat>, mipmaps: MipmapsOption)
                                   -> Result<UnsignedTexture2d, TextureCreationError>
                                   where T: Texture2dDataSource<'a>, F: Facade
                {
            
let format = format.map(|f| {
                           TextureFormatRequest::Specific(f.to_texture_format())
                       }).unwrap_or(TextureFormatRequest::AnyUnsigned);
                    let RawImage2d { data, width, height, format: client_format } =
                                            data.into_raw();
                let client_format = ClientFormatAny::ClientFormat(client_format);Ok(UnsignedTexture2d(try!(any::new_texture(facade, format, Some((client_format, data)), mipmaps.to_regular(), Dimensions::Texture2d { width: width, height: height }))))
}

                /// Creates an empty texture.
                ///
                /// No mipmap level (except for the main level) will be allocated or generated.
                ///
                /// The texture will contain undefined data.
                pub fn empty<F>(facade: &F, width: u32, height: u32)
                                -> Result<UnsignedTexture2d, TextureCreationError>
                                where F: Facade
                {
                    let format = TextureFormatRequest::AnyUnsigned;
            
any::new_texture::<_, u8>(facade, format, None, MipmapsOption::NoMipmap.to_regular(), Dimensions::Texture2d { width: width, height: height }).map(|t| UnsignedTexture2d(t))}

                /// Creates an empty texture with a specific format.
                ///
                /// The texture (and its mipmaps) will contain undefined data.
                pub fn empty_with_format<F>(facade: &F, format: UncompressedUintFormat, mipmaps: MipmapsOption, width: u32, height: u32) -> Result<UnsignedTexture2d, TextureCreationError> where F: Facade {
                    let format = format.to_texture_format();
                    let format = TextureFormatRequest::Specific(format);
            
let t = any::new_texture::<_, u8>(facade, format, None, mipmaps.to_regular(), Dimensions::Texture2d { width: width, height: height });
            t.map(|t| UnsignedTexture2d(t))
}

                /// Creates an empty texture. Specifies whether is has mipmaps.
                ///
                /// The texture (and its mipmaps) will contain undefined data.
                pub fn empty_with_mipmaps<F>(facade: &F, mipmaps: MipmapsOption, width: u32, height: u32) -> Result<UnsignedTexture2d, TextureCreationError> where F: Facade {
                    let format = TextureFormatRequest::AnyUnsigned;
            
any::new_texture::<_, u8>(facade, format, None, mipmaps.to_regular(), Dimensions::Texture2d { width: width, height: height }).map(|t| UnsignedTexture2d(t))
}

            /// Returns the number of mipmap levels of the texture.
            ///
            /// The minimum value is 1, since there is always a main texture.
            pub fn get_mipmap_levels(&self) -> u32 {
                self.0.get_mipmap_levels()
            }
        
            /// Turns the texture into a `ResidentTexture`.
            ///
            /// This allows you to use the texture in a much more efficient way by storing
            /// a "reference to it" in a buffer (actually not a reference but a raw pointer).
            ///
            /// See the documentation of `ResidentTexture` for more infos.
            pub fn resident(self) -> Result<ResidentTexture, BindlessTexturesNotSupportedError> {
                ResidentTexture::new(self.0)
            }
        
                /// Access a single mipmap level of this texture.
                pub fn mipmap(&self, level: u32) -> Option<UnsignedTexture2dMipmap> {
                    self.0.mipmap(0, level).map(|m| UnsignedTexture2dMipmap(m, self))
                }
            
                /// Access the main mipmap level of this texture.
                pub fn main_level(&self) -> UnsignedTexture2dMipmap {
                    self.mipmap(0).unwrap()
                }
            }

                    /// Represents a single mipmap level of a `UnsignedTexture2d`.
                    ///
                    /// Can be obtained by calling `UnsignedTexture2d::mipmap()` or `UnsignedTexture2d::main_level()`.
                    #[derive(Copy, Clone)]
                    pub struct UnsignedTexture2dMipmap<'t>(TextureAnyMipmap<'t>, &'t UnsignedTexture2d);
                impl<'t> UnsignedTexture2dMipmap<'t> {

                /// Returns the corresponding texture.
                pub fn get_texture(&self) -> &'t UnsignedTexture2d {
                    self.1
                }

                /// Returns the texture level.
                pub fn get_level(&self) -> u32 {
                    self.0.get_level()
                }
            }
/// A two-dimensional texture  containing depth data.
pub struct DepthTexture2d(TextureAny);

                impl Texture for DepthTexture2d {
                    fn get_width(&self) -> u32 {
                        self.0.get_width()
                    }

                    fn get_height(&self) -> Option<u32> {
                        self.0.get_height()
                    }

                    fn get_depth(&self) -> Option<u32> {
                        self.0.get_depth()
                    }

                    fn get_array_size(&self) -> Option<u32> {
                        self.0.get_array_size()
                    }
                }
            

                impl GlObject for DepthTexture2d {
                    type Id = gl::types::GLuint;
                    fn get_id(&self) -> gl::types::GLuint {
                        self.0.get_id()
                    }
                }
            

                impl ::std::fmt::Debug for DepthTexture2d {
                    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> Result<(), ::std::fmt::Error>
                    {
                        self.0.fmt(f)
                    }
                }
            

                impl ::std::ops::Deref for DepthTexture2d {
                    type Target = TextureAny;
                    
                    fn deref<'a>(&'a self) -> &'a TextureAny {
                        &self.0
                    }
                }
            

                            impl<'a> AsUniformValue for &'a DepthTexture2d {
                                fn as_uniform_value(&self) -> UniformValue {
                                    UniformValue::DepthTexture2d(*self, None)
                                }
                            }

                            impl<'a> AsUniformValue for Sampler<'a, DepthTexture2d> {
                                fn as_uniform_value(&self) -> UniformValue {
                                    UniformValue::DepthTexture2d(self.0, Some(self.1))
                                }
                            }

                            impl DepthTexture2d {
                                /// Builds a `Sampler` marker object that allows you to indicate
                                /// how the texture should be sampled from inside a shader.
                                ///
                                /// # Example
                                ///
                                /// ```no_run
                                /// # #[macro_use] extern crate glium;
                                /// # fn main() {
                                /// # let texture: glium::texture::Texture2d = unsafe {
                                /// # ::std::mem::uninitialized() };
                                /// let uniforms = uniform! {
                                ///     color_texture: texture.sampled().magnify_filter(glium::uniforms::MagnifySamplerFilter::Nearest)
                                /// };
                                /// # }
                                /// ```
                                pub fn sampled(&self) -> Sampler<DepthTexture2d> {
                                    Sampler(self, Default::default())
                                }
                            }
                        

                        impl ::framebuffer::ToDepthAttachment for DepthTexture2d {
                            fn to_depth_attachment(&self) -> ::framebuffer::DepthAttachment {
                                ::framebuffer::DepthAttachment::Texture(self.0.mipmap(0, 0).unwrap())
                            }
                        }
                    
impl DepthTexture2d {

            /// Determines the internal format of this texture.
            ///
            /// The backend may not support querying the actual format, in which case an error
            /// is returned.
            pub fn get_internal_format(&self) -> Result<InternalFormat, GetFormatError> {
                self.0.get_internal_format()
            }
        

                /// Builds a new texture by uploading data.
                ///
                /// This function will automatically generate all mipmaps of the texture.
                pub fn new<'a, F, T>(facade: &F, data: T)
                              -> Result<DepthTexture2d, TextureCreationError>
                              where T: Texture2dDataSource<'a>, F: Facade
                {
                    DepthTexture2d::new_impl(facade, data, None, MipmapsOption::AutoGeneratedMipmaps)
                }
            

                /// Builds a new texture by uploading data.
                pub fn with_mipmaps<'a, F, T>(facade: &F, data: T, mipmaps: MipmapsOption)
                                              -> Result<DepthTexture2d, TextureCreationError>
                                              where T: Texture2dDataSource<'a>, F: Facade
                {
                    DepthTexture2d::new_impl(facade, data, None, mipmaps)
                }
            

                /// Builds a new texture with a specific format.
                pub fn with_format<'a, F, T>(facade: &F, data: T,
                                          format: DepthFormat, mipmaps: MipmapsOption)
                                          -> Result<DepthTexture2d, TextureCreationError>
                                          where T: Texture2dDataSource<'a>, F: Facade
                {
                    DepthTexture2d::new_impl(facade, data, Some(format), mipmaps)
                }
            

                fn new_impl<'a, F, T>(facade: &F, data: T,
                                   format: Option<DepthFormat>, mipmaps: MipmapsOption)
                                   -> Result<DepthTexture2d, TextureCreationError>
                                   where T: Texture2dDataSource<'a>, F: Facade
                {
            
let format = format.map(|f| {
                           TextureFormatRequest::Specific(f.to_texture_format())
                       }).unwrap_or(TextureFormatRequest::AnyDepth);
                    let RawImage2d { data, width, height, format: client_format } =
                                            data.into_raw();
                let client_format = ClientFormatAny::ClientFormat(client_format);Ok(DepthTexture2d(try!(any::new_texture(facade, format, Some((client_format, data)), mipmaps.to_regular(), Dimensions::Texture2d { width: width, height: height }))))
}

                /// Creates an empty texture.
                ///
                /// No mipmap level (except for the main level) will be allocated or generated.
                ///
                /// The texture will contain undefined data.
                pub fn empty<F>(facade: &F, width: u32, height: u32)
                                -> Result<DepthTexture2d, TextureCreationError>
                                where F: Facade
                {
                    let format = TextureFormatRequest::AnyDepth;
            
any::new_texture::<_, u8>(facade, format, None, MipmapsOption::NoMipmap.to_regular(), Dimensions::Texture2d { width: width, height: height }).map(|t| DepthTexture2d(t))}

                /// Creates an empty texture with a specific format.
                ///
                /// The texture (and its mipmaps) will contain undefined data.
                pub fn empty_with_format<F>(facade: &F, format: DepthFormat, mipmaps: MipmapsOption, width: u32, height: u32) -> Result<DepthTexture2d, TextureCreationError> where F: Facade {
                    let format = format.to_texture_format();
                    let format = TextureFormatRequest::Specific(format);
            
let t = any::new_texture::<_, u8>(facade, format, None, mipmaps.to_regular(), Dimensions::Texture2d { width: width, height: height });
            t.map(|t| DepthTexture2d(t))
}

                /// Creates an empty texture. Specifies whether is has mipmaps.
                ///
                /// The texture (and its mipmaps) will contain undefined data.
                pub fn empty_with_mipmaps<F>(facade: &F, mipmaps: MipmapsOption, width: u32, height: u32) -> Result<DepthTexture2d, TextureCreationError> where F: Facade {
                    let format = TextureFormatRequest::AnyDepth;
            
any::new_texture::<_, u8>(facade, format, None, mipmaps.to_regular(), Dimensions::Texture2d { width: width, height: height }).map(|t| DepthTexture2d(t))
}

            /// Returns the number of mipmap levels of the texture.
            ///
            /// The minimum value is 1, since there is always a main texture.
            pub fn get_mipmap_levels(&self) -> u32 {
                self.0.get_mipmap_levels()
            }
        
            /// Turns the texture into a `ResidentTexture`.
            ///
            /// This allows you to use the texture in a much more efficient way by storing
            /// a "reference to it" in a buffer (actually not a reference but a raw pointer).
            ///
            /// See the documentation of `ResidentTexture` for more infos.
            pub fn resident(self) -> Result<ResidentTexture, BindlessTexturesNotSupportedError> {
                ResidentTexture::new(self.0)
            }
        
                /// Access a single mipmap level of this texture.
                pub fn mipmap(&self, level: u32) -> Option<DepthTexture2dMipmap> {
                    self.0.mipmap(0, level).map(|m| DepthTexture2dMipmap(m, self))
                }
            
                /// Access the main mipmap level of this texture.
                pub fn main_level(&self) -> DepthTexture2dMipmap {
                    self.mipmap(0).unwrap()
                }
            }

                    /// Represents a single mipmap level of a `DepthTexture2d`.
                    ///
                    /// Can be obtained by calling `DepthTexture2d::mipmap()` or `DepthTexture2d::main_level()`.
                    #[derive(Copy, Clone)]
                    pub struct DepthTexture2dMipmap<'t>(TextureAnyMipmap<'t>, &'t DepthTexture2d);
                impl<'t> DepthTexture2dMipmap<'t> {

                /// Returns the corresponding texture.
                pub fn get_texture(&self) -> &'t DepthTexture2d {
                    self.1
                }

                /// Returns the texture level.
                pub fn get_level(&self) -> u32 {
                    self.0.get_level()
                }
            }
/// A two-dimensional texture  containing stencil data.
pub struct StencilTexture2d(TextureAny);

                impl Texture for StencilTexture2d {
                    fn get_width(&self) -> u32 {
                        self.0.get_width()
                    }

                    fn get_height(&self) -> Option<u32> {
                        self.0.get_height()
                    }

                    fn get_depth(&self) -> Option<u32> {
                        self.0.get_depth()
                    }

                    fn get_array_size(&self) -> Option<u32> {
                        self.0.get_array_size()
                    }
                }
            

                impl GlObject for StencilTexture2d {
                    type Id = gl::types::GLuint;
                    fn get_id(&self) -> gl::types::GLuint {
                        self.0.get_id()
                    }
                }
            

                impl ::std::fmt::Debug for StencilTexture2d {
                    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> Result<(), ::std::fmt::Error>
                    {
                        self.0.fmt(f)
                    }
                }
            

                impl ::std::ops::Deref for StencilTexture2d {
                    type Target = TextureAny;
                    
                    fn deref<'a>(&'a self) -> &'a TextureAny {
                        &self.0
                    }
                }
            

                        impl ::framebuffer::ToStencilAttachment for StencilTexture2d {
                            fn to_stencil_attachment(&self) -> ::framebuffer::StencilAttachment {
                                ::framebuffer::StencilAttachment::Texture(self.0.mipmap(0, 0).unwrap())
                            }
                        }
                    
impl StencilTexture2d {

            /// Determines the internal format of this texture.
            ///
            /// The backend may not support querying the actual format, in which case an error
            /// is returned.
            pub fn get_internal_format(&self) -> Result<InternalFormat, GetFormatError> {
                self.0.get_internal_format()
            }
        

                /// Builds a new texture by uploading data.
                ///
                /// This function will automatically generate all mipmaps of the texture.
                pub fn new<'a, F, T>(facade: &F, data: T)
                              -> Result<StencilTexture2d, TextureCreationError>
                              where T: Texture2dDataSource<'a>, F: Facade
                {
                    StencilTexture2d::new_impl(facade, data, None, MipmapsOption::AutoGeneratedMipmaps)
                }
            

                /// Builds a new texture by uploading data.
                pub fn with_mipmaps<'a, F, T>(facade: &F, data: T, mipmaps: MipmapsOption)
                                              -> Result<StencilTexture2d, TextureCreationError>
                                              where T: Texture2dDataSource<'a>, F: Facade
                {
                    StencilTexture2d::new_impl(facade, data, None, mipmaps)
                }
            

                /// Builds a new texture with a specific format.
                pub fn with_format<'a, F, T>(facade: &F, data: T,
                                          format: StencilFormat, mipmaps: MipmapsOption)
                                          -> Result<StencilTexture2d, TextureCreationError>
                                          where T: Texture2dDataSource<'a>, F: Facade
                {
                    StencilTexture2d::new_impl(facade, data, Some(format), mipmaps)
                }
            

                fn new_impl<'a, F, T>(facade: &F, data: T,
                                   format: Option<StencilFormat>, mipmaps: MipmapsOption)
                                   -> Result<StencilTexture2d, TextureCreationError>
                                   where T: Texture2dDataSource<'a>, F: Facade
                {
            
let format = format.map(|f| {
                           TextureFormatRequest::Specific(f.to_texture_format())
                       }).unwrap_or(TextureFormatRequest::AnyStencil);
                    let RawImage2d { data, width, height, format: client_format } =
                                            data.into_raw();
                let client_format = ClientFormatAny::ClientFormat(client_format);Ok(StencilTexture2d(try!(any::new_texture(facade, format, Some((client_format, data)), mipmaps.to_regular(), Dimensions::Texture2d { width: width, height: height }))))
}

                /// Creates an empty texture.
                ///
                /// No mipmap level (except for the main level) will be allocated or generated.
                ///
                /// The texture will contain undefined data.
                pub fn empty<F>(facade: &F, width: u32, height: u32)
                                -> Result<StencilTexture2d, TextureCreationError>
                                where F: Facade
                {
                    let format = TextureFormatRequest::AnyStencil;
            
any::new_texture::<_, u8>(facade, format, None, MipmapsOption::NoMipmap.to_regular(), Dimensions::Texture2d { width: width, height: height }).map(|t| StencilTexture2d(t))}

                /// Creates an empty texture with a specific format.
                ///
                /// The texture (and its mipmaps) will contain undefined data.
                pub fn empty_with_format<F>(facade: &F, format: StencilFormat, mipmaps: MipmapsOption, width: u32, height: u32) -> Result<StencilTexture2d, TextureCreationError> where F: Facade {
                    let format = format.to_texture_format();
                    let format = TextureFormatRequest::Specific(format);
            
let t = any::new_texture::<_, u8>(facade, format, None, mipmaps.to_regular(), Dimensions::Texture2d { width: width, height: height });
            t.map(|t| StencilTexture2d(t))
}

                /// Creates an empty texture. Specifies whether is has mipmaps.
                ///
                /// The texture (and its mipmaps) will contain undefined data.
                pub fn empty_with_mipmaps<F>(facade: &F, mipmaps: MipmapsOption, width: u32, height: u32) -> Result<StencilTexture2d, TextureCreationError> where F: Facade {
                    let format = TextureFormatRequest::AnyStencil;
            
any::new_texture::<_, u8>(facade, format, None, mipmaps.to_regular(), Dimensions::Texture2d { width: width, height: height }).map(|t| StencilTexture2d(t))
}

            /// Returns the number of mipmap levels of the texture.
            ///
            /// The minimum value is 1, since there is always a main texture.
            pub fn get_mipmap_levels(&self) -> u32 {
                self.0.get_mipmap_levels()
            }
        
            /// Turns the texture into a `ResidentTexture`.
            ///
            /// This allows you to use the texture in a much more efficient way by storing
            /// a "reference to it" in a buffer (actually not a reference but a raw pointer).
            ///
            /// See the documentation of `ResidentTexture` for more infos.
            pub fn resident(self) -> Result<ResidentTexture, BindlessTexturesNotSupportedError> {
                ResidentTexture::new(self.0)
            }
        
                /// Access a single mipmap level of this texture.
                pub fn mipmap(&self, level: u32) -> Option<StencilTexture2dMipmap> {
                    self.0.mipmap(0, level).map(|m| StencilTexture2dMipmap(m, self))
                }
            
                /// Access the main mipmap level of this texture.
                pub fn main_level(&self) -> StencilTexture2dMipmap {
                    self.mipmap(0).unwrap()
                }
            }

                    /// Represents a single mipmap level of a `StencilTexture2d`.
                    ///
                    /// Can be obtained by calling `StencilTexture2d::mipmap()` or `StencilTexture2d::main_level()`.
                    #[derive(Copy, Clone)]
                    pub struct StencilTexture2dMipmap<'t>(TextureAnyMipmap<'t>, &'t StencilTexture2d);
                impl<'t> StencilTexture2dMipmap<'t> {

                /// Returns the corresponding texture.
                pub fn get_texture(&self) -> &'t StencilTexture2d {
                    self.1
                }

                /// Returns the texture level.
                pub fn get_level(&self) -> u32 {
                    self.0.get_level()
                }
            }
/// A two-dimensional texture  containing both depth and stencil data.
pub struct DepthStencilTexture2d(TextureAny);

                impl Texture for DepthStencilTexture2d {
                    fn get_width(&self) -> u32 {
                        self.0.get_width()
                    }

                    fn get_height(&self) -> Option<u32> {
                        self.0.get_height()
                    }

                    fn get_depth(&self) -> Option<u32> {
                        self.0.get_depth()
                    }

                    fn get_array_size(&self) -> Option<u32> {
                        self.0.get_array_size()
                    }
                }
            

                impl GlObject for DepthStencilTexture2d {
                    type Id = gl::types::GLuint;
                    fn get_id(&self) -> gl::types::GLuint {
                        self.0.get_id()
                    }
                }
            

                impl ::std::fmt::Debug for DepthStencilTexture2d {
                    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> Result<(), ::std::fmt::Error>
                    {
                        self.0.fmt(f)
                    }
                }
            

                impl ::std::ops::Deref for DepthStencilTexture2d {
                    type Target = TextureAny;
                    
                    fn deref<'a>(&'a self) -> &'a TextureAny {
                        &self.0
                    }
                }
            

                        impl ::framebuffer::ToDepthStencilAttachment for DepthStencilTexture2d {
                            fn to_depth_stencil_attachment(&self) -> ::framebuffer::DepthStencilAttachment {
                                ::framebuffer::DepthStencilAttachment::Texture(self.0.mipmap(0, 0).unwrap())
                            }
                        }
                    
impl DepthStencilTexture2d {

            /// Determines the internal format of this texture.
            ///
            /// The backend may not support querying the actual format, in which case an error
            /// is returned.
            pub fn get_internal_format(&self) -> Result<InternalFormat, GetFormatError> {
                self.0.get_internal_format()
            }
        

                /// Builds a new texture by uploading data.
                ///
                /// This function will automatically generate all mipmaps of the texture.
                pub fn new<'a, F, T>(facade: &F, data: T)
                              -> Result<DepthStencilTexture2d, TextureCreationError>
                              where T: Texture2dDataSource<'a>, F: Facade
                {
                    DepthStencilTexture2d::new_impl(facade, data, None, MipmapsOption::AutoGeneratedMipmaps)
                }
            

                /// Builds a new texture by uploading data.
                pub fn with_mipmaps<'a, F, T>(facade: &F, data: T, mipmaps: MipmapsOption)
                                              -> Result<DepthStencilTexture2d, TextureCreationError>
                                              where T: Texture2dDataSource<'a>, F: Facade
                {
                    DepthStencilTexture2d::new_impl(facade, data, None, mipmaps)
                }
            

                /// Builds a new texture with a specific format.
                pub fn with_format<'a, F, T>(facade: &F, data: T,
                                          format: DepthStencilFormat, mipmaps: MipmapsOption)
                                          -> Result<DepthStencilTexture2d, TextureCreationError>
                                          where T: Texture2dDataSource<'a>, F: Facade
                {
                    DepthStencilTexture2d::new_impl(facade, data, Some(format), mipmaps)
                }
            

                fn new_impl<'a, F, T>(facade: &F, data: T,
                                   format: Option<DepthStencilFormat>, mipmaps: MipmapsOption)
                                   -> Result<DepthStencilTexture2d, TextureCreationError>
                                   where T: Texture2dDataSource<'a>, F: Facade
                {
            
let format = format.map(|f| {
                           TextureFormatRequest::Specific(f.to_texture_format())
                       }).unwrap_or(TextureFormatRequest::AnyDepthStencil);
                    let RawImage2d { data, width, height, format: client_format } =
                                            data.into_raw();
                let client_format = ClientFormatAny::ClientFormat(client_format);Ok(DepthStencilTexture2d(try!(any::new_texture(facade, format, Some((client_format, data)), mipmaps.to_regular(), Dimensions::Texture2d { width: width, height: height }))))
}

                /// Creates an empty texture.
                ///
                /// No mipmap level (except for the main level) will be allocated or generated.
                ///
                /// The texture will contain undefined data.
                pub fn empty<F>(facade: &F, width: u32, height: u32)
                                -> Result<DepthStencilTexture2d, TextureCreationError>
                                where F: Facade
                {
                    let format = TextureFormatRequest::AnyDepthStencil;
            
any::new_texture::<_, u8>(facade, format, None, MipmapsOption::NoMipmap.to_regular(), Dimensions::Texture2d { width: width, height: height }).map(|t| DepthStencilTexture2d(t))}

                /// Creates an empty texture with a specific format.
                ///
                /// The texture (and its mipmaps) will contain undefined data.
                pub fn empty_with_format<F>(facade: &F, format: DepthStencilFormat, mipmaps: MipmapsOption, width: u32, height: u32) -> Result<DepthStencilTexture2d, TextureCreationError> where F: Facade {
                    let format = format.to_texture_format();
                    let format = TextureFormatRequest::Specific(format);
            
let t = any::new_texture::<_, u8>(facade, format, None, mipmaps.to_regular(), Dimensions::Texture2d { width: width, height: height });
            t.map(|t| DepthStencilTexture2d(t))
}

                /// Creates an empty texture. Specifies whether is has mipmaps.
                ///
                /// The texture (and its mipmaps) will contain undefined data.
                pub fn empty_with_mipmaps<F>(facade: &F, mipmaps: MipmapsOption, width: u32, height: u32) -> Result<DepthStencilTexture2d, TextureCreationError> where F: Facade {
                    let format = TextureFormatRequest::AnyDepthStencil;
            
any::new_texture::<_, u8>(facade, format, None, mipmaps.to_regular(), Dimensions::Texture2d { width: width, height: height }).map(|t| DepthStencilTexture2d(t))
}

            /// Returns the number of mipmap levels of the texture.
            ///
            /// The minimum value is 1, since there is always a main texture.
            pub fn get_mipmap_levels(&self) -> u32 {
                self.0.get_mipmap_levels()
            }
        
            /// Turns the texture into a `ResidentTexture`.
            ///
            /// This allows you to use the texture in a much more efficient way by storing
            /// a "reference to it" in a buffer (actually not a reference but a raw pointer).
            ///
            /// See the documentation of `ResidentTexture` for more infos.
            pub fn resident(self) -> Result<ResidentTexture, BindlessTexturesNotSupportedError> {
                ResidentTexture::new(self.0)
            }
        
                /// Access a single mipmap level of this texture.
                pub fn mipmap(&self, level: u32) -> Option<DepthStencilTexture2dMipmap> {
                    self.0.mipmap(0, level).map(|m| DepthStencilTexture2dMipmap(m, self))
                }
            
                /// Access the main mipmap level of this texture.
                pub fn main_level(&self) -> DepthStencilTexture2dMipmap {
                    self.mipmap(0).unwrap()
                }
            }

                    /// Represents a single mipmap level of a `DepthStencilTexture2d`.
                    ///
                    /// Can be obtained by calling `DepthStencilTexture2d::mipmap()` or `DepthStencilTexture2d::main_level()`.
                    #[derive(Copy, Clone)]
                    pub struct DepthStencilTexture2dMipmap<'t>(TextureAnyMipmap<'t>, &'t DepthStencilTexture2d);
                impl<'t> DepthStencilTexture2dMipmap<'t> {

                /// Returns the corresponding texture.
                pub fn get_texture(&self) -> &'t DepthStencilTexture2d {
                    self.1
                }

                /// Returns the texture level.
                pub fn get_level(&self) -> u32 {
                    self.0.get_level()
                }
            }
/// A two-dimensional texture  containing floating-point data.
pub struct Texture2dMultisample(TextureAny);

                impl Texture for Texture2dMultisample {
                    fn get_width(&self) -> u32 {
                        self.0.get_width()
                    }

                    fn get_height(&self) -> Option<u32> {
                        self.0.get_height()
                    }

                    fn get_depth(&self) -> Option<u32> {
                        self.0.get_depth()
                    }

                    fn get_array_size(&self) -> Option<u32> {
                        self.0.get_array_size()
                    }
                }
            

                impl GlObject for Texture2dMultisample {
                    type Id = gl::types::GLuint;
                    fn get_id(&self) -> gl::types::GLuint {
                        self.0.get_id()
                    }
                }
            

                impl ::std::fmt::Debug for Texture2dMultisample {
                    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> Result<(), ::std::fmt::Error>
                    {
                        self.0.fmt(f)
                    }
                }
            

                impl ::std::ops::Deref for Texture2dMultisample {
                    type Target = TextureAny;
                    
                    fn deref<'a>(&'a self) -> &'a TextureAny {
                        &self.0
                    }
                }
            

                            impl<'a> AsUniformValue for &'a Texture2dMultisample {
                                fn as_uniform_value(&self) -> UniformValue {
                                    UniformValue::Texture2dMultisample(*self, None)
                                }
                            }

                            impl<'a> AsUniformValue for Sampler<'a, Texture2dMultisample> {
                                fn as_uniform_value(&self) -> UniformValue {
                                    UniformValue::Texture2dMultisample(self.0, Some(self.1))
                                }
                            }

                            impl Texture2dMultisample {
                                /// Builds a `Sampler` marker object that allows you to indicate
                                /// how the texture should be sampled from inside a shader.
                                ///
                                /// # Example
                                ///
                                /// ```no_run
                                /// # #[macro_use] extern crate glium;
                                /// # fn main() {
                                /// # let texture: glium::texture::Texture2d = unsafe {
                                /// # ::std::mem::uninitialized() };
                                /// let uniforms = uniform! {
                                ///     color_texture: texture.sampled().magnify_filter(glium::uniforms::MagnifySamplerFilter::Nearest)
                                /// };
                                /// # }
                                /// ```
                                pub fn sampled(&self) -> Sampler<Texture2dMultisample> {
                                    Sampler(self, Default::default())
                                }
                            }
                        

                        impl ::framebuffer::ToColorAttachment for Texture2dMultisample {
                            fn to_color_attachment(&self) -> ::framebuffer::ColorAttachment {
                                ::framebuffer::ColorAttachment::Texture(self.0.mipmap(0, 0).unwrap())
                            }
                        }
                    
impl Texture2dMultisample {

            /// Determines the internal format of this texture.
            ///
            /// The backend may not support querying the actual format, in which case an error
            /// is returned.
            pub fn get_internal_format(&self) -> Result<InternalFormat, GetFormatError> {
                self.0.get_internal_format()
            }
        

                /// Creates an empty texture.
                ///
                /// No mipmap level (except for the main level) will be allocated or generated.
                ///
                /// The texture will contain undefined data.
                pub fn empty<F>(facade: &F, width: u32, height: u32, samples: u32)
                                -> Result<Texture2dMultisample, TextureCreationError>
                                where F: Facade
                {
                    let format = TextureFormatRequest::AnyFloatingPoint;
            
any::new_texture::<_, u8>(facade, format, None, MipmapsOption::NoMipmap.to_regular(), Dimensions::Texture2dMultisample { width: width, height: height, samples: samples }).map(|t| Texture2dMultisample(t))}

                /// Creates an empty texture with a specific format.
                ///
                /// The texture (and its mipmaps) will contain undefined data.
                pub fn empty_with_format<F>(facade: &F, format: UncompressedFloatFormat, mipmaps: MipmapsOption, width: u32, height: u32, samples: u32) -> Result<Texture2dMultisample, TextureCreationError> where F: Facade {
                    let format = format.to_texture_format();
                    let format = TextureFormatRequest::Specific(format);
            
let t = any::new_texture::<_, u8>(facade, format, None, mipmaps.to_regular(), Dimensions::Texture2dMultisample { width: width, height: height, samples: samples });
            t.map(|t| Texture2dMultisample(t))
}

                /// Creates an empty texture. Specifies whether is has mipmaps.
                ///
                /// The texture (and its mipmaps) will contain undefined data.
                pub fn empty_with_mipmaps<F>(facade: &F, mipmaps: MipmapsOption, width: u32, height: u32, samples: u32) -> Result<Texture2dMultisample, TextureCreationError> where F: Facade {
                    let format = TextureFormatRequest::AnyFloatingPoint;
            
any::new_texture::<_, u8>(facade, format, None, mipmaps.to_regular(), Dimensions::Texture2dMultisample { width: width, height: height, samples: samples }).map(|t| Texture2dMultisample(t))
}

                /// Starts drawing on the texture.
                ///
                /// All the function calls to the framebuffer will draw on the texture instead
                /// of the screen.
                ///
                /// ## Low-level information
                ///
                /// The first time that this function is called, a FrameBuffer Object will be
                /// created and cached. The following calls to `as_surface` will load the existing
                /// FBO and re-use it. When the texture is destroyed, the FBO is destroyed too.
                ///
                pub fn as_surface<'a>(&'a self) -> framebuffer::SimpleFrameBuffer<'a> {
                    framebuffer::SimpleFrameBuffer::new(self.0.get_context(), self)
                }
            
            /// Returns the number of mipmap levels of the texture.
            ///
            /// The minimum value is 1, since there is always a main texture.
            pub fn get_mipmap_levels(&self) -> u32 {
                self.0.get_mipmap_levels()
            }
        
            /// Turns the texture into a `ResidentTexture`.
            ///
            /// This allows you to use the texture in a much more efficient way by storing
            /// a "reference to it" in a buffer (actually not a reference but a raw pointer).
            ///
            /// See the documentation of `ResidentTexture` for more infos.
            pub fn resident(self) -> Result<ResidentTexture, BindlessTexturesNotSupportedError> {
                ResidentTexture::new(self.0)
            }
        
                /// Access a single mipmap level of this texture.
                pub fn mipmap(&self, level: u32) -> Option<Texture2dMultisampleMipmap> {
                    self.0.mipmap(0, level).map(|m| Texture2dMultisampleMipmap(m, self))
                }
            
                /// Access the main mipmap level of this texture.
                pub fn main_level(&self) -> Texture2dMultisampleMipmap {
                    self.mipmap(0).unwrap()
                }
            }

                    /// Represents a single mipmap level of a `Texture2dMultisample`.
                    ///
                    /// Can be obtained by calling `Texture2dMultisample::mipmap()` or `Texture2dMultisample::main_level()`.
                    #[derive(Copy, Clone)]
                    pub struct Texture2dMultisampleMipmap<'t>(TextureAnyMipmap<'t>, &'t Texture2dMultisample);
                impl<'t> Texture2dMultisampleMipmap<'t> {

                /// Returns the corresponding texture.
                pub fn get_texture(&self) -> &'t Texture2dMultisample {
                    self.1
                }

                /// Returns the texture level.
                pub fn get_level(&self) -> u32 {
                    self.0.get_level()
                }
            }
/// A two-dimensional texture  containing signed integral data.
pub struct IntegralTexture2dMultisample(TextureAny);

                impl Texture for IntegralTexture2dMultisample {
                    fn get_width(&self) -> u32 {
                        self.0.get_width()
                    }

                    fn get_height(&self) -> Option<u32> {
                        self.0.get_height()
                    }

                    fn get_depth(&self) -> Option<u32> {
                        self.0.get_depth()
                    }

                    fn get_array_size(&self) -> Option<u32> {
                        self.0.get_array_size()
                    }
                }
            

                impl GlObject for IntegralTexture2dMultisample {
                    type Id = gl::types::GLuint;
                    fn get_id(&self) -> gl::types::GLuint {
                        self.0.get_id()
                    }
                }
            

                impl ::std::fmt::Debug for IntegralTexture2dMultisample {
                    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> Result<(), ::std::fmt::Error>
                    {
                        self.0.fmt(f)
                    }
                }
            

                impl ::std::ops::Deref for IntegralTexture2dMultisample {
                    type Target = TextureAny;
                    
                    fn deref<'a>(&'a self) -> &'a TextureAny {
                        &self.0
                    }
                }
            

                            impl<'a> AsUniformValue for &'a IntegralTexture2dMultisample {
                                fn as_uniform_value(&self) -> UniformValue {
                                    UniformValue::IntegralTexture2dMultisample(*self, None)
                                }
                            }

                            impl<'a> AsUniformValue for Sampler<'a, IntegralTexture2dMultisample> {
                                fn as_uniform_value(&self) -> UniformValue {
                                    UniformValue::IntegralTexture2dMultisample(self.0, Some(self.1))
                                }
                            }

                            impl IntegralTexture2dMultisample {
                                /// Builds a `Sampler` marker object that allows you to indicate
                                /// how the texture should be sampled from inside a shader.
                                ///
                                /// # Example
                                ///
                                /// ```no_run
                                /// # #[macro_use] extern crate glium;
                                /// # fn main() {
                                /// # let texture: glium::texture::Texture2d = unsafe {
                                /// # ::std::mem::uninitialized() };
                                /// let uniforms = uniform! {
                                ///     color_texture: texture.sampled().magnify_filter(glium::uniforms::MagnifySamplerFilter::Nearest)
                                /// };
                                /// # }
                                /// ```
                                pub fn sampled(&self) -> Sampler<IntegralTexture2dMultisample> {
                                    Sampler(self, Default::default())
                                }
                            }
                        
impl IntegralTexture2dMultisample {

            /// Determines the internal format of this texture.
            ///
            /// The backend may not support querying the actual format, in which case an error
            /// is returned.
            pub fn get_internal_format(&self) -> Result<InternalFormat, GetFormatError> {
                self.0.get_internal_format()
            }
        

                /// Creates an empty texture.
                ///
                /// No mipmap level (except for the main level) will be allocated or generated.
                ///
                /// The texture will contain undefined data.
                pub fn empty<F>(facade: &F, width: u32, height: u32, samples: u32)
                                -> Result<IntegralTexture2dMultisample, TextureCreationError>
                                where F: Facade
                {
                    let format = TextureFormatRequest::AnyIntegral;
            
any::new_texture::<_, u8>(facade, format, None, MipmapsOption::NoMipmap.to_regular(), Dimensions::Texture2dMultisample { width: width, height: height, samples: samples }).map(|t| IntegralTexture2dMultisample(t))}

                /// Creates an empty texture with a specific format.
                ///
                /// The texture (and its mipmaps) will contain undefined data.
                pub fn empty_with_format<F>(facade: &F, format: UncompressedIntFormat, mipmaps: MipmapsOption, width: u32, height: u32, samples: u32) -> Result<IntegralTexture2dMultisample, TextureCreationError> where F: Facade {
                    let format = format.to_texture_format();
                    let format = TextureFormatRequest::Specific(format);
            
let t = any::new_texture::<_, u8>(facade, format, None, mipmaps.to_regular(), Dimensions::Texture2dMultisample { width: width, height: height, samples: samples });
            t.map(|t| IntegralTexture2dMultisample(t))
}

                /// Creates an empty texture. Specifies whether is has mipmaps.
                ///
                /// The texture (and its mipmaps) will contain undefined data.
                pub fn empty_with_mipmaps<F>(facade: &F, mipmaps: MipmapsOption, width: u32, height: u32, samples: u32) -> Result<IntegralTexture2dMultisample, TextureCreationError> where F: Facade {
                    let format = TextureFormatRequest::AnyIntegral;
            
any::new_texture::<_, u8>(facade, format, None, mipmaps.to_regular(), Dimensions::Texture2dMultisample { width: width, height: height, samples: samples }).map(|t| IntegralTexture2dMultisample(t))
}

            /// Returns the number of mipmap levels of the texture.
            ///
            /// The minimum value is 1, since there is always a main texture.
            pub fn get_mipmap_levels(&self) -> u32 {
                self.0.get_mipmap_levels()
            }
        
            /// Turns the texture into a `ResidentTexture`.
            ///
            /// This allows you to use the texture in a much more efficient way by storing
            /// a "reference to it" in a buffer (actually not a reference but a raw pointer).
            ///
            /// See the documentation of `ResidentTexture` for more infos.
            pub fn resident(self) -> Result<ResidentTexture, BindlessTexturesNotSupportedError> {
                ResidentTexture::new(self.0)
            }
        
                /// Access a single mipmap level of this texture.
                pub fn mipmap(&self, level: u32) -> Option<IntegralTexture2dMultisampleMipmap> {
                    self.0.mipmap(0, level).map(|m| IntegralTexture2dMultisampleMipmap(m, self))
                }
            
                /// Access the main mipmap level of this texture.
                pub fn main_level(&self) -> IntegralTexture2dMultisampleMipmap {
                    self.mipmap(0).unwrap()
                }
            }

                    /// Represents a single mipmap level of a `IntegralTexture2dMultisample`.
                    ///
                    /// Can be obtained by calling `IntegralTexture2dMultisample::mipmap()` or `IntegralTexture2dMultisample::main_level()`.
                    #[derive(Copy, Clone)]
                    pub struct IntegralTexture2dMultisampleMipmap<'t>(TextureAnyMipmap<'t>, &'t IntegralTexture2dMultisample);
                impl<'t> IntegralTexture2dMultisampleMipmap<'t> {

                /// Returns the corresponding texture.
                pub fn get_texture(&self) -> &'t IntegralTexture2dMultisample {
                    self.1
                }

                /// Returns the texture level.
                pub fn get_level(&self) -> u32 {
                    self.0.get_level()
                }
            }
/// A two-dimensional texture  containing sRGB floating-point data.
pub struct SrgbTexture2dMultisample(TextureAny);

                impl Texture for SrgbTexture2dMultisample {
                    fn get_width(&self) -> u32 {
                        self.0.get_width()
                    }

                    fn get_height(&self) -> Option<u32> {
                        self.0.get_height()
                    }

                    fn get_depth(&self) -> Option<u32> {
                        self.0.get_depth()
                    }

                    fn get_array_size(&self) -> Option<u32> {
                        self.0.get_array_size()
                    }
                }
            

                impl GlObject for SrgbTexture2dMultisample {
                    type Id = gl::types::GLuint;
                    fn get_id(&self) -> gl::types::GLuint {
                        self.0.get_id()
                    }
                }
            

                impl ::std::fmt::Debug for SrgbTexture2dMultisample {
                    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> Result<(), ::std::fmt::Error>
                    {
                        self.0.fmt(f)
                    }
                }
            

                impl ::std::ops::Deref for SrgbTexture2dMultisample {
                    type Target = TextureAny;
                    
                    fn deref<'a>(&'a self) -> &'a TextureAny {
                        &self.0
                    }
                }
            

                            impl<'a> AsUniformValue for &'a SrgbTexture2dMultisample {
                                fn as_uniform_value(&self) -> UniformValue {
                                    UniformValue::SrgbTexture2dMultisample(*self, None)
                                }
                            }

                            impl<'a> AsUniformValue for Sampler<'a, SrgbTexture2dMultisample> {
                                fn as_uniform_value(&self) -> UniformValue {
                                    UniformValue::SrgbTexture2dMultisample(self.0, Some(self.1))
                                }
                            }

                            impl SrgbTexture2dMultisample {
                                /// Builds a `Sampler` marker object that allows you to indicate
                                /// how the texture should be sampled from inside a shader.
                                ///
                                /// # Example
                                ///
                                /// ```no_run
                                /// # #[macro_use] extern crate glium;
                                /// # fn main() {
                                /// # let texture: glium::texture::Texture2d = unsafe {
                                /// # ::std::mem::uninitialized() };
                                /// let uniforms = uniform! {
                                ///     color_texture: texture.sampled().magnify_filter(glium::uniforms::MagnifySamplerFilter::Nearest)
                                /// };
                                /// # }
                                /// ```
                                pub fn sampled(&self) -> Sampler<SrgbTexture2dMultisample> {
                                    Sampler(self, Default::default())
                                }
                            }
                        

                        impl ::framebuffer::ToColorAttachment for SrgbTexture2dMultisample {
                            fn to_color_attachment(&self) -> ::framebuffer::ColorAttachment {
                                ::framebuffer::ColorAttachment::Texture(self.0.mipmap(0, 0).unwrap())
                            }
                        }
                    
impl SrgbTexture2dMultisample {

            /// Determines the internal format of this texture.
            ///
            /// The backend may not support querying the actual format, in which case an error
            /// is returned.
            pub fn get_internal_format(&self) -> Result<InternalFormat, GetFormatError> {
                self.0.get_internal_format()
            }
        

                /// Creates an empty texture.
                ///
                /// No mipmap level (except for the main level) will be allocated or generated.
                ///
                /// The texture will contain undefined data.
                pub fn empty<F>(facade: &F, width: u32, height: u32, samples: u32)
                                -> Result<SrgbTexture2dMultisample, TextureCreationError>
                                where F: Facade
                {
                    let format = TextureFormatRequest::AnySrgb;
            
any::new_texture::<_, u8>(facade, format, None, MipmapsOption::NoMipmap.to_regular(), Dimensions::Texture2dMultisample { width: width, height: height, samples: samples }).map(|t| SrgbTexture2dMultisample(t))}

                /// Creates an empty texture with a specific format.
                ///
                /// The texture (and its mipmaps) will contain undefined data.
                pub fn empty_with_format<F>(facade: &F, format: SrgbFormat, mipmaps: MipmapsOption, width: u32, height: u32, samples: u32) -> Result<SrgbTexture2dMultisample, TextureCreationError> where F: Facade {
                    let format = format.to_texture_format();
                    let format = TextureFormatRequest::Specific(format);
            
let t = any::new_texture::<_, u8>(facade, format, None, mipmaps.to_regular(), Dimensions::Texture2dMultisample { width: width, height: height, samples: samples });
            t.map(|t| SrgbTexture2dMultisample(t))
}

                /// Creates an empty texture. Specifies whether is has mipmaps.
                ///
                /// The texture (and its mipmaps) will contain undefined data.
                pub fn empty_with_mipmaps<F>(facade: &F, mipmaps: MipmapsOption, width: u32, height: u32, samples: u32) -> Result<SrgbTexture2dMultisample, TextureCreationError> where F: Facade {
                    let format = TextureFormatRequest::AnySrgb;
            
any::new_texture::<_, u8>(facade, format, None, mipmaps.to_regular(), Dimensions::Texture2dMultisample { width: width, height: height, samples: samples }).map(|t| SrgbTexture2dMultisample(t))
}

            /// Returns the number of mipmap levels of the texture.
            ///
            /// The minimum value is 1, since there is always a main texture.
            pub fn get_mipmap_levels(&self) -> u32 {
                self.0.get_mipmap_levels()
            }
        
            /// Turns the texture into a `ResidentTexture`.
            ///
            /// This allows you to use the texture in a much more efficient way by storing
            /// a "reference to it" in a buffer (actually not a reference but a raw pointer).
            ///
            /// See the documentation of `ResidentTexture` for more infos.
            pub fn resident(self) -> Result<ResidentTexture, BindlessTexturesNotSupportedError> {
                ResidentTexture::new(self.0)
            }
        
                /// Access a single mipmap level of this texture.
                pub fn mipmap(&self, level: u32) -> Option<SrgbTexture2dMultisampleMipmap> {
                    self.0.mipmap(0, level).map(|m| SrgbTexture2dMultisampleMipmap(m, self))
                }
            
                /// Access the main mipmap level of this texture.
                pub fn main_level(&self) -> SrgbTexture2dMultisampleMipmap {
                    self.mipmap(0).unwrap()
                }
            }

                    /// Represents a single mipmap level of a `SrgbTexture2dMultisample`.
                    ///
                    /// Can be obtained by calling `SrgbTexture2dMultisample::mipmap()` or `SrgbTexture2dMultisample::main_level()`.
                    #[derive(Copy, Clone)]
                    pub struct SrgbTexture2dMultisampleMipmap<'t>(TextureAnyMipmap<'t>, &'t SrgbTexture2dMultisample);
                impl<'t> SrgbTexture2dMultisampleMipmap<'t> {

                /// Returns the corresponding texture.
                pub fn get_texture(&self) -> &'t SrgbTexture2dMultisample {
                    self.1
                }

                /// Returns the texture level.
                pub fn get_level(&self) -> u32 {
                    self.0.get_level()
                }
            }
/// A two-dimensional texture  containing unsigned integral data.
pub struct UnsignedTexture2dMultisample(TextureAny);

                impl Texture for UnsignedTexture2dMultisample {
                    fn get_width(&self) -> u32 {
                        self.0.get_width()
                    }

                    fn get_height(&self) -> Option<u32> {
                        self.0.get_height()
                    }

                    fn get_depth(&self) -> Option<u32> {
                        self.0.get_depth()
                    }

                    fn get_array_size(&self) -> Option<u32> {
                        self.0.get_array_size()
                    }
                }
            

                impl GlObject for UnsignedTexture2dMultisample {
                    type Id = gl::types::GLuint;
                    fn get_id(&self) -> gl::types::GLuint {
                        self.0.get_id()
                    }
                }
            

                impl ::std::fmt::Debug for UnsignedTexture2dMultisample {
                    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> Result<(), ::std::fmt::Error>
                    {
                        self.0.fmt(f)
                    }
                }
            

                impl ::std::ops::Deref for UnsignedTexture2dMultisample {
                    type Target = TextureAny;
                    
                    fn deref<'a>(&'a self) -> &'a TextureAny {
                        &self.0
                    }
                }
            

                            impl<'a> AsUniformValue for &'a UnsignedTexture2dMultisample {
                                fn as_uniform_value(&self) -> UniformValue {
                                    UniformValue::UnsignedTexture2dMultisample(*self, None)
                                }
                            }

                            impl<'a> AsUniformValue for Sampler<'a, UnsignedTexture2dMultisample> {
                                fn as_uniform_value(&self) -> UniformValue {
                                    UniformValue::UnsignedTexture2dMultisample(self.0, Some(self.1))
                                }
                            }

                            impl UnsignedTexture2dMultisample {
                                /// Builds a `Sampler` marker object that allows you to indicate
                                /// how the texture should be sampled from inside a shader.
                                ///
                                /// # Example
                                ///
                                /// ```no_run
                                /// # #[macro_use] extern crate glium;
                                /// # fn main() {
                                /// # let texture: glium::texture::Texture2d = unsafe {
                                /// # ::std::mem::uninitialized() };
                                /// let uniforms = uniform! {
                                ///     color_texture: texture.sampled().magnify_filter(glium::uniforms::MagnifySamplerFilter::Nearest)
                                /// };
                                /// # }
                                /// ```
                                pub fn sampled(&self) -> Sampler<UnsignedTexture2dMultisample> {
                                    Sampler(self, Default::default())
                                }
                            }
                        
impl UnsignedTexture2dMultisample {

            /// Determines the internal format of this texture.
            ///
            /// The backend may not support querying the actual format, in which case an error
            /// is returned.
            pub fn get_internal_format(&self) -> Result<InternalFormat, GetFormatError> {
                self.0.get_internal_format()
            }
        

                /// Creates an empty texture.
                ///
                /// No mipmap level (except for the main level) will be allocated or generated.
                ///
                /// The texture will contain undefined data.
                pub fn empty<F>(facade: &F, width: u32, height: u32, samples: u32)
                                -> Result<UnsignedTexture2dMultisample, TextureCreationError>
                                where F: Facade
                {
                    let format = TextureFormatRequest::AnyUnsigned;
            
any::new_texture::<_, u8>(facade, format, None, MipmapsOption::NoMipmap.to_regular(), Dimensions::Texture2dMultisample { width: width, height: height, samples: samples }).map(|t| UnsignedTexture2dMultisample(t))}

                /// Creates an empty texture with a specific format.
                ///
                /// The texture (and its mipmaps) will contain undefined data.
                pub fn empty_with_format<F>(facade: &F, format: UncompressedUintFormat, mipmaps: MipmapsOption, width: u32, height: u32, samples: u32) -> Result<UnsignedTexture2dMultisample, TextureCreationError> where F: Facade {
                    let format = format.to_texture_format();
                    let format = TextureFormatRequest::Specific(format);
            
let t = any::new_texture::<_, u8>(facade, format, None, mipmaps.to_regular(), Dimensions::Texture2dMultisample { width: width, height: height, samples: samples });
            t.map(|t| UnsignedTexture2dMultisample(t))
}

                /// Creates an empty texture. Specifies whether is has mipmaps.
                ///
                /// The texture (and its mipmaps) will contain undefined data.
                pub fn empty_with_mipmaps<F>(facade: &F, mipmaps: MipmapsOption, width: u32, height: u32, samples: u32) -> Result<UnsignedTexture2dMultisample, TextureCreationError> where F: Facade {
                    let format = TextureFormatRequest::AnyUnsigned;
            
any::new_texture::<_, u8>(facade, format, None, mipmaps.to_regular(), Dimensions::Texture2dMultisample { width: width, height: height, samples: samples }).map(|t| UnsignedTexture2dMultisample(t))
}

            /// Returns the number of mipmap levels of the texture.
            ///
            /// The minimum value is 1, since there is always a main texture.
            pub fn get_mipmap_levels(&self) -> u32 {
                self.0.get_mipmap_levels()
            }
        
            /// Turns the texture into a `ResidentTexture`.
            ///
            /// This allows you to use the texture in a much more efficient way by storing
            /// a "reference to it" in a buffer (actually not a reference but a raw pointer).
            ///
            /// See the documentation of `ResidentTexture` for more infos.
            pub fn resident(self) -> Result<ResidentTexture, BindlessTexturesNotSupportedError> {
                ResidentTexture::new(self.0)
            }
        
                /// Access a single mipmap level of this texture.
                pub fn mipmap(&self, level: u32) -> Option<UnsignedTexture2dMultisampleMipmap> {
                    self.0.mipmap(0, level).map(|m| UnsignedTexture2dMultisampleMipmap(m, self))
                }
            
                /// Access the main mipmap level of this texture.
                pub fn main_level(&self) -> UnsignedTexture2dMultisampleMipmap {
                    self.mipmap(0).unwrap()
                }
            }

                    /// Represents a single mipmap level of a `UnsignedTexture2dMultisample`.
                    ///
                    /// Can be obtained by calling `UnsignedTexture2dMultisample::mipmap()` or `UnsignedTexture2dMultisample::main_level()`.
                    #[derive(Copy, Clone)]
                    pub struct UnsignedTexture2dMultisampleMipmap<'t>(TextureAnyMipmap<'t>, &'t UnsignedTexture2dMultisample);
                impl<'t> UnsignedTexture2dMultisampleMipmap<'t> {

                /// Returns the corresponding texture.
                pub fn get_texture(&self) -> &'t UnsignedTexture2dMultisample {
                    self.1
                }

                /// Returns the texture level.
                pub fn get_level(&self) -> u32 {
                    self.0.get_level()
                }
            }
/// A two-dimensional texture  containing depth data.
pub struct DepthTexture2dMultisample(TextureAny);

                impl Texture for DepthTexture2dMultisample {
                    fn get_width(&self) -> u32 {
                        self.0.get_width()
                    }

                    fn get_height(&self) -> Option<u32> {
                        self.0.get_height()
                    }

                    fn get_depth(&self) -> Option<u32> {
                        self.0.get_depth()
                    }

                    fn get_array_size(&self) -> Option<u32> {
                        self.0.get_array_size()
                    }
                }
            

                impl GlObject for DepthTexture2dMultisample {
                    type Id = gl::types::GLuint;
                    fn get_id(&self) -> gl::types::GLuint {
                        self.0.get_id()
                    }
                }
            

                impl ::std::fmt::Debug for DepthTexture2dMultisample {
                    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> Result<(), ::std::fmt::Error>
                    {
                        self.0.fmt(f)
                    }
                }
            

                impl ::std::ops::Deref for DepthTexture2dMultisample {
                    type Target = TextureAny;
                    
                    fn deref<'a>(&'a self) -> &'a TextureAny {
                        &self.0
                    }
                }
            

                            impl<'a> AsUniformValue for &'a DepthTexture2dMultisample {
                                fn as_uniform_value(&self) -> UniformValue {
                                    UniformValue::DepthTexture2dMultisample(*self, None)
                                }
                            }

                            impl<'a> AsUniformValue for Sampler<'a, DepthTexture2dMultisample> {
                                fn as_uniform_value(&self) -> UniformValue {
                                    UniformValue::DepthTexture2dMultisample(self.0, Some(self.1))
                                }
                            }

                            impl DepthTexture2dMultisample {
                                /// Builds a `Sampler` marker object that allows you to indicate
                                /// how the texture should be sampled from inside a shader.
                                ///
                                /// # Example
                                ///
                                /// ```no_run
                                /// # #[macro_use] extern crate glium;
                                /// # fn main() {
                                /// # let texture: glium::texture::Texture2d = unsafe {
                                /// # ::std::mem::uninitialized() };
                                /// let uniforms = uniform! {
                                ///     color_texture: texture.sampled().magnify_filter(glium::uniforms::MagnifySamplerFilter::Nearest)
                                /// };
                                /// # }
                                /// ```
                                pub fn sampled(&self) -> Sampler<DepthTexture2dMultisample> {
                                    Sampler(self, Default::default())
                                }
                            }
                        

                        impl ::framebuffer::ToDepthAttachment for DepthTexture2dMultisample {
                            fn to_depth_attachment(&self) -> ::framebuffer::DepthAttachment {
                                ::framebuffer::DepthAttachment::Texture(self.0.mipmap(0, 0).unwrap())
                            }
                        }
                    
impl DepthTexture2dMultisample {

            /// Determines the internal format of this texture.
            ///
            /// The backend may not support querying the actual format, in which case an error
            /// is returned.
            pub fn get_internal_format(&self) -> Result<InternalFormat, GetFormatError> {
                self.0.get_internal_format()
            }
        

                /// Creates an empty texture.
                ///
                /// No mipmap level (except for the main level) will be allocated or generated.
                ///
                /// The texture will contain undefined data.
                pub fn empty<F>(facade: &F, width: u32, height: u32, samples: u32)
                                -> Result<DepthTexture2dMultisample, TextureCreationError>
                                where F: Facade
                {
                    let format = TextureFormatRequest::AnyDepth;
            
any::new_texture::<_, u8>(facade, format, None, MipmapsOption::NoMipmap.to_regular(), Dimensions::Texture2dMultisample { width: width, height: height, samples: samples }).map(|t| DepthTexture2dMultisample(t))}

                /// Creates an empty texture with a specific format.
                ///
                /// The texture (and its mipmaps) will contain undefined data.
                pub fn empty_with_format<F>(facade: &F, format: DepthFormat, mipmaps: MipmapsOption, width: u32, height: u32, samples: u32) -> Result<DepthTexture2dMultisample, TextureCreationError> where F: Facade {
                    let format = format.to_texture_format();
                    let format = TextureFormatRequest::Specific(format);
            
let t = any::new_texture::<_, u8>(facade, format, None, mipmaps.to_regular(), Dimensions::Texture2dMultisample { width: width, height: height, samples: samples });
            t.map(|t| DepthTexture2dMultisample(t))
}

                /// Creates an empty texture. Specifies whether is has mipmaps.
                ///
                /// The texture (and its mipmaps) will contain undefined data.
                pub fn empty_with_mipmaps<F>(facade: &F, mipmaps: MipmapsOption, width: u32, height: u32, samples: u32) -> Result<DepthTexture2dMultisample, TextureCreationError> where F: Facade {
                    let format = TextureFormatRequest::AnyDepth;
            
any::new_texture::<_, u8>(facade, format, None, mipmaps.to_regular(), Dimensions::Texture2dMultisample { width: width, height: height, samples: samples }).map(|t| DepthTexture2dMultisample(t))
}

            /// Returns the number of mipmap levels of the texture.
            ///
            /// The minimum value is 1, since there is always a main texture.
            pub fn get_mipmap_levels(&self) -> u32 {
                self.0.get_mipmap_levels()
            }
        
            /// Turns the texture into a `ResidentTexture`.
            ///
            /// This allows you to use the texture in a much more efficient way by storing
            /// a "reference to it" in a buffer (actually not a reference but a raw pointer).
            ///
            /// See the documentation of `ResidentTexture` for more infos.
            pub fn resident(self) -> Result<ResidentTexture, BindlessTexturesNotSupportedError> {
                ResidentTexture::new(self.0)
            }
        
                /// Access a single mipmap level of this texture.
                pub fn mipmap(&self, level: u32) -> Option<DepthTexture2dMultisampleMipmap> {
                    self.0.mipmap(0, level).map(|m| DepthTexture2dMultisampleMipmap(m, self))
                }
            
                /// Access the main mipmap level of this texture.
                pub fn main_level(&self) -> DepthTexture2dMultisampleMipmap {
                    self.mipmap(0).unwrap()
                }
            }

                    /// Represents a single mipmap level of a `DepthTexture2dMultisample`.
                    ///
                    /// Can be obtained by calling `DepthTexture2dMultisample::mipmap()` or `DepthTexture2dMultisample::main_level()`.
                    #[derive(Copy, Clone)]
                    pub struct DepthTexture2dMultisampleMipmap<'t>(TextureAnyMipmap<'t>, &'t DepthTexture2dMultisample);
                impl<'t> DepthTexture2dMultisampleMipmap<'t> {

                /// Returns the corresponding texture.
                pub fn get_texture(&self) -> &'t DepthTexture2dMultisample {
                    self.1
                }

                /// Returns the texture level.
                pub fn get_level(&self) -> u32 {
                    self.0.get_level()
                }
            }
/// A two-dimensional texture  containing stencil data.
pub struct StencilTexture2dMultisample(TextureAny);

                impl Texture for StencilTexture2dMultisample {
                    fn get_width(&self) -> u32 {
                        self.0.get_width()
                    }

                    fn get_height(&self) -> Option<u32> {
                        self.0.get_height()
                    }

                    fn get_depth(&self) -> Option<u32> {
                        self.0.get_depth()
                    }

                    fn get_array_size(&self) -> Option<u32> {
                        self.0.get_array_size()
                    }
                }
            

                impl GlObject for StencilTexture2dMultisample {
                    type Id = gl::types::GLuint;
                    fn get_id(&self) -> gl::types::GLuint {
                        self.0.get_id()
                    }
                }
            

                impl ::std::fmt::Debug for StencilTexture2dMultisample {
                    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> Result<(), ::std::fmt::Error>
                    {
                        self.0.fmt(f)
                    }
                }
            

                impl ::std::ops::Deref for StencilTexture2dMultisample {
                    type Target = TextureAny;
                    
                    fn deref<'a>(&'a self) -> &'a TextureAny {
                        &self.0
                    }
                }
            

                        impl ::framebuffer::ToStencilAttachment for StencilTexture2dMultisample {
                            fn to_stencil_attachment(&self) -> ::framebuffer::StencilAttachment {
                                ::framebuffer::StencilAttachment::Texture(self.0.mipmap(0, 0).unwrap())
                            }
                        }
                    
impl StencilTexture2dMultisample {

            /// Determines the internal format of this texture.
            ///
            /// The backend may not support querying the actual format, in which case an error
            /// is returned.
            pub fn get_internal_format(&self) -> Result<InternalFormat, GetFormatError> {
                self.0.get_internal_format()
            }
        

                /// Creates an empty texture.
                ///
                /// No mipmap level (except for the main level) will be allocated or generated.
                ///
                /// The texture will contain undefined data.
                pub fn empty<F>(facade: &F, width: u32, height: u32, samples: u32)
                                -> Result<StencilTexture2dMultisample, TextureCreationError>
                                where F: Facade
                {
                    let format = TextureFormatRequest::AnyStencil;
            
any::new_texture::<_, u8>(facade, format, None, MipmapsOption::NoMipmap.to_regular(), Dimensions::Texture2dMultisample { width: width, height: height, samples: samples }).map(|t| StencilTexture2dMultisample(t))}

                /// Creates an empty texture with a specific format.
                ///
                /// The texture (and its mipmaps) will contain undefined data.
                pub fn empty_with_format<F>(facade: &F, format: StencilFormat, mipmaps: MipmapsOption, width: u32, height: u32, samples: u32) -> Result<StencilTexture2dMultisample, TextureCreationError> where F: Facade {
                    let format = format.to_texture_format();
                    let format = TextureFormatRequest::Specific(format);
            
let t = any::new_texture::<_, u8>(facade, format, None, mipmaps.to_regular(), Dimensions::Texture2dMultisample { width: width, height: height, samples: samples });
            t.map(|t| StencilTexture2dMultisample(t))
}

                /// Creates an empty texture. Specifies whether is has mipmaps.
                ///
                /// The texture (and its mipmaps) will contain undefined data.
                pub fn empty_with_mipmaps<F>(facade: &F, mipmaps: MipmapsOption, width: u32, height: u32, samples: u32) -> Result<StencilTexture2dMultisample, TextureCreationError> where F: Facade {
                    let format = TextureFormatRequest::AnyStencil;
            
any::new_texture::<_, u8>(facade, format, None, mipmaps.to_regular(), Dimensions::Texture2dMultisample { width: width, height: height, samples: samples }).map(|t| StencilTexture2dMultisample(t))
}

            /// Returns the number of mipmap levels of the texture.
            ///
            /// The minimum value is 1, since there is always a main texture.
            pub fn get_mipmap_levels(&self) -> u32 {
                self.0.get_mipmap_levels()
            }
        
            /// Turns the texture into a `ResidentTexture`.
            ///
            /// This allows you to use the texture in a much more efficient way by storing
            /// a "reference to it" in a buffer (actually not a reference but a raw pointer).
            ///
            /// See the documentation of `ResidentTexture` for more infos.
            pub fn resident(self) -> Result<ResidentTexture, BindlessTexturesNotSupportedError> {
                ResidentTexture::new(self.0)
            }
        
                /// Access a single mipmap level of this texture.
                pub fn mipmap(&self, level: u32) -> Option<StencilTexture2dMultisampleMipmap> {
                    self.0.mipmap(0, level).map(|m| StencilTexture2dMultisampleMipmap(m, self))
                }
            
                /// Access the main mipmap level of this texture.
                pub fn main_level(&self) -> StencilTexture2dMultisampleMipmap {
                    self.mipmap(0).unwrap()
                }
            }

                    /// Represents a single mipmap level of a `StencilTexture2dMultisample`.
                    ///
                    /// Can be obtained by calling `StencilTexture2dMultisample::mipmap()` or `StencilTexture2dMultisample::main_level()`.
                    #[derive(Copy, Clone)]
                    pub struct StencilTexture2dMultisampleMipmap<'t>(TextureAnyMipmap<'t>, &'t StencilTexture2dMultisample);
                impl<'t> StencilTexture2dMultisampleMipmap<'t> {

                /// Returns the corresponding texture.
                pub fn get_texture(&self) -> &'t StencilTexture2dMultisample {
                    self.1
                }

                /// Returns the texture level.
                pub fn get_level(&self) -> u32 {
                    self.0.get_level()
                }
            }
/// A two-dimensional texture  containing both depth and stencil data.
pub struct DepthStencilTexture2dMultisample(TextureAny);

                impl Texture for DepthStencilTexture2dMultisample {
                    fn get_width(&self) -> u32 {
                        self.0.get_width()
                    }

                    fn get_height(&self) -> Option<u32> {
                        self.0.get_height()
                    }

                    fn get_depth(&self) -> Option<u32> {
                        self.0.get_depth()
                    }

                    fn get_array_size(&self) -> Option<u32> {
                        self.0.get_array_size()
                    }
                }
            

                impl GlObject for DepthStencilTexture2dMultisample {
                    type Id = gl::types::GLuint;
                    fn get_id(&self) -> gl::types::GLuint {
                        self.0.get_id()
                    }
                }
            

                impl ::std::fmt::Debug for DepthStencilTexture2dMultisample {
                    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> Result<(), ::std::fmt::Error>
                    {
                        self.0.fmt(f)
                    }
                }
            

                impl ::std::ops::Deref for DepthStencilTexture2dMultisample {
                    type Target = TextureAny;
                    
                    fn deref<'a>(&'a self) -> &'a TextureAny {
                        &self.0
                    }
                }
            

                        impl ::framebuffer::ToDepthStencilAttachment for DepthStencilTexture2dMultisample {
                            fn to_depth_stencil_attachment(&self) -> ::framebuffer::DepthStencilAttachment {
                                ::framebuffer::DepthStencilAttachment::Texture(self.0.mipmap(0, 0).unwrap())
                            }
                        }
                    
impl DepthStencilTexture2dMultisample {

            /// Determines the internal format of this texture.
            ///
            /// The backend may not support querying the actual format, in which case an error
            /// is returned.
            pub fn get_internal_format(&self) -> Result<InternalFormat, GetFormatError> {
                self.0.get_internal_format()
            }
        

                /// Creates an empty texture.
                ///
                /// No mipmap level (except for the main level) will be allocated or generated.
                ///
                /// The texture will contain undefined data.
                pub fn empty<F>(facade: &F, width: u32, height: u32, samples: u32)
                                -> Result<DepthStencilTexture2dMultisample, TextureCreationError>
                                where F: Facade
                {
                    let format = TextureFormatRequest::AnyDepthStencil;
            
any::new_texture::<_, u8>(facade, format, None, MipmapsOption::NoMipmap.to_regular(), Dimensions::Texture2dMultisample { width: width, height: height, samples: samples }).map(|t| DepthStencilTexture2dMultisample(t))}

                /// Creates an empty texture with a specific format.
                ///
                /// The texture (and its mipmaps) will contain undefined data.
                pub fn empty_with_format<F>(facade: &F, format: DepthStencilFormat, mipmaps: MipmapsOption, width: u32, height: u32, samples: u32) -> Result<DepthStencilTexture2dMultisample, TextureCreationError> where F: Facade {
                    let format = format.to_texture_format();
                    let format = TextureFormatRequest::Specific(format);
            
let t = any::new_texture::<_, u8>(facade, format, None, mipmaps.to_regular(), Dimensions::Texture2dMultisample { width: width, height: height, samples: samples });
            t.map(|t| DepthStencilTexture2dMultisample(t))
}

                /// Creates an empty texture. Specifies whether is has mipmaps.
                ///
                /// The texture (and its mipmaps) will contain undefined data.
                pub fn empty_with_mipmaps<F>(facade: &F, mipmaps: MipmapsOption, width: u32, height: u32, samples: u32) -> Result<DepthStencilTexture2dMultisample, TextureCreationError> where F: Facade {
                    let format = TextureFormatRequest::AnyDepthStencil;
            
any::new_texture::<_, u8>(facade, format, None, mipmaps.to_regular(), Dimensions::Texture2dMultisample { width: width, height: height, samples: samples }).map(|t| DepthStencilTexture2dMultisample(t))
}

            /// Returns the number of mipmap levels of the texture.
            ///
            /// The minimum value is 1, since there is always a main texture.
            pub fn get_mipmap_levels(&self) -> u32 {
                self.0.get_mipmap_levels()
            }
        
            /// Turns the texture into a `ResidentTexture`.
            ///
            /// This allows you to use the texture in a much more efficient way by storing
            /// a "reference to it" in a buffer (actually not a reference but a raw pointer).
            ///
            /// See the documentation of `ResidentTexture` for more infos.
            pub fn resident(self) -> Result<ResidentTexture, BindlessTexturesNotSupportedError> {
                ResidentTexture::new(self.0)
            }
        
                /// Access a single mipmap level of this texture.
                pub fn mipmap(&self, level: u32) -> Option<DepthStencilTexture2dMultisampleMipmap> {
                    self.0.mipmap(0, level).map(|m| DepthStencilTexture2dMultisampleMipmap(m, self))
                }
            
                /// Access the main mipmap level of this texture.
                pub fn main_level(&self) -> DepthStencilTexture2dMultisampleMipmap {
                    self.mipmap(0).unwrap()
                }
            }

                    /// Represents a single mipmap level of a `DepthStencilTexture2dMultisample`.
                    ///
                    /// Can be obtained by calling `DepthStencilTexture2dMultisample::mipmap()` or `DepthStencilTexture2dMultisample::main_level()`.
                    #[derive(Copy, Clone)]
                    pub struct DepthStencilTexture2dMultisampleMipmap<'t>(TextureAnyMipmap<'t>, &'t DepthStencilTexture2dMultisample);
                impl<'t> DepthStencilTexture2dMultisampleMipmap<'t> {

                /// Returns the corresponding texture.
                pub fn get_texture(&self) -> &'t DepthStencilTexture2dMultisample {
                    self.1
                }

                /// Returns the texture level.
                pub fn get_level(&self) -> u32 {
                    self.0.get_level()
                }
            }
/// A three-dimensional texture  containing floating-point data.
pub struct Texture3d(TextureAny);

                impl Texture for Texture3d {
                    fn get_width(&self) -> u32 {
                        self.0.get_width()
                    }

                    fn get_height(&self) -> Option<u32> {
                        self.0.get_height()
                    }

                    fn get_depth(&self) -> Option<u32> {
                        self.0.get_depth()
                    }

                    fn get_array_size(&self) -> Option<u32> {
                        self.0.get_array_size()
                    }
                }
            

                impl GlObject for Texture3d {
                    type Id = gl::types::GLuint;
                    fn get_id(&self) -> gl::types::GLuint {
                        self.0.get_id()
                    }
                }
            

                impl ::std::fmt::Debug for Texture3d {
                    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> Result<(), ::std::fmt::Error>
                    {
                        self.0.fmt(f)
                    }
                }
            

                impl ::std::ops::Deref for Texture3d {
                    type Target = TextureAny;
                    
                    fn deref<'a>(&'a self) -> &'a TextureAny {
                        &self.0
                    }
                }
            

                            impl<'a> AsUniformValue for &'a Texture3d {
                                fn as_uniform_value(&self) -> UniformValue {
                                    UniformValue::Texture3d(*self, None)
                                }
                            }

                            impl<'a> AsUniformValue for Sampler<'a, Texture3d> {
                                fn as_uniform_value(&self) -> UniformValue {
                                    UniformValue::Texture3d(self.0, Some(self.1))
                                }
                            }

                            impl Texture3d {
                                /// Builds a `Sampler` marker object that allows you to indicate
                                /// how the texture should be sampled from inside a shader.
                                ///
                                /// # Example
                                ///
                                /// ```no_run
                                /// # #[macro_use] extern crate glium;
                                /// # fn main() {
                                /// # let texture: glium::texture::Texture2d = unsafe {
                                /// # ::std::mem::uninitialized() };
                                /// let uniforms = uniform! {
                                ///     color_texture: texture.sampled().magnify_filter(glium::uniforms::MagnifySamplerFilter::Nearest)
                                /// };
                                /// # }
                                /// ```
                                pub fn sampled(&self) -> Sampler<Texture3d> {
                                    Sampler(self, Default::default())
                                }
                            }
                        
impl Texture3d {

            /// Determines the internal format of this texture.
            ///
            /// The backend may not support querying the actual format, in which case an error
            /// is returned.
            pub fn get_internal_format(&self) -> Result<InternalFormat, GetFormatError> {
                self.0.get_internal_format()
            }
        

                /// Builds a new texture by uploading data.
                ///
                /// This function will automatically generate all mipmaps of the texture.
                pub fn new<'a, F, T>(facade: &F, data: T)
                              -> Result<Texture3d, TextureCreationError>
                              where T: Texture3dDataSource<'a>, F: Facade
                {
                    Texture3d::new_impl(facade, data, None, MipmapsOption::AutoGeneratedMipmaps)
                }
            

                /// Builds a new texture by uploading data.
                pub fn with_mipmaps<'a, F, T>(facade: &F, data: T, mipmaps: MipmapsOption)
                                              -> Result<Texture3d, TextureCreationError>
                                              where T: Texture3dDataSource<'a>, F: Facade
                {
                    Texture3d::new_impl(facade, data, None, mipmaps)
                }
            

                /// Builds a new texture with a specific format.
                pub fn with_format<'a, F, T>(facade: &F, data: T,
                                          format: UncompressedFloatFormat, mipmaps: MipmapsOption)
                                          -> Result<Texture3d, TextureCreationError>
                                          where T: Texture3dDataSource<'a>, F: Facade
                {
                    Texture3d::new_impl(facade, data, Some(format), mipmaps)
                }
            

                fn new_impl<'a, F, T>(facade: &F, data: T,
                                   format: Option<UncompressedFloatFormat>, mipmaps: MipmapsOption)
                                   -> Result<Texture3d, TextureCreationError>
                                   where T: Texture3dDataSource<'a>, F: Facade
                {
            
let format = format.map(|f| {
                           TextureFormatRequest::Specific(f.to_texture_format())
                       }).unwrap_or(TextureFormatRequest::AnyFloatingPoint);
                    let RawImage3d { data, width, height, depth, format: client_format } =
                                            data.into_raw();
                let client_format = ClientFormatAny::ClientFormat(client_format);Ok(Texture3d(try!(any::new_texture(facade, format, Some((client_format, data)), mipmaps.to_regular(), Dimensions::Texture3d { width: width, height: height, depth: depth }))))
}

                /// Creates an empty texture.
                ///
                /// No mipmap level (except for the main level) will be allocated or generated.
                ///
                /// The texture will contain undefined data.
                pub fn empty<F>(facade: &F, width: u32, height: u32, depth: u32)
                                -> Result<Texture3d, TextureCreationError>
                                where F: Facade
                {
                    let format = TextureFormatRequest::AnyFloatingPoint;
            
any::new_texture::<_, u8>(facade, format, None, MipmapsOption::NoMipmap.to_regular(), Dimensions::Texture3d { width: width, height: height, depth: depth }).map(|t| Texture3d(t))}

                /// Creates an empty texture with a specific format.
                ///
                /// The texture (and its mipmaps) will contain undefined data.
                pub fn empty_with_format<F>(facade: &F, format: UncompressedFloatFormat, mipmaps: MipmapsOption, width: u32, height: u32, depth: u32) -> Result<Texture3d, TextureCreationError> where F: Facade {
                    let format = format.to_texture_format();
                    let format = TextureFormatRequest::Specific(format);
            
let t = any::new_texture::<_, u8>(facade, format, None, mipmaps.to_regular(), Dimensions::Texture3d { width: width, height: height, depth: depth });
            t.map(|t| Texture3d(t))
}

                /// Creates an empty texture. Specifies whether is has mipmaps.
                ///
                /// The texture (and its mipmaps) will contain undefined data.
                pub fn empty_with_mipmaps<F>(facade: &F, mipmaps: MipmapsOption, width: u32, height: u32, depth: u32) -> Result<Texture3d, TextureCreationError> where F: Facade {
                    let format = TextureFormatRequest::AnyFloatingPoint;
            
any::new_texture::<_, u8>(facade, format, None, mipmaps.to_regular(), Dimensions::Texture3d { width: width, height: height, depth: depth }).map(|t| Texture3d(t))
}

            /// Returns the number of mipmap levels of the texture.
            ///
            /// The minimum value is 1, since there is always a main texture.
            pub fn get_mipmap_levels(&self) -> u32 {
                self.0.get_mipmap_levels()
            }
        
            /// Turns the texture into a `ResidentTexture`.
            ///
            /// This allows you to use the texture in a much more efficient way by storing
            /// a "reference to it" in a buffer (actually not a reference but a raw pointer).
            ///
            /// See the documentation of `ResidentTexture` for more infos.
            pub fn resident(self) -> Result<ResidentTexture, BindlessTexturesNotSupportedError> {
                ResidentTexture::new(self.0)
            }
        
                /// Access a single mipmap level of this texture.
                pub fn mipmap(&self, level: u32) -> Option<Texture3dMipmap> {
                    self.0.mipmap(0, level).map(|m| Texture3dMipmap(m, self))
                }
            
                /// Access the main mipmap level of this texture.
                pub fn main_level(&self) -> Texture3dMipmap {
                    self.mipmap(0).unwrap()
                }
            }

                    /// Represents a single mipmap level of a `Texture3d`.
                    ///
                    /// Can be obtained by calling `Texture3d::mipmap()` or `Texture3d::main_level()`.
                    #[derive(Copy, Clone)]
                    pub struct Texture3dMipmap<'t>(TextureAnyMipmap<'t>, &'t Texture3d);
                impl<'t> Texture3dMipmap<'t> {

                /// Returns the corresponding texture.
                pub fn get_texture(&self) -> &'t Texture3d {
                    self.1
                }

                /// Returns the texture level.
                pub fn get_level(&self) -> u32 {
                    self.0.get_level()
                }
            }
/// A compressed three-dimensional texture  containing floating-point data.
pub struct CompressedTexture3d(TextureAny);

                impl Texture for CompressedTexture3d {
                    fn get_width(&self) -> u32 {
                        self.0.get_width()
                    }

                    fn get_height(&self) -> Option<u32> {
                        self.0.get_height()
                    }

                    fn get_depth(&self) -> Option<u32> {
                        self.0.get_depth()
                    }

                    fn get_array_size(&self) -> Option<u32> {
                        self.0.get_array_size()
                    }
                }
            

                impl GlObject for CompressedTexture3d {
                    type Id = gl::types::GLuint;
                    fn get_id(&self) -> gl::types::GLuint {
                        self.0.get_id()
                    }
                }
            

                impl ::std::fmt::Debug for CompressedTexture3d {
                    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> Result<(), ::std::fmt::Error>
                    {
                        self.0.fmt(f)
                    }
                }
            

                impl ::std::ops::Deref for CompressedTexture3d {
                    type Target = TextureAny;
                    
                    fn deref<'a>(&'a self) -> &'a TextureAny {
                        &self.0
                    }
                }
            

                            impl<'a> AsUniformValue for &'a CompressedTexture3d {
                                fn as_uniform_value(&self) -> UniformValue {
                                    UniformValue::CompressedTexture3d(*self, None)
                                }
                            }

                            impl<'a> AsUniformValue for Sampler<'a, CompressedTexture3d> {
                                fn as_uniform_value(&self) -> UniformValue {
                                    UniformValue::CompressedTexture3d(self.0, Some(self.1))
                                }
                            }

                            impl CompressedTexture3d {
                                /// Builds a `Sampler` marker object that allows you to indicate
                                /// how the texture should be sampled from inside a shader.
                                ///
                                /// # Example
                                ///
                                /// ```no_run
                                /// # #[macro_use] extern crate glium;
                                /// # fn main() {
                                /// # let texture: glium::texture::Texture2d = unsafe {
                                /// # ::std::mem::uninitialized() };
                                /// let uniforms = uniform! {
                                ///     color_texture: texture.sampled().magnify_filter(glium::uniforms::MagnifySamplerFilter::Nearest)
                                /// };
                                /// # }
                                /// ```
                                pub fn sampled(&self) -> Sampler<CompressedTexture3d> {
                                    Sampler(self, Default::default())
                                }
                            }
                        
impl CompressedTexture3d {

            /// Determines the internal format of this texture.
            ///
            /// The backend may not support querying the actual format, in which case an error
            /// is returned.
            pub fn get_internal_format(&self) -> Result<InternalFormat, GetFormatError> {
                self.0.get_internal_format()
            }
        

                /// Builds a new texture by uploading data.
                ///
                /// No mipmap level (except for the main level) will be allocator nor generated.
                pub fn new<'a, F, T>(facade: &F, data: T)
                              -> Result<CompressedTexture3d, TextureCreationError>
                              where T: Texture3dDataSource<'a>, F: Facade
                {
                    CompressedTexture3d::new_impl(facade, data, None, CompressedMipmapsOption::NoMipmap)
                }
            

                /// Builds a new texture by uploading data.
                pub fn with_mipmaps<'a, F, T>(facade: &F, data: T, mipmaps: CompressedMipmapsOption)
                                              -> Result<CompressedTexture3d, TextureCreationError>
                                              where T: Texture3dDataSource<'a>, F: Facade
                {
                    CompressedTexture3d::new_impl(facade, data, None, mipmaps)
                }
            

                /// Builds a new texture with a specific format. The input data must also be of the
                /// specified compressed format.
                pub fn with_compressed_data<F>(facade: &F, data: &[u8], width: u32, height: u32, depth: u32,
                                                      format: CompressedFormat, mipmaps: CompressedMipmapsOption)
                                                      -> Result<CompressedTexture3d, TextureCreationError>
                                                       where F: Facade
                {
                    let data = Cow::Borrowed(data.as_ref());
                    let client_format = ClientFormatAny::CompressedFormat(format);
                    Ok(CompressedTexture3d(try!(any::new_texture(facade, TextureFormatRequest::AnyCompressed, Some((client_format, data)),
                                                    mipmaps.to_regular(), Dimensions::Texture3d { width: width, height: height, depth: depth }))))
                }
            

                /// Builds a new texture with a specific format.
                pub fn with_format<'a, F, T>(facade: &F, data: T,
                                          format: CompressedFormat, mipmaps: CompressedMipmapsOption)
                                          -> Result<CompressedTexture3d, TextureCreationError>
                                          where T: Texture3dDataSource<'a>, F: Facade
                {
                    CompressedTexture3d::new_impl(facade, data, Some(format), mipmaps)
                }
            

                fn new_impl<'a, F, T>(facade: &F, data: T,
                                   format: Option<CompressedFormat>, mipmaps: CompressedMipmapsOption)
                                   -> Result<CompressedTexture3d, TextureCreationError>
                                   where T: Texture3dDataSource<'a>, F: Facade
                {
            
let format = format.map(|f| {
                           TextureFormatRequest::Specific(f.to_texture_format())
                       }).unwrap_or(TextureFormatRequest::AnyCompressed);
                    let RawImage3d { data, width, height, depth, format: client_format } =
                                            data.into_raw();
                let client_format = ClientFormatAny::ClientFormat(client_format);Ok(CompressedTexture3d(try!(any::new_texture(facade, format, Some((client_format, data)), mipmaps.to_regular(), Dimensions::Texture3d { width: width, height: height, depth: depth }))))
}

                /// Creates an empty texture with a specific format.
                ///
                /// The texture (and its mipmaps) will contain undefined data.
                pub fn empty_with_format<F>(facade: &F, format: CompressedFormat, mipmaps: CompressedMipmapsOption, width: u32, height: u32, depth: u32) -> Result<CompressedTexture3d, TextureCreationError> where F: Facade {
                    let format = format.to_texture_format();
                    let format = TextureFormatRequest::Specific(format);
            
let t = any::new_texture::<_, u8>(facade, format, None, mipmaps.to_regular(), Dimensions::Texture3d { width: width, height: height, depth: depth });
            t.map(|t| CompressedTexture3d(t))
}

            /// Returns the number of mipmap levels of the texture.
            ///
            /// The minimum value is 1, since there is always a main texture.
            pub fn get_mipmap_levels(&self) -> u32 {
                self.0.get_mipmap_levels()
            }
        
                /// Reads the content of the texture to RAM without decompressing it before.
                ///
                /// You should avoid doing this at all cost during performance-critical
                /// operations (for example, while you're drawing).
                ///
                /// Returns the compressed format of the texture and the compressed data, gives
                /// `None` when the internal compression format is generic or unknown.
                pub fn read_compressed_data(&self) -> Option<(CompressedFormat, Vec<u8>)> {
                    self.main_level().read_compressed_data()
                }
            
            /// Turns the texture into a `ResidentTexture`.
            ///
            /// This allows you to use the texture in a much more efficient way by storing
            /// a "reference to it" in a buffer (actually not a reference but a raw pointer).
            ///
            /// See the documentation of `ResidentTexture` for more infos.
            pub fn resident(self) -> Result<ResidentTexture, BindlessTexturesNotSupportedError> {
                ResidentTexture::new(self.0)
            }
        
                /// Access a single mipmap level of this texture.
                pub fn mipmap(&self, level: u32) -> Option<CompressedTexture3dMipmap> {
                    self.0.mipmap(0, level).map(|m| CompressedTexture3dMipmap(m, self))
                }
            
                /// Access the main mipmap level of this texture.
                pub fn main_level(&self) -> CompressedTexture3dMipmap {
                    self.mipmap(0).unwrap()
                }
            }

                    /// Represents a single mipmap level of a `CompressedTexture3d`.
                    ///
                    /// Can be obtained by calling `CompressedTexture3d::mipmap()` or `CompressedTexture3d::main_level()`.
                    #[derive(Copy, Clone)]
                    pub struct CompressedTexture3dMipmap<'t>(TextureAnyMipmap<'t>, &'t CompressedTexture3d);
                impl<'t> CompressedTexture3dMipmap<'t> {

                    /// Reads the content of the texture level to RAM without decompressing it before.
                    ///
                    /// You should avoid doing this at all cost during performance-critical
                    /// operations (for example, while you're drawing).
                    ///
                    /// Returns the compressed format of the texture and the compressed data, gives
                    /// `None` when the internal compression format is generic or unknown.
                    pub fn read_compressed_data(&self) -> Option<(CompressedFormat, Vec<u8>)> {
                        match self.0.download_compressed_data() {
                            Some((ClientFormatAny::CompressedFormat(format), buf)) => Some((format, buf)),
                            None => None,
                            _ => unreachable!(),
                        }
                    }
                
                /// Returns the corresponding texture.
                pub fn get_texture(&self) -> &'t CompressedTexture3d {
                    self.1
                }

                /// Returns the texture level.
                pub fn get_level(&self) -> u32 {
                    self.0.get_level()
                }
            }
/// A three-dimensional texture  containing sRGB floating-point data.
pub struct SrgbTexture3d(TextureAny);

                impl Texture for SrgbTexture3d {
                    fn get_width(&self) -> u32 {
                        self.0.get_width()
                    }

                    fn get_height(&self) -> Option<u32> {
                        self.0.get_height()
                    }

                    fn get_depth(&self) -> Option<u32> {
                        self.0.get_depth()
                    }

                    fn get_array_size(&self) -> Option<u32> {
                        self.0.get_array_size()
                    }
                }
            

                impl GlObject for SrgbTexture3d {
                    type Id = gl::types::GLuint;
                    fn get_id(&self) -> gl::types::GLuint {
                        self.0.get_id()
                    }
                }
            

                impl ::std::fmt::Debug for SrgbTexture3d {
                    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> Result<(), ::std::fmt::Error>
                    {
                        self.0.fmt(f)
                    }
                }
            

                impl ::std::ops::Deref for SrgbTexture3d {
                    type Target = TextureAny;
                    
                    fn deref<'a>(&'a self) -> &'a TextureAny {
                        &self.0
                    }
                }
            

                            impl<'a> AsUniformValue for &'a SrgbTexture3d {
                                fn as_uniform_value(&self) -> UniformValue {
                                    UniformValue::SrgbTexture3d(*self, None)
                                }
                            }

                            impl<'a> AsUniformValue for Sampler<'a, SrgbTexture3d> {
                                fn as_uniform_value(&self) -> UniformValue {
                                    UniformValue::SrgbTexture3d(self.0, Some(self.1))
                                }
                            }

                            impl SrgbTexture3d {
                                /// Builds a `Sampler` marker object that allows you to indicate
                                /// how the texture should be sampled from inside a shader.
                                ///
                                /// # Example
                                ///
                                /// ```no_run
                                /// # #[macro_use] extern crate glium;
                                /// # fn main() {
                                /// # let texture: glium::texture::Texture2d = unsafe {
                                /// # ::std::mem::uninitialized() };
                                /// let uniforms = uniform! {
                                ///     color_texture: texture.sampled().magnify_filter(glium::uniforms::MagnifySamplerFilter::Nearest)
                                /// };
                                /// # }
                                /// ```
                                pub fn sampled(&self) -> Sampler<SrgbTexture3d> {
                                    Sampler(self, Default::default())
                                }
                            }
                        
impl SrgbTexture3d {

            /// Determines the internal format of this texture.
            ///
            /// The backend may not support querying the actual format, in which case an error
            /// is returned.
            pub fn get_internal_format(&self) -> Result<InternalFormat, GetFormatError> {
                self.0.get_internal_format()
            }
        

                /// Builds a new texture by uploading data.
                ///
                /// This function will automatically generate all mipmaps of the texture.
                pub fn new<'a, F, T>(facade: &F, data: T)
                              -> Result<SrgbTexture3d, TextureCreationError>
                              where T: Texture3dDataSource<'a>, F: Facade
                {
                    SrgbTexture3d::new_impl(facade, data, None, MipmapsOption::AutoGeneratedMipmaps)
                }
            

                /// Builds a new texture by uploading data.
                pub fn with_mipmaps<'a, F, T>(facade: &F, data: T, mipmaps: MipmapsOption)
                                              -> Result<SrgbTexture3d, TextureCreationError>
                                              where T: Texture3dDataSource<'a>, F: Facade
                {
                    SrgbTexture3d::new_impl(facade, data, None, mipmaps)
                }
            

                /// Builds a new texture with a specific format.
                pub fn with_format<'a, F, T>(facade: &F, data: T,
                                          format: SrgbFormat, mipmaps: MipmapsOption)
                                          -> Result<SrgbTexture3d, TextureCreationError>
                                          where T: Texture3dDataSource<'a>, F: Facade
                {
                    SrgbTexture3d::new_impl(facade, data, Some(format), mipmaps)
                }
            

                fn new_impl<'a, F, T>(facade: &F, data: T,
                                   format: Option<SrgbFormat>, mipmaps: MipmapsOption)
                                   -> Result<SrgbTexture3d, TextureCreationError>
                                   where T: Texture3dDataSource<'a>, F: Facade
                {
            
let format = format.map(|f| {
                           TextureFormatRequest::Specific(f.to_texture_format())
                       }).unwrap_or(TextureFormatRequest::AnySrgb);
                    let RawImage3d { data, width, height, depth, format: client_format } =
                                            data.into_raw();
                let client_format = ClientFormatAny::ClientFormat(client_format);Ok(SrgbTexture3d(try!(any::new_texture(facade, format, Some((client_format, data)), mipmaps.to_regular(), Dimensions::Texture3d { width: width, height: height, depth: depth }))))
}

                /// Creates an empty texture.
                ///
                /// No mipmap level (except for the main level) will be allocated or generated.
                ///
                /// The texture will contain undefined data.
                pub fn empty<F>(facade: &F, width: u32, height: u32, depth: u32)
                                -> Result<SrgbTexture3d, TextureCreationError>
                                where F: Facade
                {
                    let format = TextureFormatRequest::AnySrgb;
            
any::new_texture::<_, u8>(facade, format, None, MipmapsOption::NoMipmap.to_regular(), Dimensions::Texture3d { width: width, height: height, depth: depth }).map(|t| SrgbTexture3d(t))}

                /// Creates an empty texture with a specific format.
                ///
                /// The texture (and its mipmaps) will contain undefined data.
                pub fn empty_with_format<F>(facade: &F, format: SrgbFormat, mipmaps: MipmapsOption, width: u32, height: u32, depth: u32) -> Result<SrgbTexture3d, TextureCreationError> where F: Facade {
                    let format = format.to_texture_format();
                    let format = TextureFormatRequest::Specific(format);
            
let t = any::new_texture::<_, u8>(facade, format, None, mipmaps.to_regular(), Dimensions::Texture3d { width: width, height: height, depth: depth });
            t.map(|t| SrgbTexture3d(t))
}

                /// Creates an empty texture. Specifies whether is has mipmaps.
                ///
                /// The texture (and its mipmaps) will contain undefined data.
                pub fn empty_with_mipmaps<F>(facade: &F, mipmaps: MipmapsOption, width: u32, height: u32, depth: u32) -> Result<SrgbTexture3d, TextureCreationError> where F: Facade {
                    let format = TextureFormatRequest::AnySrgb;
            
any::new_texture::<_, u8>(facade, format, None, mipmaps.to_regular(), Dimensions::Texture3d { width: width, height: height, depth: depth }).map(|t| SrgbTexture3d(t))
}

            /// Returns the number of mipmap levels of the texture.
            ///
            /// The minimum value is 1, since there is always a main texture.
            pub fn get_mipmap_levels(&self) -> u32 {
                self.0.get_mipmap_levels()
            }
        
            /// Turns the texture into a `ResidentTexture`.
            ///
            /// This allows you to use the texture in a much more efficient way by storing
            /// a "reference to it" in a buffer (actually not a reference but a raw pointer).
            ///
            /// See the documentation of `ResidentTexture` for more infos.
            pub fn resident(self) -> Result<ResidentTexture, BindlessTexturesNotSupportedError> {
                ResidentTexture::new(self.0)
            }
        
                /// Access a single mipmap level of this texture.
                pub fn mipmap(&self, level: u32) -> Option<SrgbTexture3dMipmap> {
                    self.0.mipmap(0, level).map(|m| SrgbTexture3dMipmap(m, self))
                }
            
                /// Access the main mipmap level of this texture.
                pub fn main_level(&self) -> SrgbTexture3dMipmap {
                    self.mipmap(0).unwrap()
                }
            }

                    /// Represents a single mipmap level of a `SrgbTexture3d`.
                    ///
                    /// Can be obtained by calling `SrgbTexture3d::mipmap()` or `SrgbTexture3d::main_level()`.
                    #[derive(Copy, Clone)]
                    pub struct SrgbTexture3dMipmap<'t>(TextureAnyMipmap<'t>, &'t SrgbTexture3d);
                impl<'t> SrgbTexture3dMipmap<'t> {

                /// Returns the corresponding texture.
                pub fn get_texture(&self) -> &'t SrgbTexture3d {
                    self.1
                }

                /// Returns the texture level.
                pub fn get_level(&self) -> u32 {
                    self.0.get_level()
                }
            }
/// A compressed three-dimensional texture  containing sRGB floating-point data.
pub struct CompressedSrgbTexture3d(TextureAny);

                impl Texture for CompressedSrgbTexture3d {
                    fn get_width(&self) -> u32 {
                        self.0.get_width()
                    }

                    fn get_height(&self) -> Option<u32> {
                        self.0.get_height()
                    }

                    fn get_depth(&self) -> Option<u32> {
                        self.0.get_depth()
                    }

                    fn get_array_size(&self) -> Option<u32> {
                        self.0.get_array_size()
                    }
                }
            

                impl GlObject for CompressedSrgbTexture3d {
                    type Id = gl::types::GLuint;
                    fn get_id(&self) -> gl::types::GLuint {
                        self.0.get_id()
                    }
                }
            

                impl ::std::fmt::Debug for CompressedSrgbTexture3d {
                    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> Result<(), ::std::fmt::Error>
                    {
                        self.0.fmt(f)
                    }
                }
            

                impl ::std::ops::Deref for CompressedSrgbTexture3d {
                    type Target = TextureAny;
                    
                    fn deref<'a>(&'a self) -> &'a TextureAny {
                        &self.0
                    }
                }
            

                            impl<'a> AsUniformValue for &'a CompressedSrgbTexture3d {
                                fn as_uniform_value(&self) -> UniformValue {
                                    UniformValue::CompressedSrgbTexture3d(*self, None)
                                }
                            }

                            impl<'a> AsUniformValue for Sampler<'a, CompressedSrgbTexture3d> {
                                fn as_uniform_value(&self) -> UniformValue {
                                    UniformValue::CompressedSrgbTexture3d(self.0, Some(self.1))
                                }
                            }

                            impl CompressedSrgbTexture3d {
                                /// Builds a `Sampler` marker object that allows you to indicate
                                /// how the texture should be sampled from inside a shader.
                                ///
                                /// # Example
                                ///
                                /// ```no_run
                                /// # #[macro_use] extern crate glium;
                                /// # fn main() {
                                /// # let texture: glium::texture::Texture2d = unsafe {
                                /// # ::std::mem::uninitialized() };
                                /// let uniforms = uniform! {
                                ///     color_texture: texture.sampled().magnify_filter(glium::uniforms::MagnifySamplerFilter::Nearest)
                                /// };
                                /// # }
                                /// ```
                                pub fn sampled(&self) -> Sampler<CompressedSrgbTexture3d> {
                                    Sampler(self, Default::default())
                                }
                            }
                        
impl CompressedSrgbTexture3d {

            /// Determines the internal format of this texture.
            ///
            /// The backend may not support querying the actual format, in which case an error
            /// is returned.
            pub fn get_internal_format(&self) -> Result<InternalFormat, GetFormatError> {
                self.0.get_internal_format()
            }
        

                /// Builds a new texture by uploading data.
                ///
                /// No mipmap level (except for the main level) will be allocator nor generated.
                pub fn new<'a, F, T>(facade: &F, data: T)
                              -> Result<CompressedSrgbTexture3d, TextureCreationError>
                              where T: Texture3dDataSource<'a>, F: Facade
                {
                    CompressedSrgbTexture3d::new_impl(facade, data, None, CompressedMipmapsOption::NoMipmap)
                }
            

                /// Builds a new texture by uploading data.
                pub fn with_mipmaps<'a, F, T>(facade: &F, data: T, mipmaps: CompressedMipmapsOption)
                                              -> Result<CompressedSrgbTexture3d, TextureCreationError>
                                              where T: Texture3dDataSource<'a>, F: Facade
                {
                    CompressedSrgbTexture3d::new_impl(facade, data, None, mipmaps)
                }
            

                /// Builds a new texture with a specific format. The input data must also be of the
                /// specified compressed format.
                pub fn with_compressed_data<F>(facade: &F, data: &[u8], width: u32, height: u32, depth: u32,
                                                      format: CompressedSrgbFormat, mipmaps: CompressedMipmapsOption)
                                                      -> Result<CompressedSrgbTexture3d, TextureCreationError>
                                                       where F: Facade
                {
                    let data = Cow::Borrowed(data.as_ref());
                    let client_format = ClientFormatAny::CompressedSrgbFormat(format);
                    Ok(CompressedSrgbTexture3d(try!(any::new_texture(facade, TextureFormatRequest::AnyCompressedSrgb, Some((client_format, data)),
                                                    mipmaps.to_regular(), Dimensions::Texture3d { width: width, height: height, depth: depth }))))
                }
            

                /// Builds a new texture with a specific format.
                pub fn with_format<'a, F, T>(facade: &F, data: T,
                                          format: CompressedSrgbFormat, mipmaps: CompressedMipmapsOption)
                                          -> Result<CompressedSrgbTexture3d, TextureCreationError>
                                          where T: Texture3dDataSource<'a>, F: Facade
                {
                    CompressedSrgbTexture3d::new_impl(facade, data, Some(format), mipmaps)
                }
            

                fn new_impl<'a, F, T>(facade: &F, data: T,
                                   format: Option<CompressedSrgbFormat>, mipmaps: CompressedMipmapsOption)
                                   -> Result<CompressedSrgbTexture3d, TextureCreationError>
                                   where T: Texture3dDataSource<'a>, F: Facade
                {
            
let format = format.map(|f| {
                           TextureFormatRequest::Specific(f.to_texture_format())
                       }).unwrap_or(TextureFormatRequest::AnyCompressedSrgb);
                    let RawImage3d { data, width, height, depth, format: client_format } =
                                            data.into_raw();
                let client_format = ClientFormatAny::ClientFormat(client_format);Ok(CompressedSrgbTexture3d(try!(any::new_texture(facade, format, Some((client_format, data)), mipmaps.to_regular(), Dimensions::Texture3d { width: width, height: height, depth: depth }))))
}

                /// Creates an empty texture with a specific format.
                ///
                /// The texture (and its mipmaps) will contain undefined data.
                pub fn empty_with_format<F>(facade: &F, format: CompressedSrgbFormat, mipmaps: CompressedMipmapsOption, width: u32, height: u32, depth: u32) -> Result<CompressedSrgbTexture3d, TextureCreationError> where F: Facade {
                    let format = format.to_texture_format();
                    let format = TextureFormatRequest::Specific(format);
            
let t = any::new_texture::<_, u8>(facade, format, None, mipmaps.to_regular(), Dimensions::Texture3d { width: width, height: height, depth: depth });
            t.map(|t| CompressedSrgbTexture3d(t))
}

            /// Returns the number of mipmap levels of the texture.
            ///
            /// The minimum value is 1, since there is always a main texture.
            pub fn get_mipmap_levels(&self) -> u32 {
                self.0.get_mipmap_levels()
            }
        
                /// Reads the content of the texture to RAM without decompressing it before.
                ///
                /// You should avoid doing this at all cost during performance-critical
                /// operations (for example, while you're drawing).
                ///
                /// Returns the compressed format of the texture and the compressed data, gives
                /// `None` when the internal compression format is generic or unknown.
                pub fn read_compressed_data(&self) -> Option<(CompressedSrgbFormat, Vec<u8>)> {
                    self.main_level().read_compressed_data()
                }
            
            /// Turns the texture into a `ResidentTexture`.
            ///
            /// This allows you to use the texture in a much more efficient way by storing
            /// a "reference to it" in a buffer (actually not a reference but a raw pointer).
            ///
            /// See the documentation of `ResidentTexture` for more infos.
            pub fn resident(self) -> Result<ResidentTexture, BindlessTexturesNotSupportedError> {
                ResidentTexture::new(self.0)
            }
        
                /// Access a single mipmap level of this texture.
                pub fn mipmap(&self, level: u32) -> Option<CompressedSrgbTexture3dMipmap> {
                    self.0.mipmap(0, level).map(|m| CompressedSrgbTexture3dMipmap(m, self))
                }
            
                /// Access the main mipmap level of this texture.
                pub fn main_level(&self) -> CompressedSrgbTexture3dMipmap {
                    self.mipmap(0).unwrap()
                }
            }

                    /// Represents a single mipmap level of a `CompressedSrgbTexture3d`.
                    ///
                    /// Can be obtained by calling `CompressedSrgbTexture3d::mipmap()` or `CompressedSrgbTexture3d::main_level()`.
                    #[derive(Copy, Clone)]
                    pub struct CompressedSrgbTexture3dMipmap<'t>(TextureAnyMipmap<'t>, &'t CompressedSrgbTexture3d);
                impl<'t> CompressedSrgbTexture3dMipmap<'t> {

                    /// Reads the content of the texture level to RAM without decompressing it before.
                    ///
                    /// You should avoid doing this at all cost during performance-critical
                    /// operations (for example, while you're drawing).
                    ///
                    /// Returns the compressed format of the texture and the compressed data, gives
                    /// `None` when the internal compression format is generic or unknown.
                    pub fn read_compressed_data(&self) -> Option<(CompressedSrgbFormat, Vec<u8>)> {
                        match self.0.download_compressed_data() {
                            Some((ClientFormatAny::CompressedSrgbFormat(format), buf)) => Some((format, buf)),
                            None => None,
                            _ => unreachable!(),
                        }
                    }
                
                /// Returns the corresponding texture.
                pub fn get_texture(&self) -> &'t CompressedSrgbTexture3d {
                    self.1
                }

                /// Returns the texture level.
                pub fn get_level(&self) -> u32 {
                    self.0.get_level()
                }
            }
/// A three-dimensional texture  containing signed integral data.
pub struct IntegralTexture3d(TextureAny);

                impl Texture for IntegralTexture3d {
                    fn get_width(&self) -> u32 {
                        self.0.get_width()
                    }

                    fn get_height(&self) -> Option<u32> {
                        self.0.get_height()
                    }

                    fn get_depth(&self) -> Option<u32> {
                        self.0.get_depth()
                    }

                    fn get_array_size(&self) -> Option<u32> {
                        self.0.get_array_size()
                    }
                }
            

                impl GlObject for IntegralTexture3d {
                    type Id = gl::types::GLuint;
                    fn get_id(&self) -> gl::types::GLuint {
                        self.0.get_id()
                    }
                }
            

                impl ::std::fmt::Debug for IntegralTexture3d {
                    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> Result<(), ::std::fmt::Error>
                    {
                        self.0.fmt(f)
                    }
                }
            

                impl ::std::ops::Deref for IntegralTexture3d {
                    type Target = TextureAny;
                    
                    fn deref<'a>(&'a self) -> &'a TextureAny {
                        &self.0
                    }
                }
            

                            impl<'a> AsUniformValue for &'a IntegralTexture3d {
                                fn as_uniform_value(&self) -> UniformValue {
                                    UniformValue::IntegralTexture3d(*self, None)
                                }
                            }

                            impl<'a> AsUniformValue for Sampler<'a, IntegralTexture3d> {
                                fn as_uniform_value(&self) -> UniformValue {
                                    UniformValue::IntegralTexture3d(self.0, Some(self.1))
                                }
                            }

                            impl IntegralTexture3d {
                                /// Builds a `Sampler` marker object that allows you to indicate
                                /// how the texture should be sampled from inside a shader.
                                ///
                                /// # Example
                                ///
                                /// ```no_run
                                /// # #[macro_use] extern crate glium;
                                /// # fn main() {
                                /// # let texture: glium::texture::Texture2d = unsafe {
                                /// # ::std::mem::uninitialized() };
                                /// let uniforms = uniform! {
                                ///     color_texture: texture.sampled().magnify_filter(glium::uniforms::MagnifySamplerFilter::Nearest)
                                /// };
                                /// # }
                                /// ```
                                pub fn sampled(&self) -> Sampler<IntegralTexture3d> {
                                    Sampler(self, Default::default())
                                }
                            }
                        
impl IntegralTexture3d {

            /// Determines the internal format of this texture.
            ///
            /// The backend may not support querying the actual format, in which case an error
            /// is returned.
            pub fn get_internal_format(&self) -> Result<InternalFormat, GetFormatError> {
                self.0.get_internal_format()
            }
        

                /// Builds a new texture by uploading data.
                ///
                /// This function will automatically generate all mipmaps of the texture.
                pub fn new<'a, F, T>(facade: &F, data: T)
                              -> Result<IntegralTexture3d, TextureCreationError>
                              where T: Texture3dDataSource<'a>, F: Facade
                {
                    IntegralTexture3d::new_impl(facade, data, None, MipmapsOption::AutoGeneratedMipmaps)
                }
            

                /// Builds a new texture by uploading data.
                pub fn with_mipmaps<'a, F, T>(facade: &F, data: T, mipmaps: MipmapsOption)
                                              -> Result<IntegralTexture3d, TextureCreationError>
                                              where T: Texture3dDataSource<'a>, F: Facade
                {
                    IntegralTexture3d::new_impl(facade, data, None, mipmaps)
                }
            

                /// Builds a new texture with a specific format.
                pub fn with_format<'a, F, T>(facade: &F, data: T,
                                          format: UncompressedIntFormat, mipmaps: MipmapsOption)
                                          -> Result<IntegralTexture3d, TextureCreationError>
                                          where T: Texture3dDataSource<'a>, F: Facade
                {
                    IntegralTexture3d::new_impl(facade, data, Some(format), mipmaps)
                }
            

                fn new_impl<'a, F, T>(facade: &F, data: T,
                                   format: Option<UncompressedIntFormat>, mipmaps: MipmapsOption)
                                   -> Result<IntegralTexture3d, TextureCreationError>
                                   where T: Texture3dDataSource<'a>, F: Facade
                {
            
let format = format.map(|f| {
                           TextureFormatRequest::Specific(f.to_texture_format())
                       }).unwrap_or(TextureFormatRequest::AnyIntegral);
                    let RawImage3d { data, width, height, depth, format: client_format } =
                                            data.into_raw();
                let client_format = ClientFormatAny::ClientFormat(client_format);Ok(IntegralTexture3d(try!(any::new_texture(facade, format, Some((client_format, data)), mipmaps.to_regular(), Dimensions::Texture3d { width: width, height: height, depth: depth }))))
}

                /// Creates an empty texture.
                ///
                /// No mipmap level (except for the main level) will be allocated or generated.
                ///
                /// The texture will contain undefined data.
                pub fn empty<F>(facade: &F, width: u32, height: u32, depth: u32)
                                -> Result<IntegralTexture3d, TextureCreationError>
                                where F: Facade
                {
                    let format = TextureFormatRequest::AnyIntegral;
            
any::new_texture::<_, u8>(facade, format, None, MipmapsOption::NoMipmap.to_regular(), Dimensions::Texture3d { width: width, height: height, depth: depth }).map(|t| IntegralTexture3d(t))}

                /// Creates an empty texture with a specific format.
                ///
                /// The texture (and its mipmaps) will contain undefined data.
                pub fn empty_with_format<F>(facade: &F, format: UncompressedIntFormat, mipmaps: MipmapsOption, width: u32, height: u32, depth: u32) -> Result<IntegralTexture3d, TextureCreationError> where F: Facade {
                    let format = format.to_texture_format();
                    let format = TextureFormatRequest::Specific(format);
            
let t = any::new_texture::<_, u8>(facade, format, None, mipmaps.to_regular(), Dimensions::Texture3d { width: width, height: height, depth: depth });
            t.map(|t| IntegralTexture3d(t))
}

                /// Creates an empty texture. Specifies whether is has mipmaps.
                ///
                /// The texture (and its mipmaps) will contain undefined data.
                pub fn empty_with_mipmaps<F>(facade: &F, mipmaps: MipmapsOption, width: u32, height: u32, depth: u32) -> Result<IntegralTexture3d, TextureCreationError> where F: Facade {
                    let format = TextureFormatRequest::AnyIntegral;
            
any::new_texture::<_, u8>(facade, format, None, mipmaps.to_regular(), Dimensions::Texture3d { width: width, height: height, depth: depth }).map(|t| IntegralTexture3d(t))
}

            /// Returns the number of mipmap levels of the texture.
            ///
            /// The minimum value is 1, since there is always a main texture.
            pub fn get_mipmap_levels(&self) -> u32 {
                self.0.get_mipmap_levels()
            }
        
            /// Turns the texture into a `ResidentTexture`.
            ///
            /// This allows you to use the texture in a much more efficient way by storing
            /// a "reference to it" in a buffer (actually not a reference but a raw pointer).
            ///
            /// See the documentation of `ResidentTexture` for more infos.
            pub fn resident(self) -> Result<ResidentTexture, BindlessTexturesNotSupportedError> {
                ResidentTexture::new(self.0)
            }
        
                /// Access a single mipmap level of this texture.
                pub fn mipmap(&self, level: u32) -> Option<IntegralTexture3dMipmap> {
                    self.0.mipmap(0, level).map(|m| IntegralTexture3dMipmap(m, self))
                }
            
                /// Access the main mipmap level of this texture.
                pub fn main_level(&self) -> IntegralTexture3dMipmap {
                    self.mipmap(0).unwrap()
                }
            }

                    /// Represents a single mipmap level of a `IntegralTexture3d`.
                    ///
                    /// Can be obtained by calling `IntegralTexture3d::mipmap()` or `IntegralTexture3d::main_level()`.
                    #[derive(Copy, Clone)]
                    pub struct IntegralTexture3dMipmap<'t>(TextureAnyMipmap<'t>, &'t IntegralTexture3d);
                impl<'t> IntegralTexture3dMipmap<'t> {

                /// Returns the corresponding texture.
                pub fn get_texture(&self) -> &'t IntegralTexture3d {
                    self.1
                }

                /// Returns the texture level.
                pub fn get_level(&self) -> u32 {
                    self.0.get_level()
                }
            }
/// A three-dimensional texture  containing unsigned integral data.
pub struct UnsignedTexture3d(TextureAny);

                impl Texture for UnsignedTexture3d {
                    fn get_width(&self) -> u32 {
                        self.0.get_width()
                    }

                    fn get_height(&self) -> Option<u32> {
                        self.0.get_height()
                    }

                    fn get_depth(&self) -> Option<u32> {
                        self.0.get_depth()
                    }

                    fn get_array_size(&self) -> Option<u32> {
                        self.0.get_array_size()
                    }
                }
            

                impl GlObject for UnsignedTexture3d {
                    type Id = gl::types::GLuint;
                    fn get_id(&self) -> gl::types::GLuint {
                        self.0.get_id()
                    }
                }
            

                impl ::std::fmt::Debug for UnsignedTexture3d {
                    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> Result<(), ::std::fmt::Error>
                    {
                        self.0.fmt(f)
                    }
                }
            

                impl ::std::ops::Deref for UnsignedTexture3d {
                    type Target = TextureAny;
                    
                    fn deref<'a>(&'a self) -> &'a TextureAny {
                        &self.0
                    }
                }
            

                            impl<'a> AsUniformValue for &'a UnsignedTexture3d {
                                fn as_uniform_value(&self) -> UniformValue {
                                    UniformValue::UnsignedTexture3d(*self, None)
                                }
                            }

                            impl<'a> AsUniformValue for Sampler<'a, UnsignedTexture3d> {
                                fn as_uniform_value(&self) -> UniformValue {
                                    UniformValue::UnsignedTexture3d(self.0, Some(self.1))
                                }
                            }

                            impl UnsignedTexture3d {
                                /// Builds a `Sampler` marker object that allows you to indicate
                                /// how the texture should be sampled from inside a shader.
                                ///
                                /// # Example
                                ///
                                /// ```no_run
                                /// # #[macro_use] extern crate glium;
                                /// # fn main() {
                                /// # let texture: glium::texture::Texture2d = unsafe {
                                /// # ::std::mem::uninitialized() };
                                /// let uniforms = uniform! {
                                ///     color_texture: texture.sampled().magnify_filter(glium::uniforms::MagnifySamplerFilter::Nearest)
                                /// };
                                /// # }
                                /// ```
                                pub fn sampled(&self) -> Sampler<UnsignedTexture3d> {
                                    Sampler(self, Default::default())
                                }
                            }
                        
impl UnsignedTexture3d {

            /// Determines the internal format of this texture.
            ///
            /// The backend may not support querying the actual format, in which case an error
            /// is returned.
            pub fn get_internal_format(&self) -> Result<InternalFormat, GetFormatError> {
                self.0.get_internal_format()
            }
        

                /// Builds a new texture by uploading data.
                ///
                /// This function will automatically generate all mipmaps of the texture.
                pub fn new<'a, F, T>(facade: &F, data: T)
                              -> Result<UnsignedTexture3d, TextureCreationError>
                              where T: Texture3dDataSource<'a>, F: Facade
                {
                    UnsignedTexture3d::new_impl(facade, data, None, MipmapsOption::AutoGeneratedMipmaps)
                }
            

                /// Builds a new texture by uploading data.
                pub fn with_mipmaps<'a, F, T>(facade: &F, data: T, mipmaps: MipmapsOption)
                                              -> Result<UnsignedTexture3d, TextureCreationError>
                                              where T: Texture3dDataSource<'a>, F: Facade
                {
                    UnsignedTexture3d::new_impl(facade, data, None, mipmaps)
                }
            

                /// Builds a new texture with a specific format.
                pub fn with_format<'a, F, T>(facade: &F, data: T,
                                          format: UncompressedUintFormat, mipmaps: MipmapsOption)
                                          -> Result<UnsignedTexture3d, TextureCreationError>
                                          where T: Texture3dDataSource<'a>, F: Facade
                {
                    UnsignedTexture3d::new_impl(facade, data, Some(format), mipmaps)
                }
            

                fn new_impl<'a, F, T>(facade: &F, data: T,
                                   format: Option<UncompressedUintFormat>, mipmaps: MipmapsOption)
                                   -> Result<UnsignedTexture3d, TextureCreationError>
                                   where T: Texture3dDataSource<'a>, F: Facade
                {
            
let format = format.map(|f| {
                           TextureFormatRequest::Specific(f.to_texture_format())
                       }).unwrap_or(TextureFormatRequest::AnyUnsigned);
                    let RawImage3d { data, width, height, depth, format: client_format } =
                                            data.into_raw();
                let client_format = ClientFormatAny::ClientFormat(client_format);Ok(UnsignedTexture3d(try!(any::new_texture(facade, format, Some((client_format, data)), mipmaps.to_regular(), Dimensions::Texture3d { width: width, height: height, depth: depth }))))
}

                /// Creates an empty texture.
                ///
                /// No mipmap level (except for the main level) will be allocated or generated.
                ///
                /// The texture will contain undefined data.
                pub fn empty<F>(facade: &F, width: u32, height: u32, depth: u32)
                                -> Result<UnsignedTexture3d, TextureCreationError>
                                where F: Facade
                {
                    let format = TextureFormatRequest::AnyUnsigned;
            
any::new_texture::<_, u8>(facade, format, None, MipmapsOption::NoMipmap.to_regular(), Dimensions::Texture3d { width: width, height: height, depth: depth }).map(|t| UnsignedTexture3d(t))}

                /// Creates an empty texture with a specific format.
                ///
                /// The texture (and its mipmaps) will contain undefined data.
                pub fn empty_with_format<F>(facade: &F, format: UncompressedUintFormat, mipmaps: MipmapsOption, width: u32, height: u32, depth: u32) -> Result<UnsignedTexture3d, TextureCreationError> where F: Facade {
                    let format = format.to_texture_format();
                    let format = TextureFormatRequest::Specific(format);
            
let t = any::new_texture::<_, u8>(facade, format, None, mipmaps.to_regular(), Dimensions::Texture3d { width: width, height: height, depth: depth });
            t.map(|t| UnsignedTexture3d(t))
}

                /// Creates an empty texture. Specifies whether is has mipmaps.
                ///
                /// The texture (and its mipmaps) will contain undefined data.
                pub fn empty_with_mipmaps<F>(facade: &F, mipmaps: MipmapsOption, width: u32, height: u32, depth: u32) -> Result<UnsignedTexture3d, TextureCreationError> where F: Facade {
                    let format = TextureFormatRequest::AnyUnsigned;
            
any::new_texture::<_, u8>(facade, format, None, mipmaps.to_regular(), Dimensions::Texture3d { width: width, height: height, depth: depth }).map(|t| UnsignedTexture3d(t))
}

            /// Returns the number of mipmap levels of the texture.
            ///
            /// The minimum value is 1, since there is always a main texture.
            pub fn get_mipmap_levels(&self) -> u32 {
                self.0.get_mipmap_levels()
            }
        
            /// Turns the texture into a `ResidentTexture`.
            ///
            /// This allows you to use the texture in a much more efficient way by storing
            /// a "reference to it" in a buffer (actually not a reference but a raw pointer).
            ///
            /// See the documentation of `ResidentTexture` for more infos.
            pub fn resident(self) -> Result<ResidentTexture, BindlessTexturesNotSupportedError> {
                ResidentTexture::new(self.0)
            }
        
                /// Access a single mipmap level of this texture.
                pub fn mipmap(&self, level: u32) -> Option<UnsignedTexture3dMipmap> {
                    self.0.mipmap(0, level).map(|m| UnsignedTexture3dMipmap(m, self))
                }
            
                /// Access the main mipmap level of this texture.
                pub fn main_level(&self) -> UnsignedTexture3dMipmap {
                    self.mipmap(0).unwrap()
                }
            }

                    /// Represents a single mipmap level of a `UnsignedTexture3d`.
                    ///
                    /// Can be obtained by calling `UnsignedTexture3d::mipmap()` or `UnsignedTexture3d::main_level()`.
                    #[derive(Copy, Clone)]
                    pub struct UnsignedTexture3dMipmap<'t>(TextureAnyMipmap<'t>, &'t UnsignedTexture3d);
                impl<'t> UnsignedTexture3dMipmap<'t> {

                /// Returns the corresponding texture.
                pub fn get_texture(&self) -> &'t UnsignedTexture3d {
                    self.1
                }

                /// Returns the texture level.
                pub fn get_level(&self) -> u32 {
                    self.0.get_level()
                }
            }
/// A three-dimensional texture  containing depth data.
pub struct DepthTexture3d(TextureAny);

                impl Texture for DepthTexture3d {
                    fn get_width(&self) -> u32 {
                        self.0.get_width()
                    }

                    fn get_height(&self) -> Option<u32> {
                        self.0.get_height()
                    }

                    fn get_depth(&self) -> Option<u32> {
                        self.0.get_depth()
                    }

                    fn get_array_size(&self) -> Option<u32> {
                        self.0.get_array_size()
                    }
                }
            

                impl GlObject for DepthTexture3d {
                    type Id = gl::types::GLuint;
                    fn get_id(&self) -> gl::types::GLuint {
                        self.0.get_id()
                    }
                }
            

                impl ::std::fmt::Debug for DepthTexture3d {
                    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> Result<(), ::std::fmt::Error>
                    {
                        self.0.fmt(f)
                    }
                }
            

                impl ::std::ops::Deref for DepthTexture3d {
                    type Target = TextureAny;
                    
                    fn deref<'a>(&'a self) -> &'a TextureAny {
                        &self.0
                    }
                }
            

                            impl<'a> AsUniformValue for &'a DepthTexture3d {
                                fn as_uniform_value(&self) -> UniformValue {
                                    UniformValue::DepthTexture3d(*self, None)
                                }
                            }

                            impl<'a> AsUniformValue for Sampler<'a, DepthTexture3d> {
                                fn as_uniform_value(&self) -> UniformValue {
                                    UniformValue::DepthTexture3d(self.0, Some(self.1))
                                }
                            }

                            impl DepthTexture3d {
                                /// Builds a `Sampler` marker object that allows you to indicate
                                /// how the texture should be sampled from inside a shader.
                                ///
                                /// # Example
                                ///
                                /// ```no_run
                                /// # #[macro_use] extern crate glium;
                                /// # fn main() {
                                /// # let texture: glium::texture::Texture2d = unsafe {
                                /// # ::std::mem::uninitialized() };
                                /// let uniforms = uniform! {
                                ///     color_texture: texture.sampled().magnify_filter(glium::uniforms::MagnifySamplerFilter::Nearest)
                                /// };
                                /// # }
                                /// ```
                                pub fn sampled(&self) -> Sampler<DepthTexture3d> {
                                    Sampler(self, Default::default())
                                }
                            }
                        
impl DepthTexture3d {

            /// Determines the internal format of this texture.
            ///
            /// The backend may not support querying the actual format, in which case an error
            /// is returned.
            pub fn get_internal_format(&self) -> Result<InternalFormat, GetFormatError> {
                self.0.get_internal_format()
            }
        

                /// Builds a new texture by uploading data.
                ///
                /// This function will automatically generate all mipmaps of the texture.
                pub fn new<'a, F, T>(facade: &F, data: T)
                              -> Result<DepthTexture3d, TextureCreationError>
                              where T: Texture3dDataSource<'a>, F: Facade
                {
                    DepthTexture3d::new_impl(facade, data, None, MipmapsOption::AutoGeneratedMipmaps)
                }
            

                /// Builds a new texture by uploading data.
                pub fn with_mipmaps<'a, F, T>(facade: &F, data: T, mipmaps: MipmapsOption)
                                              -> Result<DepthTexture3d, TextureCreationError>
                                              where T: Texture3dDataSource<'a>, F: Facade
                {
                    DepthTexture3d::new_impl(facade, data, None, mipmaps)
                }
            

                /// Builds a new texture with a specific format.
                pub fn with_format<'a, F, T>(facade: &F, data: T,
                                          format: DepthFormat, mipmaps: MipmapsOption)
                                          -> Result<DepthTexture3d, TextureCreationError>
                                          where T: Texture3dDataSource<'a>, F: Facade
                {
                    DepthTexture3d::new_impl(facade, data, Some(format), mipmaps)
                }
            

                fn new_impl<'a, F, T>(facade: &F, data: T,
                                   format: Option<DepthFormat>, mipmaps: MipmapsOption)
                                   -> Result<DepthTexture3d, TextureCreationError>
                                   where T: Texture3dDataSource<'a>, F: Facade
                {
            
let format = format.map(|f| {
                           TextureFormatRequest::Specific(f.to_texture_format())
                       }).unwrap_or(TextureFormatRequest::AnyDepth);
                    let RawImage3d { data, width, height, depth, format: client_format } =
                                            data.into_raw();
                let client_format = ClientFormatAny::ClientFormat(client_format);Ok(DepthTexture3d(try!(any::new_texture(facade, format, Some((client_format, data)), mipmaps.to_regular(), Dimensions::Texture3d { width: width, height: height, depth: depth }))))
}

                /// Creates an empty texture.
                ///
                /// No mipmap level (except for the main level) will be allocated or generated.
                ///
                /// The texture will contain undefined data.
                pub fn empty<F>(facade: &F, width: u32, height: u32, depth: u32)
                                -> Result<DepthTexture3d, TextureCreationError>
                                where F: Facade
                {
                    let format = TextureFormatRequest::AnyDepth;
            
any::new_texture::<_, u8>(facade, format, None, MipmapsOption::NoMipmap.to_regular(), Dimensions::Texture3d { width: width, height: height, depth: depth }).map(|t| DepthTexture3d(t))}

                /// Creates an empty texture with a specific format.
                ///
                /// The texture (and its mipmaps) will contain undefined data.
                pub fn empty_with_format<F>(facade: &F, format: DepthFormat, mipmaps: MipmapsOption, width: u32, height: u32, depth: u32) -> Result<DepthTexture3d, TextureCreationError> where F: Facade {
                    let format = format.to_texture_format();
                    let format = TextureFormatRequest::Specific(format);
            
let t = any::new_texture::<_, u8>(facade, format, None, mipmaps.to_regular(), Dimensions::Texture3d { width: width, height: height, depth: depth });
            t.map(|t| DepthTexture3d(t))
}

                /// Creates an empty texture. Specifies whether is has mipmaps.
                ///
                /// The texture (and its mipmaps) will contain undefined data.
                pub fn empty_with_mipmaps<F>(facade: &F, mipmaps: MipmapsOption, width: u32, height: u32, depth: u32) -> Result<DepthTexture3d, TextureCreationError> where F: Facade {
                    let format = TextureFormatRequest::AnyDepth;
            
any::new_texture::<_, u8>(facade, format, None, mipmaps.to_regular(), Dimensions::Texture3d { width: width, height: height, depth: depth }).map(|t| DepthTexture3d(t))
}

            /// Returns the number of mipmap levels of the texture.
            ///
            /// The minimum value is 1, since there is always a main texture.
            pub fn get_mipmap_levels(&self) -> u32 {
                self.0.get_mipmap_levels()
            }
        
            /// Turns the texture into a `ResidentTexture`.
            ///
            /// This allows you to use the texture in a much more efficient way by storing
            /// a "reference to it" in a buffer (actually not a reference but a raw pointer).
            ///
            /// See the documentation of `ResidentTexture` for more infos.
            pub fn resident(self) -> Result<ResidentTexture, BindlessTexturesNotSupportedError> {
                ResidentTexture::new(self.0)
            }
        
                /// Access a single mipmap level of this texture.
                pub fn mipmap(&self, level: u32) -> Option<DepthTexture3dMipmap> {
                    self.0.mipmap(0, level).map(|m| DepthTexture3dMipmap(m, self))
                }
            
                /// Access the main mipmap level of this texture.
                pub fn main_level(&self) -> DepthTexture3dMipmap {
                    self.mipmap(0).unwrap()
                }
            }

                    /// Represents a single mipmap level of a `DepthTexture3d`.
                    ///
                    /// Can be obtained by calling `DepthTexture3d::mipmap()` or `DepthTexture3d::main_level()`.
                    #[derive(Copy, Clone)]
                    pub struct DepthTexture3dMipmap<'t>(TextureAnyMipmap<'t>, &'t DepthTexture3d);
                impl<'t> DepthTexture3dMipmap<'t> {

                /// Returns the corresponding texture.
                pub fn get_texture(&self) -> &'t DepthTexture3d {
                    self.1
                }

                /// Returns the texture level.
                pub fn get_level(&self) -> u32 {
                    self.0.get_level()
                }
            }
/// A three-dimensional texture  containing stencil data.
pub struct StencilTexture3d(TextureAny);

                impl Texture for StencilTexture3d {
                    fn get_width(&self) -> u32 {
                        self.0.get_width()
                    }

                    fn get_height(&self) -> Option<u32> {
                        self.0.get_height()
                    }

                    fn get_depth(&self) -> Option<u32> {
                        self.0.get_depth()
                    }

                    fn get_array_size(&self) -> Option<u32> {
                        self.0.get_array_size()
                    }
                }
            

                impl GlObject for StencilTexture3d {
                    type Id = gl::types::GLuint;
                    fn get_id(&self) -> gl::types::GLuint {
                        self.0.get_id()
                    }
                }
            

                impl ::std::fmt::Debug for StencilTexture3d {
                    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> Result<(), ::std::fmt::Error>
                    {
                        self.0.fmt(f)
                    }
                }
            

                impl ::std::ops::Deref for StencilTexture3d {
                    type Target = TextureAny;
                    
                    fn deref<'a>(&'a self) -> &'a TextureAny {
                        &self.0
                    }
                }
            
impl StencilTexture3d {

            /// Determines the internal format of this texture.
            ///
            /// The backend may not support querying the actual format, in which case an error
            /// is returned.
            pub fn get_internal_format(&self) -> Result<InternalFormat, GetFormatError> {
                self.0.get_internal_format()
            }
        

                /// Builds a new texture by uploading data.
                ///
                /// This function will automatically generate all mipmaps of the texture.
                pub fn new<'a, F, T>(facade: &F, data: T)
                              -> Result<StencilTexture3d, TextureCreationError>
                              where T: Texture3dDataSource<'a>, F: Facade
                {
                    StencilTexture3d::new_impl(facade, data, None, MipmapsOption::AutoGeneratedMipmaps)
                }
            

                /// Builds a new texture by uploading data.
                pub fn with_mipmaps<'a, F, T>(facade: &F, data: T, mipmaps: MipmapsOption)
                                              -> Result<StencilTexture3d, TextureCreationError>
                                              where T: Texture3dDataSource<'a>, F: Facade
                {
                    StencilTexture3d::new_impl(facade, data, None, mipmaps)
                }
            

                /// Builds a new texture with a specific format.
                pub fn with_format<'a, F, T>(facade: &F, data: T,
                                          format: StencilFormat, mipmaps: MipmapsOption)
                                          -> Result<StencilTexture3d, TextureCreationError>
                                          where T: Texture3dDataSource<'a>, F: Facade
                {
                    StencilTexture3d::new_impl(facade, data, Some(format), mipmaps)
                }
            

                fn new_impl<'a, F, T>(facade: &F, data: T,
                                   format: Option<StencilFormat>, mipmaps: MipmapsOption)
                                   -> Result<StencilTexture3d, TextureCreationError>
                                   where T: Texture3dDataSource<'a>, F: Facade
                {
            
let format = format.map(|f| {
                           TextureFormatRequest::Specific(f.to_texture_format())
                       }).unwrap_or(TextureFormatRequest::AnyStencil);
                    let RawImage3d { data, width, height, depth, format: client_format } =
                                            data.into_raw();
                let client_format = ClientFormatAny::ClientFormat(client_format);Ok(StencilTexture3d(try!(any::new_texture(facade, format, Some((client_format, data)), mipmaps.to_regular(), Dimensions::Texture3d { width: width, height: height, depth: depth }))))
}

                /// Creates an empty texture.
                ///
                /// No mipmap level (except for the main level) will be allocated or generated.
                ///
                /// The texture will contain undefined data.
                pub fn empty<F>(facade: &F, width: u32, height: u32, depth: u32)
                                -> Result<StencilTexture3d, TextureCreationError>
                                where F: Facade
                {
                    let format = TextureFormatRequest::AnyStencil;
            
any::new_texture::<_, u8>(facade, format, None, MipmapsOption::NoMipmap.to_regular(), Dimensions::Texture3d { width: width, height: height, depth: depth }).map(|t| StencilTexture3d(t))}

                /// Creates an empty texture with a specific format.
                ///
                /// The texture (and its mipmaps) will contain undefined data.
                pub fn empty_with_format<F>(facade: &F, format: StencilFormat, mipmaps: MipmapsOption, width: u32, height: u32, depth: u32) -> Result<StencilTexture3d, TextureCreationError> where F: Facade {
                    let format = format.to_texture_format();
                    let format = TextureFormatRequest::Specific(format);
            
let t = any::new_texture::<_, u8>(facade, format, None, mipmaps.to_regular(), Dimensions::Texture3d { width: width, height: height, depth: depth });
            t.map(|t| StencilTexture3d(t))
}

                /// Creates an empty texture. Specifies whether is has mipmaps.
                ///
                /// The texture (and its mipmaps) will contain undefined data.
                pub fn empty_with_mipmaps<F>(facade: &F, mipmaps: MipmapsOption, width: u32, height: u32, depth: u32) -> Result<StencilTexture3d, TextureCreationError> where F: Facade {
                    let format = TextureFormatRequest::AnyStencil;
            
any::new_texture::<_, u8>(facade, format, None, mipmaps.to_regular(), Dimensions::Texture3d { width: width, height: height, depth: depth }).map(|t| StencilTexture3d(t))
}

            /// Returns the number of mipmap levels of the texture.
            ///
            /// The minimum value is 1, since there is always a main texture.
            pub fn get_mipmap_levels(&self) -> u32 {
                self.0.get_mipmap_levels()
            }
        
            /// Turns the texture into a `ResidentTexture`.
            ///
            /// This allows you to use the texture in a much more efficient way by storing
            /// a "reference to it" in a buffer (actually not a reference but a raw pointer).
            ///
            /// See the documentation of `ResidentTexture` for more infos.
            pub fn resident(self) -> Result<ResidentTexture, BindlessTexturesNotSupportedError> {
                ResidentTexture::new(self.0)
            }
        
                /// Access a single mipmap level of this texture.
                pub fn mipmap(&self, level: u32) -> Option<StencilTexture3dMipmap> {
                    self.0.mipmap(0, level).map(|m| StencilTexture3dMipmap(m, self))
                }
            
                /// Access the main mipmap level of this texture.
                pub fn main_level(&self) -> StencilTexture3dMipmap {
                    self.mipmap(0).unwrap()
                }
            }

                    /// Represents a single mipmap level of a `StencilTexture3d`.
                    ///
                    /// Can be obtained by calling `StencilTexture3d::mipmap()` or `StencilTexture3d::main_level()`.
                    #[derive(Copy, Clone)]
                    pub struct StencilTexture3dMipmap<'t>(TextureAnyMipmap<'t>, &'t StencilTexture3d);
                impl<'t> StencilTexture3dMipmap<'t> {

                /// Returns the corresponding texture.
                pub fn get_texture(&self) -> &'t StencilTexture3d {
                    self.1
                }

                /// Returns the texture level.
                pub fn get_level(&self) -> u32 {
                    self.0.get_level()
                }
            }
/// A three-dimensional texture  containing both depth and stencil data.
pub struct DepthStencilTexture3d(TextureAny);

                impl Texture for DepthStencilTexture3d {
                    fn get_width(&self) -> u32 {
                        self.0.get_width()
                    }

                    fn get_height(&self) -> Option<u32> {
                        self.0.get_height()
                    }

                    fn get_depth(&self) -> Option<u32> {
                        self.0.get_depth()
                    }

                    fn get_array_size(&self) -> Option<u32> {
                        self.0.get_array_size()
                    }
                }
            

                impl GlObject for DepthStencilTexture3d {
                    type Id = gl::types::GLuint;
                    fn get_id(&self) -> gl::types::GLuint {
                        self.0.get_id()
                    }
                }
            

                impl ::std::fmt::Debug for DepthStencilTexture3d {
                    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> Result<(), ::std::fmt::Error>
                    {
                        self.0.fmt(f)
                    }
                }
            

                impl ::std::ops::Deref for DepthStencilTexture3d {
                    type Target = TextureAny;
                    
                    fn deref<'a>(&'a self) -> &'a TextureAny {
                        &self.0
                    }
                }
            
impl DepthStencilTexture3d {

            /// Determines the internal format of this texture.
            ///
            /// The backend may not support querying the actual format, in which case an error
            /// is returned.
            pub fn get_internal_format(&self) -> Result<InternalFormat, GetFormatError> {
                self.0.get_internal_format()
            }
        

                /// Builds a new texture by uploading data.
                ///
                /// This function will automatically generate all mipmaps of the texture.
                pub fn new<'a, F, T>(facade: &F, data: T)
                              -> Result<DepthStencilTexture3d, TextureCreationError>
                              where T: Texture3dDataSource<'a>, F: Facade
                {
                    DepthStencilTexture3d::new_impl(facade, data, None, MipmapsOption::AutoGeneratedMipmaps)
                }
            

                /// Builds a new texture by uploading data.
                pub fn with_mipmaps<'a, F, T>(facade: &F, data: T, mipmaps: MipmapsOption)
                                              -> Result<DepthStencilTexture3d, TextureCreationError>
                                              where T: Texture3dDataSource<'a>, F: Facade
                {
                    DepthStencilTexture3d::new_impl(facade, data, None, mipmaps)
                }
            

                /// Builds a new texture with a specific format.
                pub fn with_format<'a, F, T>(facade: &F, data: T,
                                          format: DepthStencilFormat, mipmaps: MipmapsOption)
                                          -> Result<DepthStencilTexture3d, TextureCreationError>
                                          where T: Texture3dDataSource<'a>, F: Facade
                {
                    DepthStencilTexture3d::new_impl(facade, data, Some(format), mipmaps)
                }
            

                fn new_impl<'a, F, T>(facade: &F, data: T,
                                   format: Option<DepthStencilFormat>, mipmaps: MipmapsOption)
                                   -> Result<DepthStencilTexture3d, TextureCreationError>
                                   where T: Texture3dDataSource<'a>, F: Facade
                {
            
let format = format.map(|f| {
                           TextureFormatRequest::Specific(f.to_texture_format())
                       }).unwrap_or(TextureFormatRequest::AnyDepthStencil);
                    let RawImage3d { data, width, height, depth, format: client_format } =
                                            data.into_raw();
                let client_format = ClientFormatAny::ClientFormat(client_format);Ok(DepthStencilTexture3d(try!(any::new_texture(facade, format, Some((client_format, data)), mipmaps.to_regular(), Dimensions::Texture3d { width: width, height: height, depth: depth }))))
}

                /// Creates an empty texture.
                ///
                /// No mipmap level (except for the main level) will be allocated or generated.
                ///
                /// The texture will contain undefined data.
                pub fn empty<F>(facade: &F, width: u32, height: u32, depth: u32)
                                -> Result<DepthStencilTexture3d, TextureCreationError>
                                where F: Facade
                {
                    let format = TextureFormatRequest::AnyDepthStencil;
            
any::new_texture::<_, u8>(facade, format, None, MipmapsOption::NoMipmap.to_regular(), Dimensions::Texture3d { width: width, height: height, depth: depth }).map(|t| DepthStencilTexture3d(t))}

                /// Creates an empty texture with a specific format.
                ///
                /// The texture (and its mipmaps) will contain undefined data.
                pub fn empty_with_format<F>(facade: &F, format: DepthStencilFormat, mipmaps: MipmapsOption, width: u32, height: u32, depth: u32) -> Result<DepthStencilTexture3d, TextureCreationError> where F: Facade {
                    let format = format.to_texture_format();
                    let format = TextureFormatRequest::Specific(format);
            
let t = any::new_texture::<_, u8>(facade, format, None, mipmaps.to_regular(), Dimensions::Texture3d { width: width, height: height, depth: depth });
            t.map(|t| DepthStencilTexture3d(t))
}

                /// Creates an empty texture. Specifies whether is has mipmaps.
                ///
                /// The texture (and its mipmaps) will contain undefined data.
                pub fn empty_with_mipmaps<F>(facade: &F, mipmaps: MipmapsOption, width: u32, height: u32, depth: u32) -> Result<DepthStencilTexture3d, TextureCreationError> where F: Facade {
                    let format = TextureFormatRequest::AnyDepthStencil;
            
any::new_texture::<_, u8>(facade, format, None, mipmaps.to_regular(), Dimensions::Texture3d { width: width, height: height, depth: depth }).map(|t| DepthStencilTexture3d(t))
}

            /// Returns the number of mipmap levels of the texture.
            ///
            /// The minimum value is 1, since there is always a main texture.
            pub fn get_mipmap_levels(&self) -> u32 {
                self.0.get_mipmap_levels()
            }
        
            /// Turns the texture into a `ResidentTexture`.
            ///
            /// This allows you to use the texture in a much more efficient way by storing
            /// a "reference to it" in a buffer (actually not a reference but a raw pointer).
            ///
            /// See the documentation of `ResidentTexture` for more infos.
            pub fn resident(self) -> Result<ResidentTexture, BindlessTexturesNotSupportedError> {
                ResidentTexture::new(self.0)
            }
        
                /// Access a single mipmap level of this texture.
                pub fn mipmap(&self, level: u32) -> Option<DepthStencilTexture3dMipmap> {
                    self.0.mipmap(0, level).map(|m| DepthStencilTexture3dMipmap(m, self))
                }
            
                /// Access the main mipmap level of this texture.
                pub fn main_level(&self) -> DepthStencilTexture3dMipmap {
                    self.mipmap(0).unwrap()
                }
            }

                    /// Represents a single mipmap level of a `DepthStencilTexture3d`.
                    ///
                    /// Can be obtained by calling `DepthStencilTexture3d::mipmap()` or `DepthStencilTexture3d::main_level()`.
                    #[derive(Copy, Clone)]
                    pub struct DepthStencilTexture3dMipmap<'t>(TextureAnyMipmap<'t>, &'t DepthStencilTexture3d);
                impl<'t> DepthStencilTexture3dMipmap<'t> {

                /// Returns the corresponding texture.
                pub fn get_texture(&self) -> &'t DepthStencilTexture3d {
                    self.1
                }

                /// Returns the texture level.
                pub fn get_level(&self) -> u32 {
                    self.0.get_level()
                }
            }
/// An array of one-dimensional textures  containing floating-point data.
pub struct Texture1dArray(TextureAny);

                impl Texture for Texture1dArray {
                    fn get_width(&self) -> u32 {
                        self.0.get_width()
                    }

                    fn get_height(&self) -> Option<u32> {
                        self.0.get_height()
                    }

                    fn get_depth(&self) -> Option<u32> {
                        self.0.get_depth()
                    }

                    fn get_array_size(&self) -> Option<u32> {
                        self.0.get_array_size()
                    }
                }
            

                impl GlObject for Texture1dArray {
                    type Id = gl::types::GLuint;
                    fn get_id(&self) -> gl::types::GLuint {
                        self.0.get_id()
                    }
                }
            

                impl ::std::fmt::Debug for Texture1dArray {
                    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> Result<(), ::std::fmt::Error>
                    {
                        self.0.fmt(f)
                    }
                }
            

                impl ::std::ops::Deref for Texture1dArray {
                    type Target = TextureAny;
                    
                    fn deref<'a>(&'a self) -> &'a TextureAny {
                        &self.0
                    }
                }
            

                            impl<'a> AsUniformValue for &'a Texture1dArray {
                                fn as_uniform_value(&self) -> UniformValue {
                                    UniformValue::Texture1dArray(*self, None)
                                }
                            }

                            impl<'a> AsUniformValue for Sampler<'a, Texture1dArray> {
                                fn as_uniform_value(&self) -> UniformValue {
                                    UniformValue::Texture1dArray(self.0, Some(self.1))
                                }
                            }

                            impl Texture1dArray {
                                /// Builds a `Sampler` marker object that allows you to indicate
                                /// how the texture should be sampled from inside a shader.
                                ///
                                /// # Example
                                ///
                                /// ```no_run
                                /// # #[macro_use] extern crate glium;
                                /// # fn main() {
                                /// # let texture: glium::texture::Texture2d = unsafe {
                                /// # ::std::mem::uninitialized() };
                                /// let uniforms = uniform! {
                                ///     color_texture: texture.sampled().magnify_filter(glium::uniforms::MagnifySamplerFilter::Nearest)
                                /// };
                                /// # }
                                /// ```
                                pub fn sampled(&self) -> Sampler<Texture1dArray> {
                                    Sampler(self, Default::default())
                                }
                            }
                        
impl Texture1dArray {

            /// Determines the internal format of this texture.
            ///
            /// The backend may not support querying the actual format, in which case an error
            /// is returned.
            pub fn get_internal_format(&self) -> Result<InternalFormat, GetFormatError> {
                self.0.get_internal_format()
            }
        

                /// Builds a new texture by uploading data.
                ///
                /// This function will automatically generate all mipmaps of the texture.
                pub fn new<'a, F, T>(facade: &F, data: Vec<T>)
                              -> Result<Texture1dArray, TextureCreationError>
                              where T: Texture1dDataSource<'a>, F: Facade
                {
                    Texture1dArray::new_impl(facade, data, None, MipmapsOption::AutoGeneratedMipmaps)
                }
            

                /// Builds a new texture by uploading data.
                pub fn with_mipmaps<'a, F, T>(facade: &F, data: Vec<T>, mipmaps: MipmapsOption)
                                              -> Result<Texture1dArray, TextureCreationError>
                                              where T: Texture1dDataSource<'a>, F: Facade
                {
                    Texture1dArray::new_impl(facade, data, None, mipmaps)
                }
            

                /// Builds a new texture with a specific format.
                pub fn with_format<'a, F, T>(facade: &F, data: Vec<T>,
                                          format: UncompressedFloatFormat, mipmaps: MipmapsOption)
                                          -> Result<Texture1dArray, TextureCreationError>
                                          where T: Texture1dDataSource<'a>, F: Facade
                {
                    Texture1dArray::new_impl(facade, data, Some(format), mipmaps)
                }
            

                fn new_impl<'a, F, T>(facade: &F, data: Vec<T>,
                                   format: Option<UncompressedFloatFormat>, mipmaps: MipmapsOption)
                                   -> Result<Texture1dArray, TextureCreationError>
                                   where T: Texture1dDataSource<'a>, F: Facade
                {
            
let format = format.map(|f| {
                           TextureFormatRequest::Specific(f.to_texture_format())
                       }).unwrap_or(TextureFormatRequest::AnyFloatingPoint);
                    let vec_raw = data.into_iter().map(|e| e.into_raw()).collect();
                    let RawImage2d {data, width, height: array_size, format: client_format } = RawImage2d::from_vec_raw1d(&vec_raw);
                let client_format = ClientFormatAny::ClientFormat(client_format);Ok(Texture1dArray(try!(any::new_texture(facade, format, Some((client_format, data)), mipmaps.to_regular(), Dimensions::Texture1dArray { width: width, array_size: array_size }))))
}

                /// Creates an empty texture.
                ///
                /// No mipmap level (except for the main level) will be allocated or generated.
                ///
                /// The texture will contain undefined data.
                pub fn empty<F>(facade: &F, width: u32, array_size: u32)
                                -> Result<Texture1dArray, TextureCreationError>
                                where F: Facade
                {
                    let format = TextureFormatRequest::AnyFloatingPoint;
            
any::new_texture::<_, u8>(facade, format, None, MipmapsOption::NoMipmap.to_regular(), Dimensions::Texture1dArray { width: width, array_size: array_size }).map(|t| Texture1dArray(t))}

                /// Creates an empty texture with a specific format.
                ///
                /// The texture (and its mipmaps) will contain undefined data.
                pub fn empty_with_format<F>(facade: &F, format: UncompressedFloatFormat, mipmaps: MipmapsOption, width: u32, array_size: u32) -> Result<Texture1dArray, TextureCreationError> where F: Facade {
                    let format = format.to_texture_format();
                    let format = TextureFormatRequest::Specific(format);
            
let t = any::new_texture::<_, u8>(facade, format, None, mipmaps.to_regular(), Dimensions::Texture1dArray { width: width, array_size: array_size });
            t.map(|t| Texture1dArray(t))
}

                /// Creates an empty texture. Specifies whether is has mipmaps.
                ///
                /// The texture (and its mipmaps) will contain undefined data.
                pub fn empty_with_mipmaps<F>(facade: &F, mipmaps: MipmapsOption, width: u32, array_size: u32) -> Result<Texture1dArray, TextureCreationError> where F: Facade {
                    let format = TextureFormatRequest::AnyFloatingPoint;
            
any::new_texture::<_, u8>(facade, format, None, mipmaps.to_regular(), Dimensions::Texture1dArray { width: width, array_size: array_size }).map(|t| Texture1dArray(t))
}

            /// Returns the number of mipmap levels of the texture.
            ///
            /// The minimum value is 1, since there is always a main texture.
            pub fn get_mipmap_levels(&self) -> u32 {
                self.0.get_mipmap_levels()
            }
        
            /// Turns the texture into a `ResidentTexture`.
            ///
            /// This allows you to use the texture in a much more efficient way by storing
            /// a "reference to it" in a buffer (actually not a reference but a raw pointer).
            ///
            /// See the documentation of `ResidentTexture` for more infos.
            pub fn resident(self) -> Result<ResidentTexture, BindlessTexturesNotSupportedError> {
                ResidentTexture::new(self.0)
            }
        
                /// Access a single layer of this texture.
                pub fn layer(&self, layer: u32) -> Option<Texture1dArrayLayer> {
                    if layer < self.0.get_array_size().unwrap_or(1) {
                        Some(Texture1dArrayLayer {
                            texture: self,
                            layer: layer,
                        })
                    } else {
                        None
                    }
                }
            }

                /// Represents a single layer of a `Texture1dArray`.
                ///
                /// Can be obtained by calling `Texture1dArray::layer()`.
                #[derive(Copy, Clone)]
                pub struct Texture1dArrayLayer<'t> {
                    texture: &'t Texture1dArray,
                    layer: u32,
                }
            impl<'t> Texture1dArrayLayer<'t> {

                /// Returns the corresponding texture.
                pub fn get_texture(&self) -> &'t Texture1dArray {
                    self.texture
                }

                /// Returns the layer index.
                pub fn get_layer(&self) -> u32 {
                    self.layer
                }
            
                /// Returns the number of mipmap levels of the texture.
                ///
                /// The minimum value is 1, since there is always a main texture.
                pub fn get_mipmap_levels(&self) -> u32 {
                    self.texture.get_mipmap_levels()
                }
            
                /// Access a single mipmap level of this layer.
                pub fn mipmap(&self, level: u32) -> Option<Texture1dArrayMipmap> {
                    self.texture.0.mipmap(self.layer, level).map(|m| Texture1dArrayMipmap(m, &self.texture))
                }
            
                /// Access the main mipmap level of this layer.
                pub fn main_level(&self) -> Texture1dArrayMipmap {
                    self.mipmap(0).unwrap()
                }
            }

                    /// Represents a single mipmap level of a `Texture1dArray`.
                    ///
                    /// Can be obtained by calling `Texture1dArrayLayer::mipmap()` or
                    /// `Texture1dArrayLayer::main_level()`.
                    #[derive(Copy, Clone)]
                    pub struct Texture1dArrayMipmap<'t>(TextureAnyMipmap<'t>, &'t Texture1dArray);
                impl<'t> Texture1dArrayMipmap<'t> {

                /// Returns the corresponding texture.
                pub fn get_texture(&self) -> &'t Texture1dArray {
                    self.1
                }

                /// Returns the texture level.
                pub fn get_level(&self) -> u32 {
                    self.0.get_level()
                }
            
                    /// Returns the layer index.
                    pub fn get_layer(&self) -> u32 {
                        self.0.get_layer()
                    }
                }
/// An array of compressed one-dimensional textures  containing floating-point data.
pub struct CompressedTexture1dArray(TextureAny);

                impl Texture for CompressedTexture1dArray {
                    fn get_width(&self) -> u32 {
                        self.0.get_width()
                    }

                    fn get_height(&self) -> Option<u32> {
                        self.0.get_height()
                    }

                    fn get_depth(&self) -> Option<u32> {
                        self.0.get_depth()
                    }

                    fn get_array_size(&self) -> Option<u32> {
                        self.0.get_array_size()
                    }
                }
            

                impl GlObject for CompressedTexture1dArray {
                    type Id = gl::types::GLuint;
                    fn get_id(&self) -> gl::types::GLuint {
                        self.0.get_id()
                    }
                }
            

                impl ::std::fmt::Debug for CompressedTexture1dArray {
                    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> Result<(), ::std::fmt::Error>
                    {
                        self.0.fmt(f)
                    }
                }
            

                impl ::std::ops::Deref for CompressedTexture1dArray {
                    type Target = TextureAny;
                    
                    fn deref<'a>(&'a self) -> &'a TextureAny {
                        &self.0
                    }
                }
            

                            impl<'a> AsUniformValue for &'a CompressedTexture1dArray {
                                fn as_uniform_value(&self) -> UniformValue {
                                    UniformValue::CompressedTexture1dArray(*self, None)
                                }
                            }

                            impl<'a> AsUniformValue for Sampler<'a, CompressedTexture1dArray> {
                                fn as_uniform_value(&self) -> UniformValue {
                                    UniformValue::CompressedTexture1dArray(self.0, Some(self.1))
                                }
                            }

                            impl CompressedTexture1dArray {
                                /// Builds a `Sampler` marker object that allows you to indicate
                                /// how the texture should be sampled from inside a shader.
                                ///
                                /// # Example
                                ///
                                /// ```no_run
                                /// # #[macro_use] extern crate glium;
                                /// # fn main() {
                                /// # let texture: glium::texture::Texture2d = unsafe {
                                /// # ::std::mem::uninitialized() };
                                /// let uniforms = uniform! {
                                ///     color_texture: texture.sampled().magnify_filter(glium::uniforms::MagnifySamplerFilter::Nearest)
                                /// };
                                /// # }
                                /// ```
                                pub fn sampled(&self) -> Sampler<CompressedTexture1dArray> {
                                    Sampler(self, Default::default())
                                }
                            }
                        
impl CompressedTexture1dArray {

            /// Determines the internal format of this texture.
            ///
            /// The backend may not support querying the actual format, in which case an error
            /// is returned.
            pub fn get_internal_format(&self) -> Result<InternalFormat, GetFormatError> {
                self.0.get_internal_format()
            }
        

                /// Builds a new texture by uploading data.
                ///
                /// No mipmap level (except for the main level) will be allocator nor generated.
                pub fn new<'a, F, T>(facade: &F, data: Vec<T>)
                              -> Result<CompressedTexture1dArray, TextureCreationError>
                              where T: Texture1dDataSource<'a>, F: Facade
                {
                    CompressedTexture1dArray::new_impl(facade, data, None, CompressedMipmapsOption::NoMipmap)
                }
            

                /// Builds a new texture by uploading data.
                pub fn with_mipmaps<'a, F, T>(facade: &F, data: Vec<T>, mipmaps: CompressedMipmapsOption)
                                              -> Result<CompressedTexture1dArray, TextureCreationError>
                                              where T: Texture1dDataSource<'a>, F: Facade
                {
                    CompressedTexture1dArray::new_impl(facade, data, None, mipmaps)
                }
            

                /// Builds a new texture with a specific format. The input data must also be of the
                /// specified compressed format.
                pub fn with_compressed_data<F>(facade: &F, data: Vec<&[u8]>, width: u32, array_size: u32,
                                                      format: CompressedFormat, mipmaps: CompressedMipmapsOption)
                                                      -> Result<CompressedTexture1dArray, TextureCreationError>
                                                       where F: Facade
                {
                    let data = Cow::Borrowed(data.as_ref());
                    let client_format = ClientFormatAny::CompressedFormat(format);
                    Ok(CompressedTexture1dArray(try!(any::new_texture(facade, TextureFormatRequest::AnyCompressed, Some((client_format, data)),
                                                    mipmaps.to_regular(), Dimensions::Texture1dArray { width: width, array_size: array_size }))))
                }
            

                /// Builds a new texture with a specific format.
                pub fn with_format<'a, F, T>(facade: &F, data: Vec<T>,
                                          format: CompressedFormat, mipmaps: CompressedMipmapsOption)
                                          -> Result<CompressedTexture1dArray, TextureCreationError>
                                          where T: Texture1dDataSource<'a>, F: Facade
                {
                    CompressedTexture1dArray::new_impl(facade, data, Some(format), mipmaps)
                }
            

                fn new_impl<'a, F, T>(facade: &F, data: Vec<T>,
                                   format: Option<CompressedFormat>, mipmaps: CompressedMipmapsOption)
                                   -> Result<CompressedTexture1dArray, TextureCreationError>
                                   where T: Texture1dDataSource<'a>, F: Facade
                {
            
let format = format.map(|f| {
                           TextureFormatRequest::Specific(f.to_texture_format())
                       }).unwrap_or(TextureFormatRequest::AnyCompressed);
                    let vec_raw = data.into_iter().map(|e| e.into_raw()).collect();
                    let RawImage2d {data, width, height: array_size, format: client_format } = RawImage2d::from_vec_raw1d(&vec_raw);
                let client_format = ClientFormatAny::ClientFormat(client_format);Ok(CompressedTexture1dArray(try!(any::new_texture(facade, format, Some((client_format, data)), mipmaps.to_regular(), Dimensions::Texture1dArray { width: width, array_size: array_size }))))
}

                /// Creates an empty texture with a specific format.
                ///
                /// The texture (and its mipmaps) will contain undefined data.
                pub fn empty_with_format<F>(facade: &F, format: CompressedFormat, mipmaps: CompressedMipmapsOption, width: u32, array_size: u32) -> Result<CompressedTexture1dArray, TextureCreationError> where F: Facade {
                    let format = format.to_texture_format();
                    let format = TextureFormatRequest::Specific(format);
            
let t = any::new_texture::<_, u8>(facade, format, None, mipmaps.to_regular(), Dimensions::Texture1dArray { width: width, array_size: array_size });
            t.map(|t| CompressedTexture1dArray(t))
}

            /// Returns the number of mipmap levels of the texture.
            ///
            /// The minimum value is 1, since there is always a main texture.
            pub fn get_mipmap_levels(&self) -> u32 {
                self.0.get_mipmap_levels()
            }
        
            /// Turns the texture into a `ResidentTexture`.
            ///
            /// This allows you to use the texture in a much more efficient way by storing
            /// a "reference to it" in a buffer (actually not a reference but a raw pointer).
            ///
            /// See the documentation of `ResidentTexture` for more infos.
            pub fn resident(self) -> Result<ResidentTexture, BindlessTexturesNotSupportedError> {
                ResidentTexture::new(self.0)
            }
        
                /// Access a single layer of this texture.
                pub fn layer(&self, layer: u32) -> Option<CompressedTexture1dArrayLayer> {
                    if layer < self.0.get_array_size().unwrap_or(1) {
                        Some(CompressedTexture1dArrayLayer {
                            texture: self,
                            layer: layer,
                        })
                    } else {
                        None
                    }
                }
            }

                /// Represents a single layer of a `CompressedTexture1dArray`.
                ///
                /// Can be obtained by calling `CompressedTexture1dArray::layer()`.
                #[derive(Copy, Clone)]
                pub struct CompressedTexture1dArrayLayer<'t> {
                    texture: &'t CompressedTexture1dArray,
                    layer: u32,
                }
            impl<'t> CompressedTexture1dArrayLayer<'t> {

                /// Returns the corresponding texture.
                pub fn get_texture(&self) -> &'t CompressedTexture1dArray {
                    self.texture
                }

                /// Returns the layer index.
                pub fn get_layer(&self) -> u32 {
                    self.layer
                }
            
                /// Returns the number of mipmap levels of the texture.
                ///
                /// The minimum value is 1, since there is always a main texture.
                pub fn get_mipmap_levels(&self) -> u32 {
                    self.texture.get_mipmap_levels()
                }
            
                /// Access a single mipmap level of this layer.
                pub fn mipmap(&self, level: u32) -> Option<CompressedTexture1dArrayMipmap> {
                    self.texture.0.mipmap(self.layer, level).map(|m| CompressedTexture1dArrayMipmap(m, &self.texture))
                }
            
                /// Access the main mipmap level of this layer.
                pub fn main_level(&self) -> CompressedTexture1dArrayMipmap {
                    self.mipmap(0).unwrap()
                }
            }

                    /// Represents a single mipmap level of a `CompressedTexture1dArray`.
                    ///
                    /// Can be obtained by calling `CompressedTexture1dArrayLayer::mipmap()` or
                    /// `CompressedTexture1dArrayLayer::main_level()`.
                    #[derive(Copy, Clone)]
                    pub struct CompressedTexture1dArrayMipmap<'t>(TextureAnyMipmap<'t>, &'t CompressedTexture1dArray);
                impl<'t> CompressedTexture1dArrayMipmap<'t> {

                /// Returns the corresponding texture.
                pub fn get_texture(&self) -> &'t CompressedTexture1dArray {
                    self.1
                }

                /// Returns the texture level.
                pub fn get_level(&self) -> u32 {
                    self.0.get_level()
                }
            
                    /// Returns the layer index.
                    pub fn get_layer(&self) -> u32 {
                        self.0.get_layer()
                    }
                }
/// An array of one-dimensional textures  containing sRGB floating-point data.
pub struct SrgbTexture1dArray(TextureAny);

                impl Texture for SrgbTexture1dArray {
                    fn get_width(&self) -> u32 {
                        self.0.get_width()
                    }

                    fn get_height(&self) -> Option<u32> {
                        self.0.get_height()
                    }

                    fn get_depth(&self) -> Option<u32> {
                        self.0.get_depth()
                    }

                    fn get_array_size(&self) -> Option<u32> {
                        self.0.get_array_size()
                    }
                }
            

                impl GlObject for SrgbTexture1dArray {
                    type Id = gl::types::GLuint;
                    fn get_id(&self) -> gl::types::GLuint {
                        self.0.get_id()
                    }
                }
            

                impl ::std::fmt::Debug for SrgbTexture1dArray {
                    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> Result<(), ::std::fmt::Error>
                    {
                        self.0.fmt(f)
                    }
                }
            

                impl ::std::ops::Deref for SrgbTexture1dArray {
                    type Target = TextureAny;
                    
                    fn deref<'a>(&'a self) -> &'a TextureAny {
                        &self.0
                    }
                }
            

                            impl<'a> AsUniformValue for &'a SrgbTexture1dArray {
                                fn as_uniform_value(&self) -> UniformValue {
                                    UniformValue::SrgbTexture1dArray(*self, None)
                                }
                            }

                            impl<'a> AsUniformValue for Sampler<'a, SrgbTexture1dArray> {
                                fn as_uniform_value(&self) -> UniformValue {
                                    UniformValue::SrgbTexture1dArray(self.0, Some(self.1))
                                }
                            }

                            impl SrgbTexture1dArray {
                                /// Builds a `Sampler` marker object that allows you to indicate
                                /// how the texture should be sampled from inside a shader.
                                ///
                                /// # Example
                                ///
                                /// ```no_run
                                /// # #[macro_use] extern crate glium;
                                /// # fn main() {
                                /// # let texture: glium::texture::Texture2d = unsafe {
                                /// # ::std::mem::uninitialized() };
                                /// let uniforms = uniform! {
                                ///     color_texture: texture.sampled().magnify_filter(glium::uniforms::MagnifySamplerFilter::Nearest)
                                /// };
                                /// # }
                                /// ```
                                pub fn sampled(&self) -> Sampler<SrgbTexture1dArray> {
                                    Sampler(self, Default::default())
                                }
                            }
                        
impl SrgbTexture1dArray {

            /// Determines the internal format of this texture.
            ///
            /// The backend may not support querying the actual format, in which case an error
            /// is returned.
            pub fn get_internal_format(&self) -> Result<InternalFormat, GetFormatError> {
                self.0.get_internal_format()
            }
        

                /// Builds a new texture by uploading data.
                ///
                /// This function will automatically generate all mipmaps of the texture.
                pub fn new<'a, F, T>(facade: &F, data: Vec<T>)
                              -> Result<SrgbTexture1dArray, TextureCreationError>
                              where T: Texture1dDataSource<'a>, F: Facade
                {
                    SrgbTexture1dArray::new_impl(facade, data, None, MipmapsOption::AutoGeneratedMipmaps)
                }
            

                /// Builds a new texture by uploading data.
                pub fn with_mipmaps<'a, F, T>(facade: &F, data: Vec<T>, mipmaps: MipmapsOption)
                                              -> Result<SrgbTexture1dArray, TextureCreationError>
                                              where T: Texture1dDataSource<'a>, F: Facade
                {
                    SrgbTexture1dArray::new_impl(facade, data, None, mipmaps)
                }
            

                /// Builds a new texture with a specific format.
                pub fn with_format<'a, F, T>(facade: &F, data: Vec<T>,
                                          format: SrgbFormat, mipmaps: MipmapsOption)
                                          -> Result<SrgbTexture1dArray, TextureCreationError>
                                          where T: Texture1dDataSource<'a>, F: Facade
                {
                    SrgbTexture1dArray::new_impl(facade, data, Some(format), mipmaps)
                }
            

                fn new_impl<'a, F, T>(facade: &F, data: Vec<T>,
                                   format: Option<SrgbFormat>, mipmaps: MipmapsOption)
                                   -> Result<SrgbTexture1dArray, TextureCreationError>
                                   where T: Texture1dDataSource<'a>, F: Facade
                {
            
let format = format.map(|f| {
                           TextureFormatRequest::Specific(f.to_texture_format())
                       }).unwrap_or(TextureFormatRequest::AnySrgb);
                    let vec_raw = data.into_iter().map(|e| e.into_raw()).collect();
                    let RawImage2d {data, width, height: array_size, format: client_format } = RawImage2d::from_vec_raw1d(&vec_raw);
                let client_format = ClientFormatAny::ClientFormat(client_format);Ok(SrgbTexture1dArray(try!(any::new_texture(facade, format, Some((client_format, data)), mipmaps.to_regular(), Dimensions::Texture1dArray { width: width, array_size: array_size }))))
}

                /// Creates an empty texture.
                ///
                /// No mipmap level (except for the main level) will be allocated or generated.
                ///
                /// The texture will contain undefined data.
                pub fn empty<F>(facade: &F, width: u32, array_size: u32)
                                -> Result<SrgbTexture1dArray, TextureCreationError>
                                where F: Facade
                {
                    let format = TextureFormatRequest::AnySrgb;
            
any::new_texture::<_, u8>(facade, format, None, MipmapsOption::NoMipmap.to_regular(), Dimensions::Texture1dArray { width: width, array_size: array_size }).map(|t| SrgbTexture1dArray(t))}

                /// Creates an empty texture with a specific format.
                ///
                /// The texture (and its mipmaps) will contain undefined data.
                pub fn empty_with_format<F>(facade: &F, format: SrgbFormat, mipmaps: MipmapsOption, width: u32, array_size: u32) -> Result<SrgbTexture1dArray, TextureCreationError> where F: Facade {
                    let format = format.to_texture_format();
                    let format = TextureFormatRequest::Specific(format);
            
let t = any::new_texture::<_, u8>(facade, format, None, mipmaps.to_regular(), Dimensions::Texture1dArray { width: width, array_size: array_size });
            t.map(|t| SrgbTexture1dArray(t))
}

                /// Creates an empty texture. Specifies whether is has mipmaps.
                ///
                /// The texture (and its mipmaps) will contain undefined data.
                pub fn empty_with_mipmaps<F>(facade: &F, mipmaps: MipmapsOption, width: u32, array_size: u32) -> Result<SrgbTexture1dArray, TextureCreationError> where F: Facade {
                    let format = TextureFormatRequest::AnySrgb;
            
any::new_texture::<_, u8>(facade, format, None, mipmaps.to_regular(), Dimensions::Texture1dArray { width: width, array_size: array_size }).map(|t| SrgbTexture1dArray(t))
}

            /// Returns the number of mipmap levels of the texture.
            ///
            /// The minimum value is 1, since there is always a main texture.
            pub fn get_mipmap_levels(&self) -> u32 {
                self.0.get_mipmap_levels()
            }
        
            /// Turns the texture into a `ResidentTexture`.
            ///
            /// This allows you to use the texture in a much more efficient way by storing
            /// a "reference to it" in a buffer (actually not a reference but a raw pointer).
            ///
            /// See the documentation of `ResidentTexture` for more infos.
            pub fn resident(self) -> Result<ResidentTexture, BindlessTexturesNotSupportedError> {
                ResidentTexture::new(self.0)
            }
        
                /// Access a single layer of this texture.
                pub fn layer(&self, layer: u32) -> Option<SrgbTexture1dArrayLayer> {
                    if layer < self.0.get_array_size().unwrap_or(1) {
                        Some(SrgbTexture1dArrayLayer {
                            texture: self,
                            layer: layer,
                        })
                    } else {
                        None
                    }
                }
            }

                /// Represents a single layer of a `SrgbTexture1dArray`.
                ///
                /// Can be obtained by calling `SrgbTexture1dArray::layer()`.
                #[derive(Copy, Clone)]
                pub struct SrgbTexture1dArrayLayer<'t> {
                    texture: &'t SrgbTexture1dArray,
                    layer: u32,
                }
            impl<'t> SrgbTexture1dArrayLayer<'t> {

                /// Returns the corresponding texture.
                pub fn get_texture(&self) -> &'t SrgbTexture1dArray {
                    self.texture
                }

                /// Returns the layer index.
                pub fn get_layer(&self) -> u32 {
                    self.layer
                }
            
                /// Returns the number of mipmap levels of the texture.
                ///
                /// The minimum value is 1, since there is always a main texture.
                pub fn get_mipmap_levels(&self) -> u32 {
                    self.texture.get_mipmap_levels()
                }
            
                /// Access a single mipmap level of this layer.
                pub fn mipmap(&self, level: u32) -> Option<SrgbTexture1dArrayMipmap> {
                    self.texture.0.mipmap(self.layer, level).map(|m| SrgbTexture1dArrayMipmap(m, &self.texture))
                }
            
                /// Access the main mipmap level of this layer.
                pub fn main_level(&self) -> SrgbTexture1dArrayMipmap {
                    self.mipmap(0).unwrap()
                }
            }

                    /// Represents a single mipmap level of a `SrgbTexture1dArray`.
                    ///
                    /// Can be obtained by calling `SrgbTexture1dArrayLayer::mipmap()` or
                    /// `SrgbTexture1dArrayLayer::main_level()`.
                    #[derive(Copy, Clone)]
                    pub struct SrgbTexture1dArrayMipmap<'t>(TextureAnyMipmap<'t>, &'t SrgbTexture1dArray);
                impl<'t> SrgbTexture1dArrayMipmap<'t> {

                /// Returns the corresponding texture.
                pub fn get_texture(&self) -> &'t SrgbTexture1dArray {
                    self.1
                }

                /// Returns the texture level.
                pub fn get_level(&self) -> u32 {
                    self.0.get_level()
                }
            
                    /// Returns the layer index.
                    pub fn get_layer(&self) -> u32 {
                        self.0.get_layer()
                    }
                }
/// An array of compressed one-dimensional textures  containing sRGB floating-point data.
pub struct CompressedSrgbTexture1dArray(TextureAny);

                impl Texture for CompressedSrgbTexture1dArray {
                    fn get_width(&self) -> u32 {
                        self.0.get_width()
                    }

                    fn get_height(&self) -> Option<u32> {
                        self.0.get_height()
                    }

                    fn get_depth(&self) -> Option<u32> {
                        self.0.get_depth()
                    }

                    fn get_array_size(&self) -> Option<u32> {
                        self.0.get_array_size()
                    }
                }
            

                impl GlObject for CompressedSrgbTexture1dArray {
                    type Id = gl::types::GLuint;
                    fn get_id(&self) -> gl::types::GLuint {
                        self.0.get_id()
                    }
                }
            

                impl ::std::fmt::Debug for CompressedSrgbTexture1dArray {
                    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> Result<(), ::std::fmt::Error>
                    {
                        self.0.fmt(f)
                    }
                }
            

                impl ::std::ops::Deref for CompressedSrgbTexture1dArray {
                    type Target = TextureAny;
                    
                    fn deref<'a>(&'a self) -> &'a TextureAny {
                        &self.0
                    }
                }
            

                            impl<'a> AsUniformValue for &'a CompressedSrgbTexture1dArray {
                                fn as_uniform_value(&self) -> UniformValue {
                                    UniformValue::CompressedSrgbTexture1dArray(*self, None)
                                }
                            }

                            impl<'a> AsUniformValue for Sampler<'a, CompressedSrgbTexture1dArray> {
                                fn as_uniform_value(&self) -> UniformValue {
                                    UniformValue::CompressedSrgbTexture1dArray(self.0, Some(self.1))
                                }
                            }

                            impl CompressedSrgbTexture1dArray {
                                /// Builds a `Sampler` marker object that allows you to indicate
                                /// how the texture should be sampled from inside a shader.
                                ///
                                /// # Example
                                ///
                                /// ```no_run
                                /// # #[macro_use] extern crate glium;
                                /// # fn main() {
                                /// # let texture: glium::texture::Texture2d = unsafe {
                                /// # ::std::mem::uninitialized() };
                                /// let uniforms = uniform! {
                                ///     color_texture: texture.sampled().magnify_filter(glium::uniforms::MagnifySamplerFilter::Nearest)
                                /// };
                                /// # }
                                /// ```
                                pub fn sampled(&self) -> Sampler<CompressedSrgbTexture1dArray> {
                                    Sampler(self, Default::default())
                                }
                            }
                        
impl CompressedSrgbTexture1dArray {

            /// Determines the internal format of this texture.
            ///
            /// The backend may not support querying the actual format, in which case an error
            /// is returned.
            pub fn get_internal_format(&self) -> Result<InternalFormat, GetFormatError> {
                self.0.get_internal_format()
            }
        

                /// Builds a new texture by uploading data.
                ///
                /// No mipmap level (except for the main level) will be allocator nor generated.
                pub fn new<'a, F, T>(facade: &F, data: Vec<T>)
                              -> Result<CompressedSrgbTexture1dArray, TextureCreationError>
                              where T: Texture1dDataSource<'a>, F: Facade
                {
                    CompressedSrgbTexture1dArray::new_impl(facade, data, None, CompressedMipmapsOption::NoMipmap)
                }
            

                /// Builds a new texture by uploading data.
                pub fn with_mipmaps<'a, F, T>(facade: &F, data: Vec<T>, mipmaps: CompressedMipmapsOption)
                                              -> Result<CompressedSrgbTexture1dArray, TextureCreationError>
                                              where T: Texture1dDataSource<'a>, F: Facade
                {
                    CompressedSrgbTexture1dArray::new_impl(facade, data, None, mipmaps)
                }
            

                /// Builds a new texture with a specific format. The input data must also be of the
                /// specified compressed format.
                pub fn with_compressed_data<F>(facade: &F, data: Vec<&[u8]>, width: u32, array_size: u32,
                                                      format: CompressedSrgbFormat, mipmaps: CompressedMipmapsOption)
                                                      -> Result<CompressedSrgbTexture1dArray, TextureCreationError>
                                                       where F: Facade
                {
                    let data = Cow::Borrowed(data.as_ref());
                    let client_format = ClientFormatAny::CompressedSrgbFormat(format);
                    Ok(CompressedSrgbTexture1dArray(try!(any::new_texture(facade, TextureFormatRequest::AnyCompressedSrgb, Some((client_format, data)),
                                                    mipmaps.to_regular(), Dimensions::Texture1dArray { width: width, array_size: array_size }))))
                }
            

                /// Builds a new texture with a specific format.
                pub fn with_format<'a, F, T>(facade: &F, data: Vec<T>,
                                          format: CompressedSrgbFormat, mipmaps: CompressedMipmapsOption)
                                          -> Result<CompressedSrgbTexture1dArray, TextureCreationError>
                                          where T: Texture1dDataSource<'a>, F: Facade
                {
                    CompressedSrgbTexture1dArray::new_impl(facade, data, Some(format), mipmaps)
                }
            

                fn new_impl<'a, F, T>(facade: &F, data: Vec<T>,
                                   format: Option<CompressedSrgbFormat>, mipmaps: CompressedMipmapsOption)
                                   -> Result<CompressedSrgbTexture1dArray, TextureCreationError>
                                   where T: Texture1dDataSource<'a>, F: Facade
                {
            
let format = format.map(|f| {
                           TextureFormatRequest::Specific(f.to_texture_format())
                       }).unwrap_or(TextureFormatRequest::AnyCompressedSrgb);
                    let vec_raw = data.into_iter().map(|e| e.into_raw()).collect();
                    let RawImage2d {data, width, height: array_size, format: client_format } = RawImage2d::from_vec_raw1d(&vec_raw);
                let client_format = ClientFormatAny::ClientFormat(client_format);Ok(CompressedSrgbTexture1dArray(try!(any::new_texture(facade, format, Some((client_format, data)), mipmaps.to_regular(), Dimensions::Texture1dArray { width: width, array_size: array_size }))))
}

                /// Creates an empty texture with a specific format.
                ///
                /// The texture (and its mipmaps) will contain undefined data.
                pub fn empty_with_format<F>(facade: &F, format: CompressedSrgbFormat, mipmaps: CompressedMipmapsOption, width: u32, array_size: u32) -> Result<CompressedSrgbTexture1dArray, TextureCreationError> where F: Facade {
                    let format = format.to_texture_format();
                    let format = TextureFormatRequest::Specific(format);
            
let t = any::new_texture::<_, u8>(facade, format, None, mipmaps.to_regular(), Dimensions::Texture1dArray { width: width, array_size: array_size });
            t.map(|t| CompressedSrgbTexture1dArray(t))
}

            /// Returns the number of mipmap levels of the texture.
            ///
            /// The minimum value is 1, since there is always a main texture.
            pub fn get_mipmap_levels(&self) -> u32 {
                self.0.get_mipmap_levels()
            }
        
            /// Turns the texture into a `ResidentTexture`.
            ///
            /// This allows you to use the texture in a much more efficient way by storing
            /// a "reference to it" in a buffer (actually not a reference but a raw pointer).
            ///
            /// See the documentation of `ResidentTexture` for more infos.
            pub fn resident(self) -> Result<ResidentTexture, BindlessTexturesNotSupportedError> {
                ResidentTexture::new(self.0)
            }
        
                /// Access a single layer of this texture.
                pub fn layer(&self, layer: u32) -> Option<CompressedSrgbTexture1dArrayLayer> {
                    if layer < self.0.get_array_size().unwrap_or(1) {
                        Some(CompressedSrgbTexture1dArrayLayer {
                            texture: self,
                            layer: layer,
                        })
                    } else {
                        None
                    }
                }
            }

                /// Represents a single layer of a `CompressedSrgbTexture1dArray`.
                ///
                /// Can be obtained by calling `CompressedSrgbTexture1dArray::layer()`.
                #[derive(Copy, Clone)]
                pub struct CompressedSrgbTexture1dArrayLayer<'t> {
                    texture: &'t CompressedSrgbTexture1dArray,
                    layer: u32,
                }
            impl<'t> CompressedSrgbTexture1dArrayLayer<'t> {

                /// Returns the corresponding texture.
                pub fn get_texture(&self) -> &'t CompressedSrgbTexture1dArray {
                    self.texture
                }

                /// Returns the layer index.
                pub fn get_layer(&self) -> u32 {
                    self.layer
                }
            
                /// Returns the number of mipmap levels of the texture.
                ///
                /// The minimum value is 1, since there is always a main texture.
                pub fn get_mipmap_levels(&self) -> u32 {
                    self.texture.get_mipmap_levels()
                }
            
                /// Access a single mipmap level of this layer.
                pub fn mipmap(&self, level: u32) -> Option<CompressedSrgbTexture1dArrayMipmap> {
                    self.texture.0.mipmap(self.layer, level).map(|m| CompressedSrgbTexture1dArrayMipmap(m, &self.texture))
                }
            
                /// Access the main mipmap level of this layer.
                pub fn main_level(&self) -> CompressedSrgbTexture1dArrayMipmap {
                    self.mipmap(0).unwrap()
                }
            }

                    /// Represents a single mipmap level of a `CompressedSrgbTexture1dArray`.
                    ///
                    /// Can be obtained by calling `CompressedSrgbTexture1dArrayLayer::mipmap()` or
                    /// `CompressedSrgbTexture1dArrayLayer::main_level()`.
                    #[derive(Copy, Clone)]
                    pub struct CompressedSrgbTexture1dArrayMipmap<'t>(TextureAnyMipmap<'t>, &'t CompressedSrgbTexture1dArray);
                impl<'t> CompressedSrgbTexture1dArrayMipmap<'t> {

                /// Returns the corresponding texture.
                pub fn get_texture(&self) -> &'t CompressedSrgbTexture1dArray {
                    self.1
                }

                /// Returns the texture level.
                pub fn get_level(&self) -> u32 {
                    self.0.get_level()
                }
            
                    /// Returns the layer index.
                    pub fn get_layer(&self) -> u32 {
                        self.0.get_layer()
                    }
                }
/// An array of one-dimensional textures  containing signed integral data.
pub struct IntegralTexture1dArray(TextureAny);

                impl Texture for IntegralTexture1dArray {
                    fn get_width(&self) -> u32 {
                        self.0.get_width()
                    }

                    fn get_height(&self) -> Option<u32> {
                        self.0.get_height()
                    }

                    fn get_depth(&self) -> Option<u32> {
                        self.0.get_depth()
                    }

                    fn get_array_size(&self) -> Option<u32> {
                        self.0.get_array_size()
                    }
                }
            

                impl GlObject for IntegralTexture1dArray {
                    type Id = gl::types::GLuint;
                    fn get_id(&self) -> gl::types::GLuint {
                        self.0.get_id()
                    }
                }
            

                impl ::std::fmt::Debug for IntegralTexture1dArray {
                    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> Result<(), ::std::fmt::Error>
                    {
                        self.0.fmt(f)
                    }
                }
            

                impl ::std::ops::Deref for IntegralTexture1dArray {
                    type Target = TextureAny;
                    
                    fn deref<'a>(&'a self) -> &'a TextureAny {
                        &self.0
                    }
                }
            

                            impl<'a> AsUniformValue for &'a IntegralTexture1dArray {
                                fn as_uniform_value(&self) -> UniformValue {
                                    UniformValue::IntegralTexture1dArray(*self, None)
                                }
                            }

                            impl<'a> AsUniformValue for Sampler<'a, IntegralTexture1dArray> {
                                fn as_uniform_value(&self) -> UniformValue {
                                    UniformValue::IntegralTexture1dArray(self.0, Some(self.1))
                                }
                            }

                            impl IntegralTexture1dArray {
                                /// Builds a `Sampler` marker object that allows you to indicate
                                /// how the texture should be sampled from inside a shader.
                                ///
                                /// # Example
                                ///
                                /// ```no_run
                                /// # #[macro_use] extern crate glium;
                                /// # fn main() {
                                /// # let texture: glium::texture::Texture2d = unsafe {
                                /// # ::std::mem::uninitialized() };
                                /// let uniforms = uniform! {
                                ///     color_texture: texture.sampled().magnify_filter(glium::uniforms::MagnifySamplerFilter::Nearest)
                                /// };
                                /// # }
                                /// ```
                                pub fn sampled(&self) -> Sampler<IntegralTexture1dArray> {
                                    Sampler(self, Default::default())
                                }
                            }
                        
impl IntegralTexture1dArray {

            /// Determines the internal format of this texture.
            ///
            /// The backend may not support querying the actual format, in which case an error
            /// is returned.
            pub fn get_internal_format(&self) -> Result<InternalFormat, GetFormatError> {
                self.0.get_internal_format()
            }
        

                /// Builds a new texture by uploading data.
                ///
                /// This function will automatically generate all mipmaps of the texture.
                pub fn new<'a, F, T>(facade: &F, data: Vec<T>)
                              -> Result<IntegralTexture1dArray, TextureCreationError>
                              where T: Texture1dDataSource<'a>, F: Facade
                {
                    IntegralTexture1dArray::new_impl(facade, data, None, MipmapsOption::AutoGeneratedMipmaps)
                }
            

                /// Builds a new texture by uploading data.
                pub fn with_mipmaps<'a, F, T>(facade: &F, data: Vec<T>, mipmaps: MipmapsOption)
                                              -> Result<IntegralTexture1dArray, TextureCreationError>
                                              where T: Texture1dDataSource<'a>, F: Facade
                {
                    IntegralTexture1dArray::new_impl(facade, data, None, mipmaps)
                }
            

                /// Builds a new texture with a specific format.
                pub fn with_format<'a, F, T>(facade: &F, data: Vec<T>,
                                          format: UncompressedIntFormat, mipmaps: MipmapsOption)
                                          -> Result<IntegralTexture1dArray, TextureCreationError>
                                          where T: Texture1dDataSource<'a>, F: Facade
                {
                    IntegralTexture1dArray::new_impl(facade, data, Some(format), mipmaps)
                }
            

                fn new_impl<'a, F, T>(facade: &F, data: Vec<T>,
                                   format: Option<UncompressedIntFormat>, mipmaps: MipmapsOption)
                                   -> Result<IntegralTexture1dArray, TextureCreationError>
                                   where T: Texture1dDataSource<'a>, F: Facade
                {
            
let format = format.map(|f| {
                           TextureFormatRequest::Specific(f.to_texture_format())
                       }).unwrap_or(TextureFormatRequest::AnyIntegral);
                    let vec_raw = data.into_iter().map(|e| e.into_raw()).collect();
                    let RawImage2d {data, width, height: array_size, format: client_format } = RawImage2d::from_vec_raw1d(&vec_raw);
                let client_format = ClientFormatAny::ClientFormat(client_format);Ok(IntegralTexture1dArray(try!(any::new_texture(facade, format, Some((client_format, data)), mipmaps.to_regular(), Dimensions::Texture1dArray { width: width, array_size: array_size }))))
}

                /// Creates an empty texture.
                ///
                /// No mipmap level (except for the main level) will be allocated or generated.
                ///
                /// The texture will contain undefined data.
                pub fn empty<F>(facade: &F, width: u32, array_size: u32)
                                -> Result<IntegralTexture1dArray, TextureCreationError>
                                where F: Facade
                {
                    let format = TextureFormatRequest::AnyIntegral;
            
any::new_texture::<_, u8>(facade, format, None, MipmapsOption::NoMipmap.to_regular(), Dimensions::Texture1dArray { width: width, array_size: array_size }).map(|t| IntegralTexture1dArray(t))}

                /// Creates an empty texture with a specific format.
                ///
                /// The texture (and its mipmaps) will contain undefined data.
                pub fn empty_with_format<F>(facade: &F, format: UncompressedIntFormat, mipmaps: MipmapsOption, width: u32, array_size: u32) -> Result<IntegralTexture1dArray, TextureCreationError> where F: Facade {
                    let format = format.to_texture_format();
                    let format = TextureFormatRequest::Specific(format);
            
let t = any::new_texture::<_, u8>(facade, format, None, mipmaps.to_regular(), Dimensions::Texture1dArray { width: width, array_size: array_size });
            t.map(|t| IntegralTexture1dArray(t))
}

                /// Creates an empty texture. Specifies whether is has mipmaps.
                ///
                /// The texture (and its mipmaps) will contain undefined data.
                pub fn empty_with_mipmaps<F>(facade: &F, mipmaps: MipmapsOption, width: u32, array_size: u32) -> Result<IntegralTexture1dArray, TextureCreationError> where F: Facade {
                    let format = TextureFormatRequest::AnyIntegral;
            
any::new_texture::<_, u8>(facade, format, None, mipmaps.to_regular(), Dimensions::Texture1dArray { width: width, array_size: array_size }).map(|t| IntegralTexture1dArray(t))
}

            /// Returns the number of mipmap levels of the texture.
            ///
            /// The minimum value is 1, since there is always a main texture.
            pub fn get_mipmap_levels(&self) -> u32 {
                self.0.get_mipmap_levels()
            }
        
            /// Turns the texture into a `ResidentTexture`.
            ///
            /// This allows you to use the texture in a much more efficient way by storing
            /// a "reference to it" in a buffer (actually not a reference but a raw pointer).
            ///
            /// See the documentation of `ResidentTexture` for more infos.
            pub fn resident(self) -> Result<ResidentTexture, BindlessTexturesNotSupportedError> {
                ResidentTexture::new(self.0)
            }
        
                /// Access a single layer of this texture.
                pub fn layer(&self, layer: u32) -> Option<IntegralTexture1dArrayLayer> {
                    if layer < self.0.get_array_size().unwrap_or(1) {
                        Some(IntegralTexture1dArrayLayer {
                            texture: self,
                            layer: layer,
                        })
                    } else {
                        None
                    }
                }
            }

                /// Represents a single layer of a `IntegralTexture1dArray`.
                ///
                /// Can be obtained by calling `IntegralTexture1dArray::layer()`.
                #[derive(Copy, Clone)]
                pub struct IntegralTexture1dArrayLayer<'t> {
                    texture: &'t IntegralTexture1dArray,
                    layer: u32,
                }
            impl<'t> IntegralTexture1dArrayLayer<'t> {

                /// Returns the corresponding texture.
                pub fn get_texture(&self) -> &'t IntegralTexture1dArray {
                    self.texture
                }

                /// Returns the layer index.
                pub fn get_layer(&self) -> u32 {
                    self.layer
                }
            
                /// Returns the number of mipmap levels of the texture.
                ///
                /// The minimum value is 1, since there is always a main texture.
                pub fn get_mipmap_levels(&self) -> u32 {
                    self.texture.get_mipmap_levels()
                }
            
                /// Access a single mipmap level of this layer.
                pub fn mipmap(&self, level: u32) -> Option<IntegralTexture1dArrayMipmap> {
                    self.texture.0.mipmap(self.layer, level).map(|m| IntegralTexture1dArrayMipmap(m, &self.texture))
                }
            
                /// Access the main mipmap level of this layer.
                pub fn main_level(&self) -> IntegralTexture1dArrayMipmap {
                    self.mipmap(0).unwrap()
                }
            }

                    /// Represents a single mipmap level of a `IntegralTexture1dArray`.
                    ///
                    /// Can be obtained by calling `IntegralTexture1dArrayLayer::mipmap()` or
                    /// `IntegralTexture1dArrayLayer::main_level()`.
                    #[derive(Copy, Clone)]
                    pub struct IntegralTexture1dArrayMipmap<'t>(TextureAnyMipmap<'t>, &'t IntegralTexture1dArray);
                impl<'t> IntegralTexture1dArrayMipmap<'t> {

                /// Returns the corresponding texture.
                pub fn get_texture(&self) -> &'t IntegralTexture1dArray {
                    self.1
                }

                /// Returns the texture level.
                pub fn get_level(&self) -> u32 {
                    self.0.get_level()
                }
            
                    /// Returns the layer index.
                    pub fn get_layer(&self) -> u32 {
                        self.0.get_layer()
                    }
                }
/// An array of one-dimensional textures  containing unsigned integral data.
pub struct UnsignedTexture1dArray(TextureAny);

                impl Texture for UnsignedTexture1dArray {
                    fn get_width(&self) -> u32 {
                        self.0.get_width()
                    }

                    fn get_height(&self) -> Option<u32> {
                        self.0.get_height()
                    }

                    fn get_depth(&self) -> Option<u32> {
                        self.0.get_depth()
                    }

                    fn get_array_size(&self) -> Option<u32> {
                        self.0.get_array_size()
                    }
                }
            

                impl GlObject for UnsignedTexture1dArray {
                    type Id = gl::types::GLuint;
                    fn get_id(&self) -> gl::types::GLuint {
                        self.0.get_id()
                    }
                }
            

                impl ::std::fmt::Debug for UnsignedTexture1dArray {
                    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> Result<(), ::std::fmt::Error>
                    {
                        self.0.fmt(f)
                    }
                }
            

                impl ::std::ops::Deref for UnsignedTexture1dArray {
                    type Target = TextureAny;
                    
                    fn deref<'a>(&'a self) -> &'a TextureAny {
                        &self.0
                    }
                }
            

                            impl<'a> AsUniformValue for &'a UnsignedTexture1dArray {
                                fn as_uniform_value(&self) -> UniformValue {
                                    UniformValue::UnsignedTexture1dArray(*self, None)
                                }
                            }

                            impl<'a> AsUniformValue for Sampler<'a, UnsignedTexture1dArray> {
                                fn as_uniform_value(&self) -> UniformValue {
                                    UniformValue::UnsignedTexture1dArray(self.0, Some(self.1))
                                }
                            }

                            impl UnsignedTexture1dArray {
                                /// Builds a `Sampler` marker object that allows you to indicate
                                /// how the texture should be sampled from inside a shader.
                                ///
                                /// # Example
                                ///
                                /// ```no_run
                                /// # #[macro_use] extern crate glium;
                                /// # fn main() {
                                /// # let texture: glium::texture::Texture2d = unsafe {
                                /// # ::std::mem::uninitialized() };
                                /// let uniforms = uniform! {
                                ///     color_texture: texture.sampled().magnify_filter(glium::uniforms::MagnifySamplerFilter::Nearest)
                                /// };
                                /// # }
                                /// ```
                                pub fn sampled(&self) -> Sampler<UnsignedTexture1dArray> {
                                    Sampler(self, Default::default())
                                }
                            }
                        
impl UnsignedTexture1dArray {

            /// Determines the internal format of this texture.
            ///
            /// The backend may not support querying the actual format, in which case an error
            /// is returned.
            pub fn get_internal_format(&self) -> Result<InternalFormat, GetFormatError> {
                self.0.get_internal_format()
            }
        

                /// Builds a new texture by uploading data.
                ///
                /// This function will automatically generate all mipmaps of the texture.
                pub fn new<'a, F, T>(facade: &F, data: Vec<T>)
                              -> Result<UnsignedTexture1dArray, TextureCreationError>
                              where T: Texture1dDataSource<'a>, F: Facade
                {
                    UnsignedTexture1dArray::new_impl(facade, data, None, MipmapsOption::AutoGeneratedMipmaps)
                }
            

                /// Builds a new texture by uploading data.
                pub fn with_mipmaps<'a, F, T>(facade: &F, data: Vec<T>, mipmaps: MipmapsOption)
                                              -> Result<UnsignedTexture1dArray, TextureCreationError>
                                              where T: Texture1dDataSource<'a>, F: Facade
                {
                    UnsignedTexture1dArray::new_impl(facade, data, None, mipmaps)
                }
            

                /// Builds a new texture with a specific format.
                pub fn with_format<'a, F, T>(facade: &F, data: Vec<T>,
                                          format: UncompressedUintFormat, mipmaps: MipmapsOption)
                                          -> Result<UnsignedTexture1dArray, TextureCreationError>
                                          where T: Texture1dDataSource<'a>, F: Facade
                {
                    UnsignedTexture1dArray::new_impl(facade, data, Some(format), mipmaps)
                }
            

                fn new_impl<'a, F, T>(facade: &F, data: Vec<T>,
                                   format: Option<UncompressedUintFormat>, mipmaps: MipmapsOption)
                                   -> Result<UnsignedTexture1dArray, TextureCreationError>
                                   where T: Texture1dDataSource<'a>, F: Facade
                {
            
let format = format.map(|f| {
                           TextureFormatRequest::Specific(f.to_texture_format())
                       }).unwrap_or(TextureFormatRequest::AnyUnsigned);
                    let vec_raw = data.into_iter().map(|e| e.into_raw()).collect();
                    let RawImage2d {data, width, height: array_size, format: client_format } = RawImage2d::from_vec_raw1d(&vec_raw);
                let client_format = ClientFormatAny::ClientFormat(client_format);Ok(UnsignedTexture1dArray(try!(any::new_texture(facade, format, Some((client_format, data)), mipmaps.to_regular(), Dimensions::Texture1dArray { width: width, array_size: array_size }))))
}

                /// Creates an empty texture.
                ///
                /// No mipmap level (except for the main level) will be allocated or generated.
                ///
                /// The texture will contain undefined data.
                pub fn empty<F>(facade: &F, width: u32, array_size: u32)
                                -> Result<UnsignedTexture1dArray, TextureCreationError>
                                where F: Facade
                {
                    let format = TextureFormatRequest::AnyUnsigned;
            
any::new_texture::<_, u8>(facade, format, None, MipmapsOption::NoMipmap.to_regular(), Dimensions::Texture1dArray { width: width, array_size: array_size }).map(|t| UnsignedTexture1dArray(t))}

                /// Creates an empty texture with a specific format.
                ///
                /// The texture (and its mipmaps) will contain undefined data.
                pub fn empty_with_format<F>(facade: &F, format: UncompressedUintFormat, mipmaps: MipmapsOption, width: u32, array_size: u32) -> Result<UnsignedTexture1dArray, TextureCreationError> where F: Facade {
                    let format = format.to_texture_format();
                    let format = TextureFormatRequest::Specific(format);
            
let t = any::new_texture::<_, u8>(facade, format, None, mipmaps.to_regular(), Dimensions::Texture1dArray { width: width, array_size: array_size });
            t.map(|t| UnsignedTexture1dArray(t))
}

                /// Creates an empty texture. Specifies whether is has mipmaps.
                ///
                /// The texture (and its mipmaps) will contain undefined data.
                pub fn empty_with_mipmaps<F>(facade: &F, mipmaps: MipmapsOption, width: u32, array_size: u32) -> Result<UnsignedTexture1dArray, TextureCreationError> where F: Facade {
                    let format = TextureFormatRequest::AnyUnsigned;
            
any::new_texture::<_, u8>(facade, format, None, mipmaps.to_regular(), Dimensions::Texture1dArray { width: width, array_size: array_size }).map(|t| UnsignedTexture1dArray(t))
}

            /// Returns the number of mipmap levels of the texture.
            ///
            /// The minimum value is 1, since there is always a main texture.
            pub fn get_mipmap_levels(&self) -> u32 {
                self.0.get_mipmap_levels()
            }
        
            /// Turns the texture into a `ResidentTexture`.
            ///
            /// This allows you to use the texture in a much more efficient way by storing
            /// a "reference to it" in a buffer (actually not a reference but a raw pointer).
            ///
            /// See the documentation of `ResidentTexture` for more infos.
            pub fn resident(self) -> Result<ResidentTexture, BindlessTexturesNotSupportedError> {
                ResidentTexture::new(self.0)
            }
        
                /// Access a single layer of this texture.
                pub fn layer(&self, layer: u32) -> Option<UnsignedTexture1dArrayLayer> {
                    if layer < self.0.get_array_size().unwrap_or(1) {
                        Some(UnsignedTexture1dArrayLayer {
                            texture: self,
                            layer: layer,
                        })
                    } else {
                        None
                    }
                }
            }

                /// Represents a single layer of a `UnsignedTexture1dArray`.
                ///
                /// Can be obtained by calling `UnsignedTexture1dArray::layer()`.
                #[derive(Copy, Clone)]
                pub struct UnsignedTexture1dArrayLayer<'t> {
                    texture: &'t UnsignedTexture1dArray,
                    layer: u32,
                }
            impl<'t> UnsignedTexture1dArrayLayer<'t> {

                /// Returns the corresponding texture.
                pub fn get_texture(&self) -> &'t UnsignedTexture1dArray {
                    self.texture
                }

                /// Returns the layer index.
                pub fn get_layer(&self) -> u32 {
                    self.layer
                }
            
                /// Returns the number of mipmap levels of the texture.
                ///
                /// The minimum value is 1, since there is always a main texture.
                pub fn get_mipmap_levels(&self) -> u32 {
                    self.texture.get_mipmap_levels()
                }
            
                /// Access a single mipmap level of this layer.
                pub fn mipmap(&self, level: u32) -> Option<UnsignedTexture1dArrayMipmap> {
                    self.texture.0.mipmap(self.layer, level).map(|m| UnsignedTexture1dArrayMipmap(m, &self.texture))
                }
            
                /// Access the main mipmap level of this layer.
                pub fn main_level(&self) -> UnsignedTexture1dArrayMipmap {
                    self.mipmap(0).unwrap()
                }
            }

                    /// Represents a single mipmap level of a `UnsignedTexture1dArray`.
                    ///
                    /// Can be obtained by calling `UnsignedTexture1dArrayLayer::mipmap()` or
                    /// `UnsignedTexture1dArrayLayer::main_level()`.
                    #[derive(Copy, Clone)]
                    pub struct UnsignedTexture1dArrayMipmap<'t>(TextureAnyMipmap<'t>, &'t UnsignedTexture1dArray);
                impl<'t> UnsignedTexture1dArrayMipmap<'t> {

                /// Returns the corresponding texture.
                pub fn get_texture(&self) -> &'t UnsignedTexture1dArray {
                    self.1
                }

                /// Returns the texture level.
                pub fn get_level(&self) -> u32 {
                    self.0.get_level()
                }
            
                    /// Returns the layer index.
                    pub fn get_layer(&self) -> u32 {
                        self.0.get_layer()
                    }
                }
/// An array of one-dimensional textures  containing depth data.
pub struct DepthTexture1dArray(TextureAny);

                impl Texture for DepthTexture1dArray {
                    fn get_width(&self) -> u32 {
                        self.0.get_width()
                    }

                    fn get_height(&self) -> Option<u32> {
                        self.0.get_height()
                    }

                    fn get_depth(&self) -> Option<u32> {
                        self.0.get_depth()
                    }

                    fn get_array_size(&self) -> Option<u32> {
                        self.0.get_array_size()
                    }
                }
            

                impl GlObject for DepthTexture1dArray {
                    type Id = gl::types::GLuint;
                    fn get_id(&self) -> gl::types::GLuint {
                        self.0.get_id()
                    }
                }
            

                impl ::std::fmt::Debug for DepthTexture1dArray {
                    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> Result<(), ::std::fmt::Error>
                    {
                        self.0.fmt(f)
                    }
                }
            

                impl ::std::ops::Deref for DepthTexture1dArray {
                    type Target = TextureAny;
                    
                    fn deref<'a>(&'a self) -> &'a TextureAny {
                        &self.0
                    }
                }
            

                            impl<'a> AsUniformValue for &'a DepthTexture1dArray {
                                fn as_uniform_value(&self) -> UniformValue {
                                    UniformValue::DepthTexture1dArray(*self, None)
                                }
                            }

                            impl<'a> AsUniformValue for Sampler<'a, DepthTexture1dArray> {
                                fn as_uniform_value(&self) -> UniformValue {
                                    UniformValue::DepthTexture1dArray(self.0, Some(self.1))
                                }
                            }

                            impl DepthTexture1dArray {
                                /// Builds a `Sampler` marker object that allows you to indicate
                                /// how the texture should be sampled from inside a shader.
                                ///
                                /// # Example
                                ///
                                /// ```no_run
                                /// # #[macro_use] extern crate glium;
                                /// # fn main() {
                                /// # let texture: glium::texture::Texture2d = unsafe {
                                /// # ::std::mem::uninitialized() };
                                /// let uniforms = uniform! {
                                ///     color_texture: texture.sampled().magnify_filter(glium::uniforms::MagnifySamplerFilter::Nearest)
                                /// };
                                /// # }
                                /// ```
                                pub fn sampled(&self) -> Sampler<DepthTexture1dArray> {
                                    Sampler(self, Default::default())
                                }
                            }
                        
impl DepthTexture1dArray {

            /// Determines the internal format of this texture.
            ///
            /// The backend may not support querying the actual format, in which case an error
            /// is returned.
            pub fn get_internal_format(&self) -> Result<InternalFormat, GetFormatError> {
                self.0.get_internal_format()
            }
        

                /// Builds a new texture by uploading data.
                ///
                /// This function will automatically generate all mipmaps of the texture.
                pub fn new<'a, F, T>(facade: &F, data: Vec<T>)
                              -> Result<DepthTexture1dArray, TextureCreationError>
                              where T: Texture1dDataSource<'a>, F: Facade
                {
                    DepthTexture1dArray::new_impl(facade, data, None, MipmapsOption::AutoGeneratedMipmaps)
                }
            

                /// Builds a new texture by uploading data.
                pub fn with_mipmaps<'a, F, T>(facade: &F, data: Vec<T>, mipmaps: MipmapsOption)
                                              -> Result<DepthTexture1dArray, TextureCreationError>
                                              where T: Texture1dDataSource<'a>, F: Facade
                {
                    DepthTexture1dArray::new_impl(facade, data, None, mipmaps)
                }
            

                /// Builds a new texture with a specific format.
                pub fn with_format<'a, F, T>(facade: &F, data: Vec<T>,
                                          format: DepthFormat, mipmaps: MipmapsOption)
                                          -> Result<DepthTexture1dArray, TextureCreationError>
                                          where T: Texture1dDataSource<'a>, F: Facade
                {
                    DepthTexture1dArray::new_impl(facade, data, Some(format), mipmaps)
                }
            

                fn new_impl<'a, F, T>(facade: &F, data: Vec<T>,
                                   format: Option<DepthFormat>, mipmaps: MipmapsOption)
                                   -> Result<DepthTexture1dArray, TextureCreationError>
                                   where T: Texture1dDataSource<'a>, F: Facade
                {
            
let format = format.map(|f| {
                           TextureFormatRequest::Specific(f.to_texture_format())
                       }).unwrap_or(TextureFormatRequest::AnyDepth);
                    let vec_raw = data.into_iter().map(|e| e.into_raw()).collect();
                    let RawImage2d {data, width, height: array_size, format: client_format } = RawImage2d::from_vec_raw1d(&vec_raw);
                let client_format = ClientFormatAny::ClientFormat(client_format);Ok(DepthTexture1dArray(try!(any::new_texture(facade, format, Some((client_format, data)), mipmaps.to_regular(), Dimensions::Texture1dArray { width: width, array_size: array_size }))))
}

                /// Creates an empty texture.
                ///
                /// No mipmap level (except for the main level) will be allocated or generated.
                ///
                /// The texture will contain undefined data.
                pub fn empty<F>(facade: &F, width: u32, array_size: u32)
                                -> Result<DepthTexture1dArray, TextureCreationError>
                                where F: Facade
                {
                    let format = TextureFormatRequest::AnyDepth;
            
any::new_texture::<_, u8>(facade, format, None, MipmapsOption::NoMipmap.to_regular(), Dimensions::Texture1dArray { width: width, array_size: array_size }).map(|t| DepthTexture1dArray(t))}

                /// Creates an empty texture with a specific format.
                ///
                /// The texture (and its mipmaps) will contain undefined data.
                pub fn empty_with_format<F>(facade: &F, format: DepthFormat, mipmaps: MipmapsOption, width: u32, array_size: u32) -> Result<DepthTexture1dArray, TextureCreationError> where F: Facade {
                    let format = format.to_texture_format();
                    let format = TextureFormatRequest::Specific(format);
            
let t = any::new_texture::<_, u8>(facade, format, None, mipmaps.to_regular(), Dimensions::Texture1dArray { width: width, array_size: array_size });
            t.map(|t| DepthTexture1dArray(t))
}

                /// Creates an empty texture. Specifies whether is has mipmaps.
                ///
                /// The texture (and its mipmaps) will contain undefined data.
                pub fn empty_with_mipmaps<F>(facade: &F, mipmaps: MipmapsOption, width: u32, array_size: u32) -> Result<DepthTexture1dArray, TextureCreationError> where F: Facade {
                    let format = TextureFormatRequest::AnyDepth;
            
any::new_texture::<_, u8>(facade, format, None, mipmaps.to_regular(), Dimensions::Texture1dArray { width: width, array_size: array_size }).map(|t| DepthTexture1dArray(t))
}

            /// Returns the number of mipmap levels of the texture.
            ///
            /// The minimum value is 1, since there is always a main texture.
            pub fn get_mipmap_levels(&self) -> u32 {
                self.0.get_mipmap_levels()
            }
        
            /// Turns the texture into a `ResidentTexture`.
            ///
            /// This allows you to use the texture in a much more efficient way by storing
            /// a "reference to it" in a buffer (actually not a reference but a raw pointer).
            ///
            /// See the documentation of `ResidentTexture` for more infos.
            pub fn resident(self) -> Result<ResidentTexture, BindlessTexturesNotSupportedError> {
                ResidentTexture::new(self.0)
            }
        
                /// Access a single layer of this texture.
                pub fn layer(&self, layer: u32) -> Option<DepthTexture1dArrayLayer> {
                    if layer < self.0.get_array_size().unwrap_or(1) {
                        Some(DepthTexture1dArrayLayer {
                            texture: self,
                            layer: layer,
                        })
                    } else {
                        None
                    }
                }
            }

                /// Represents a single layer of a `DepthTexture1dArray`.
                ///
                /// Can be obtained by calling `DepthTexture1dArray::layer()`.
                #[derive(Copy, Clone)]
                pub struct DepthTexture1dArrayLayer<'t> {
                    texture: &'t DepthTexture1dArray,
                    layer: u32,
                }
            impl<'t> DepthTexture1dArrayLayer<'t> {

                /// Returns the corresponding texture.
                pub fn get_texture(&self) -> &'t DepthTexture1dArray {
                    self.texture
                }

                /// Returns the layer index.
                pub fn get_layer(&self) -> u32 {
                    self.layer
                }
            
                /// Returns the number of mipmap levels of the texture.
                ///
                /// The minimum value is 1, since there is always a main texture.
                pub fn get_mipmap_levels(&self) -> u32 {
                    self.texture.get_mipmap_levels()
                }
            
                /// Access a single mipmap level of this layer.
                pub fn mipmap(&self, level: u32) -> Option<DepthTexture1dArrayMipmap> {
                    self.texture.0.mipmap(self.layer, level).map(|m| DepthTexture1dArrayMipmap(m, &self.texture))
                }
            
                /// Access the main mipmap level of this layer.
                pub fn main_level(&self) -> DepthTexture1dArrayMipmap {
                    self.mipmap(0).unwrap()
                }
            }

                    /// Represents a single mipmap level of a `DepthTexture1dArray`.
                    ///
                    /// Can be obtained by calling `DepthTexture1dArrayLayer::mipmap()` or
                    /// `DepthTexture1dArrayLayer::main_level()`.
                    #[derive(Copy, Clone)]
                    pub struct DepthTexture1dArrayMipmap<'t>(TextureAnyMipmap<'t>, &'t DepthTexture1dArray);
                impl<'t> DepthTexture1dArrayMipmap<'t> {

                /// Returns the corresponding texture.
                pub fn get_texture(&self) -> &'t DepthTexture1dArray {
                    self.1
                }

                /// Returns the texture level.
                pub fn get_level(&self) -> u32 {
                    self.0.get_level()
                }
            
                    /// Returns the layer index.
                    pub fn get_layer(&self) -> u32 {
                        self.0.get_layer()
                    }
                }
/// An array of one-dimensional textures  containing stencil data.
pub struct StencilTexture1dArray(TextureAny);

                impl Texture for StencilTexture1dArray {
                    fn get_width(&self) -> u32 {
                        self.0.get_width()
                    }

                    fn get_height(&self) -> Option<u32> {
                        self.0.get_height()
                    }

                    fn get_depth(&self) -> Option<u32> {
                        self.0.get_depth()
                    }

                    fn get_array_size(&self) -> Option<u32> {
                        self.0.get_array_size()
                    }
                }
            

                impl GlObject for StencilTexture1dArray {
                    type Id = gl::types::GLuint;
                    fn get_id(&self) -> gl::types::GLuint {
                        self.0.get_id()
                    }
                }
            

                impl ::std::fmt::Debug for StencilTexture1dArray {
                    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> Result<(), ::std::fmt::Error>
                    {
                        self.0.fmt(f)
                    }
                }
            

                impl ::std::ops::Deref for StencilTexture1dArray {
                    type Target = TextureAny;
                    
                    fn deref<'a>(&'a self) -> &'a TextureAny {
                        &self.0
                    }
                }
            
impl StencilTexture1dArray {

            /// Determines the internal format of this texture.
            ///
            /// The backend may not support querying the actual format, in which case an error
            /// is returned.
            pub fn get_internal_format(&self) -> Result<InternalFormat, GetFormatError> {
                self.0.get_internal_format()
            }
        

                /// Builds a new texture by uploading data.
                ///
                /// This function will automatically generate all mipmaps of the texture.
                pub fn new<'a, F, T>(facade: &F, data: Vec<T>)
                              -> Result<StencilTexture1dArray, TextureCreationError>
                              where T: Texture1dDataSource<'a>, F: Facade
                {
                    StencilTexture1dArray::new_impl(facade, data, None, MipmapsOption::AutoGeneratedMipmaps)
                }
            

                /// Builds a new texture by uploading data.
                pub fn with_mipmaps<'a, F, T>(facade: &F, data: Vec<T>, mipmaps: MipmapsOption)
                                              -> Result<StencilTexture1dArray, TextureCreationError>
                                              where T: Texture1dDataSource<'a>, F: Facade
                {
                    StencilTexture1dArray::new_impl(facade, data, None, mipmaps)
                }
            

                /// Builds a new texture with a specific format.
                pub fn with_format<'a, F, T>(facade: &F, data: Vec<T>,
                                          format: StencilFormat, mipmaps: MipmapsOption)
                                          -> Result<StencilTexture1dArray, TextureCreationError>
                                          where T: Texture1dDataSource<'a>, F: Facade
                {
                    StencilTexture1dArray::new_impl(facade, data, Some(format), mipmaps)
                }
            

                fn new_impl<'a, F, T>(facade: &F, data: Vec<T>,
                                   format: Option<StencilFormat>, mipmaps: MipmapsOption)
                                   -> Result<StencilTexture1dArray, TextureCreationError>
                                   where T: Texture1dDataSource<'a>, F: Facade
                {
            
let format = format.map(|f| {
                           TextureFormatRequest::Specific(f.to_texture_format())
                       }).unwrap_or(TextureFormatRequest::AnyStencil);
                    let vec_raw = data.into_iter().map(|e| e.into_raw()).collect();
                    let RawImage2d {data, width, height: array_size, format: client_format } = RawImage2d::from_vec_raw1d(&vec_raw);
                let client_format = ClientFormatAny::ClientFormat(client_format);Ok(StencilTexture1dArray(try!(any::new_texture(facade, format, Some((client_format, data)), mipmaps.to_regular(), Dimensions::Texture1dArray { width: width, array_size: array_size }))))
}

                /// Creates an empty texture.
                ///
                /// No mipmap level (except for the main level) will be allocated or generated.
                ///
                /// The texture will contain undefined data.
                pub fn empty<F>(facade: &F, width: u32, array_size: u32)
                                -> Result<StencilTexture1dArray, TextureCreationError>
                                where F: Facade
                {
                    let format = TextureFormatRequest::AnyStencil;
            
any::new_texture::<_, u8>(facade, format, None, MipmapsOption::NoMipmap.to_regular(), Dimensions::Texture1dArray { width: width, array_size: array_size }).map(|t| StencilTexture1dArray(t))}

                /// Creates an empty texture with a specific format.
                ///
                /// The texture (and its mipmaps) will contain undefined data.
                pub fn empty_with_format<F>(facade: &F, format: StencilFormat, mipmaps: MipmapsOption, width: u32, array_size: u32) -> Result<StencilTexture1dArray, TextureCreationError> where F: Facade {
                    let format = format.to_texture_format();
                    let format = TextureFormatRequest::Specific(format);
            
let t = any::new_texture::<_, u8>(facade, format, None, mipmaps.to_regular(), Dimensions::Texture1dArray { width: width, array_size: array_size });
            t.map(|t| StencilTexture1dArray(t))
}

                /// Creates an empty texture. Specifies whether is has mipmaps.
                ///
                /// The texture (and its mipmaps) will contain undefined data.
                pub fn empty_with_mipmaps<F>(facade: &F, mipmaps: MipmapsOption, width: u32, array_size: u32) -> Result<StencilTexture1dArray, TextureCreationError> where F: Facade {
                    let format = TextureFormatRequest::AnyStencil;
            
any::new_texture::<_, u8>(facade, format, None, mipmaps.to_regular(), Dimensions::Texture1dArray { width: width, array_size: array_size }).map(|t| StencilTexture1dArray(t))
}

            /// Returns the number of mipmap levels of the texture.
            ///
            /// The minimum value is 1, since there is always a main texture.
            pub fn get_mipmap_levels(&self) -> u32 {
                self.0.get_mipmap_levels()
            }
        
            /// Turns the texture into a `ResidentTexture`.
            ///
            /// This allows you to use the texture in a much more efficient way by storing
            /// a "reference to it" in a buffer (actually not a reference but a raw pointer).
            ///
            /// See the documentation of `ResidentTexture` for more infos.
            pub fn resident(self) -> Result<ResidentTexture, BindlessTexturesNotSupportedError> {
                ResidentTexture::new(self.0)
            }
        
                /// Access a single layer of this texture.
                pub fn layer(&self, layer: u32) -> Option<StencilTexture1dArrayLayer> {
                    if layer < self.0.get_array_size().unwrap_or(1) {
                        Some(StencilTexture1dArrayLayer {
                            texture: self,
                            layer: layer,
                        })
                    } else {
                        None
                    }
                }
            }

                /// Represents a single layer of a `StencilTexture1dArray`.
                ///
                /// Can be obtained by calling `StencilTexture1dArray::layer()`.
                #[derive(Copy, Clone)]
                pub struct StencilTexture1dArrayLayer<'t> {
                    texture: &'t StencilTexture1dArray,
                    layer: u32,
                }
            impl<'t> StencilTexture1dArrayLayer<'t> {

                /// Returns the corresponding texture.
                pub fn get_texture(&self) -> &'t StencilTexture1dArray {
                    self.texture
                }

                /// Returns the layer index.
                pub fn get_layer(&self) -> u32 {
                    self.layer
                }
            
                /// Returns the number of mipmap levels of the texture.
                ///
                /// The minimum value is 1, since there is always a main texture.
                pub fn get_mipmap_levels(&self) -> u32 {
                    self.texture.get_mipmap_levels()
                }
            
                /// Access a single mipmap level of this layer.
                pub fn mipmap(&self, level: u32) -> Option<StencilTexture1dArrayMipmap> {
                    self.texture.0.mipmap(self.layer, level).map(|m| StencilTexture1dArrayMipmap(m, &self.texture))
                }
            
                /// Access the main mipmap level of this layer.
                pub fn main_level(&self) -> StencilTexture1dArrayMipmap {
                    self.mipmap(0).unwrap()
                }
            }

                    /// Represents a single mipmap level of a `StencilTexture1dArray`.
                    ///
                    /// Can be obtained by calling `StencilTexture1dArrayLayer::mipmap()` or
                    /// `StencilTexture1dArrayLayer::main_level()`.
                    #[derive(Copy, Clone)]
                    pub struct StencilTexture1dArrayMipmap<'t>(TextureAnyMipmap<'t>, &'t StencilTexture1dArray);
                impl<'t> StencilTexture1dArrayMipmap<'t> {

                /// Returns the corresponding texture.
                pub fn get_texture(&self) -> &'t StencilTexture1dArray {
                    self.1
                }

                /// Returns the texture level.
                pub fn get_level(&self) -> u32 {
                    self.0.get_level()
                }
            
                    /// Returns the layer index.
                    pub fn get_layer(&self) -> u32 {
                        self.0.get_layer()
                    }
                }
/// An array of one-dimensional textures  containing both depth and stencil data.
pub struct DepthStencilTexture1dArray(TextureAny);

                impl Texture for DepthStencilTexture1dArray {
                    fn get_width(&self) -> u32 {
                        self.0.get_width()
                    }

                    fn get_height(&self) -> Option<u32> {
                        self.0.get_height()
                    }

                    fn get_depth(&self) -> Option<u32> {
                        self.0.get_depth()
                    }

                    fn get_array_size(&self) -> Option<u32> {
                        self.0.get_array_size()
                    }
                }
            

                impl GlObject for DepthStencilTexture1dArray {
                    type Id = gl::types::GLuint;
                    fn get_id(&self) -> gl::types::GLuint {
                        self.0.get_id()
                    }
                }
            

                impl ::std::fmt::Debug for DepthStencilTexture1dArray {
                    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> Result<(), ::std::fmt::Error>
                    {
                        self.0.fmt(f)
                    }
                }
            

                impl ::std::ops::Deref for DepthStencilTexture1dArray {
                    type Target = TextureAny;
                    
                    fn deref<'a>(&'a self) -> &'a TextureAny {
                        &self.0
                    }
                }
            
impl DepthStencilTexture1dArray {

            /// Determines the internal format of this texture.
            ///
            /// The backend may not support querying the actual format, in which case an error
            /// is returned.
            pub fn get_internal_format(&self) -> Result<InternalFormat, GetFormatError> {
                self.0.get_internal_format()
            }
        

                /// Builds a new texture by uploading data.
                ///
                /// This function will automatically generate all mipmaps of the texture.
                pub fn new<'a, F, T>(facade: &F, data: Vec<T>)
                              -> Result<DepthStencilTexture1dArray, TextureCreationError>
                              where T: Texture1dDataSource<'a>, F: Facade
                {
                    DepthStencilTexture1dArray::new_impl(facade, data, None, MipmapsOption::AutoGeneratedMipmaps)
                }
            

                /// Builds a new texture by uploading data.
                pub fn with_mipmaps<'a, F, T>(facade: &F, data: Vec<T>, mipmaps: MipmapsOption)
                                              -> Result<DepthStencilTexture1dArray, TextureCreationError>
                                              where T: Texture1dDataSource<'a>, F: Facade
                {
                    DepthStencilTexture1dArray::new_impl(facade, data, None, mipmaps)
                }
            

                /// Builds a new texture with a specific format.
                pub fn with_format<'a, F, T>(facade: &F, data: Vec<T>,
                                          format: DepthStencilFormat, mipmaps: MipmapsOption)
                                          -> Result<DepthStencilTexture1dArray, TextureCreationError>
                                          where T: Texture1dDataSource<'a>, F: Facade
                {
                    DepthStencilTexture1dArray::new_impl(facade, data, Some(format), mipmaps)
                }
            

                fn new_impl<'a, F, T>(facade: &F, data: Vec<T>,
                                   format: Option<DepthStencilFormat>, mipmaps: MipmapsOption)
                                   -> Result<DepthStencilTexture1dArray, TextureCreationError>
                                   where T: Texture1dDataSource<'a>, F: Facade
                {
            
let format = format.map(|f| {
                           TextureFormatRequest::Specific(f.to_texture_format())
                       }).unwrap_or(TextureFormatRequest::AnyDepthStencil);
                    let vec_raw = data.into_iter().map(|e| e.into_raw()).collect();
                    let RawImage2d {data, width, height: array_size, format: client_format } = RawImage2d::from_vec_raw1d(&vec_raw);
                let client_format = ClientFormatAny::ClientFormat(client_format);Ok(DepthStencilTexture1dArray(try!(any::new_texture(facade, format, Some((client_format, data)), mipmaps.to_regular(), Dimensions::Texture1dArray { width: width, array_size: array_size }))))
}

                /// Creates an empty texture.
                ///
                /// No mipmap level (except for the main level) will be allocated or generated.
                ///
                /// The texture will contain undefined data.
                pub fn empty<F>(facade: &F, width: u32, array_size: u32)
                                -> Result<DepthStencilTexture1dArray, TextureCreationError>
                                where F: Facade
                {
                    let format = TextureFormatRequest::AnyDepthStencil;
            
any::new_texture::<_, u8>(facade, format, None, MipmapsOption::NoMipmap.to_regular(), Dimensions::Texture1dArray { width: width, array_size: array_size }).map(|t| DepthStencilTexture1dArray(t))}

                /// Creates an empty texture with a specific format.
                ///
                /// The texture (and its mipmaps) will contain undefined data.
                pub fn empty_with_format<F>(facade: &F, format: DepthStencilFormat, mipmaps: MipmapsOption, width: u32, array_size: u32) -> Result<DepthStencilTexture1dArray, TextureCreationError> where F: Facade {
                    let format = format.to_texture_format();
                    let format = TextureFormatRequest::Specific(format);
            
let t = any::new_texture::<_, u8>(facade, format, None, mipmaps.to_regular(), Dimensions::Texture1dArray { width: width, array_size: array_size });
            t.map(|t| DepthStencilTexture1dArray(t))
}

                /// Creates an empty texture. Specifies whether is has mipmaps.
                ///
                /// The texture (and its mipmaps) will contain undefined data.
                pub fn empty_with_mipmaps<F>(facade: &F, mipmaps: MipmapsOption, width: u32, array_size: u32) -> Result<DepthStencilTexture1dArray, TextureCreationError> where F: Facade {
                    let format = TextureFormatRequest::AnyDepthStencil;
            
any::new_texture::<_, u8>(facade, format, None, mipmaps.to_regular(), Dimensions::Texture1dArray { width: width, array_size: array_size }).map(|t| DepthStencilTexture1dArray(t))
}

            /// Returns the number of mipmap levels of the texture.
            ///
            /// The minimum value is 1, since there is always a main texture.
            pub fn get_mipmap_levels(&self) -> u32 {
                self.0.get_mipmap_levels()
            }
        
            /// Turns the texture into a `ResidentTexture`.
            ///
            /// This allows you to use the texture in a much more efficient way by storing
            /// a "reference to it" in a buffer (actually not a reference but a raw pointer).
            ///
            /// See the documentation of `ResidentTexture` for more infos.
            pub fn resident(self) -> Result<ResidentTexture, BindlessTexturesNotSupportedError> {
                ResidentTexture::new(self.0)
            }
        
                /// Access a single layer of this texture.
                pub fn layer(&self, layer: u32) -> Option<DepthStencilTexture1dArrayLayer> {
                    if layer < self.0.get_array_size().unwrap_or(1) {
                        Some(DepthStencilTexture1dArrayLayer {
                            texture: self,
                            layer: layer,
                        })
                    } else {
                        None
                    }
                }
            }

                /// Represents a single layer of a `DepthStencilTexture1dArray`.
                ///
                /// Can be obtained by calling `DepthStencilTexture1dArray::layer()`.
                #[derive(Copy, Clone)]
                pub struct DepthStencilTexture1dArrayLayer<'t> {
                    texture: &'t DepthStencilTexture1dArray,
                    layer: u32,
                }
            impl<'t> DepthStencilTexture1dArrayLayer<'t> {

                /// Returns the corresponding texture.
                pub fn get_texture(&self) -> &'t DepthStencilTexture1dArray {
                    self.texture
                }

                /// Returns the layer index.
                pub fn get_layer(&self) -> u32 {
                    self.layer
                }
            
                /// Returns the number of mipmap levels of the texture.
                ///
                /// The minimum value is 1, since there is always a main texture.
                pub fn get_mipmap_levels(&self) -> u32 {
                    self.texture.get_mipmap_levels()
                }
            
                /// Access a single mipmap level of this layer.
                pub fn mipmap(&self, level: u32) -> Option<DepthStencilTexture1dArrayMipmap> {
                    self.texture.0.mipmap(self.layer, level).map(|m| DepthStencilTexture1dArrayMipmap(m, &self.texture))
                }
            
                /// Access the main mipmap level of this layer.
                pub fn main_level(&self) -> DepthStencilTexture1dArrayMipmap {
                    self.mipmap(0).unwrap()
                }
            }

                    /// Represents a single mipmap level of a `DepthStencilTexture1dArray`.
                    ///
                    /// Can be obtained by calling `DepthStencilTexture1dArrayLayer::mipmap()` or
                    /// `DepthStencilTexture1dArrayLayer::main_level()`.
                    #[derive(Copy, Clone)]
                    pub struct DepthStencilTexture1dArrayMipmap<'t>(TextureAnyMipmap<'t>, &'t DepthStencilTexture1dArray);
                impl<'t> DepthStencilTexture1dArrayMipmap<'t> {

                /// Returns the corresponding texture.
                pub fn get_texture(&self) -> &'t DepthStencilTexture1dArray {
                    self.1
                }

                /// Returns the texture level.
                pub fn get_level(&self) -> u32 {
                    self.0.get_level()
                }
            
                    /// Returns the layer index.
                    pub fn get_layer(&self) -> u32 {
                        self.0.get_layer()
                    }
                }
/// An array of two-dimensional textures  containing floating-point data.
pub struct Texture2dArray(TextureAny);

                impl Texture for Texture2dArray {
                    fn get_width(&self) -> u32 {
                        self.0.get_width()
                    }

                    fn get_height(&self) -> Option<u32> {
                        self.0.get_height()
                    }

                    fn get_depth(&self) -> Option<u32> {
                        self.0.get_depth()
                    }

                    fn get_array_size(&self) -> Option<u32> {
                        self.0.get_array_size()
                    }
                }
            

                impl GlObject for Texture2dArray {
                    type Id = gl::types::GLuint;
                    fn get_id(&self) -> gl::types::GLuint {
                        self.0.get_id()
                    }
                }
            

                impl ::std::fmt::Debug for Texture2dArray {
                    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> Result<(), ::std::fmt::Error>
                    {
                        self.0.fmt(f)
                    }
                }
            

                impl ::std::ops::Deref for Texture2dArray {
                    type Target = TextureAny;
                    
                    fn deref<'a>(&'a self) -> &'a TextureAny {
                        &self.0
                    }
                }
            

                            impl<'a> AsUniformValue for &'a Texture2dArray {
                                fn as_uniform_value(&self) -> UniformValue {
                                    UniformValue::Texture2dArray(*self, None)
                                }
                            }

                            impl<'a> AsUniformValue for Sampler<'a, Texture2dArray> {
                                fn as_uniform_value(&self) -> UniformValue {
                                    UniformValue::Texture2dArray(self.0, Some(self.1))
                                }
                            }

                            impl Texture2dArray {
                                /// Builds a `Sampler` marker object that allows you to indicate
                                /// how the texture should be sampled from inside a shader.
                                ///
                                /// # Example
                                ///
                                /// ```no_run
                                /// # #[macro_use] extern crate glium;
                                /// # fn main() {
                                /// # let texture: glium::texture::Texture2d = unsafe {
                                /// # ::std::mem::uninitialized() };
                                /// let uniforms = uniform! {
                                ///     color_texture: texture.sampled().magnify_filter(glium::uniforms::MagnifySamplerFilter::Nearest)
                                /// };
                                /// # }
                                /// ```
                                pub fn sampled(&self) -> Sampler<Texture2dArray> {
                                    Sampler(self, Default::default())
                                }
                            }
                        
impl Texture2dArray {

            /// Determines the internal format of this texture.
            ///
            /// The backend may not support querying the actual format, in which case an error
            /// is returned.
            pub fn get_internal_format(&self) -> Result<InternalFormat, GetFormatError> {
                self.0.get_internal_format()
            }
        

                /// Builds a new texture by uploading data.
                ///
                /// This function will automatically generate all mipmaps of the texture.
                pub fn new<'a, F, T>(facade: &F, data: Vec<T>)
                              -> Result<Texture2dArray, TextureCreationError>
                              where T: Texture2dDataSource<'a>, F: Facade
                {
                    Texture2dArray::new_impl(facade, data, None, MipmapsOption::AutoGeneratedMipmaps)
                }
            

                /// Builds a new texture by uploading data.
                pub fn with_mipmaps<'a, F, T>(facade: &F, data: Vec<T>, mipmaps: MipmapsOption)
                                              -> Result<Texture2dArray, TextureCreationError>
                                              where T: Texture2dDataSource<'a>, F: Facade
                {
                    Texture2dArray::new_impl(facade, data, None, mipmaps)
                }
            

                /// Builds a new texture with a specific format.
                pub fn with_format<'a, F, T>(facade: &F, data: Vec<T>,
                                          format: UncompressedFloatFormat, mipmaps: MipmapsOption)
                                          -> Result<Texture2dArray, TextureCreationError>
                                          where T: Texture2dDataSource<'a>, F: Facade
                {
                    Texture2dArray::new_impl(facade, data, Some(format), mipmaps)
                }
            

                fn new_impl<'a, F, T>(facade: &F, data: Vec<T>,
                                   format: Option<UncompressedFloatFormat>, mipmaps: MipmapsOption)
                                   -> Result<Texture2dArray, TextureCreationError>
                                   where T: Texture2dDataSource<'a>, F: Facade
                {
            
let format = format.map(|f| {
                           TextureFormatRequest::Specific(f.to_texture_format())
                       }).unwrap_or(TextureFormatRequest::AnyFloatingPoint);
                    let vec_raw = data.into_iter().map(|e| e.into_raw()).collect();
                    let RawImage3d {data, width, height, depth: array_size, format: client_format } = RawImage3d::from_vec_raw2d(&vec_raw);
                let client_format = ClientFormatAny::ClientFormat(client_format);Ok(Texture2dArray(try!(any::new_texture(facade, format, Some((client_format, data)), mipmaps.to_regular(), Dimensions::Texture2dArray { width: width, height: height, array_size: array_size }))))
}

                /// Creates an empty texture.
                ///
                /// No mipmap level (except for the main level) will be allocated or generated.
                ///
                /// The texture will contain undefined data.
                pub fn empty<F>(facade: &F, width: u32, height: u32, array_size: u32)
                                -> Result<Texture2dArray, TextureCreationError>
                                where F: Facade
                {
                    let format = TextureFormatRequest::AnyFloatingPoint;
            
any::new_texture::<_, u8>(facade, format, None, MipmapsOption::NoMipmap.to_regular(), Dimensions::Texture2dArray { width: width, height: height, array_size: array_size }).map(|t| Texture2dArray(t))}

                /// Creates an empty texture with a specific format.
                ///
                /// The texture (and its mipmaps) will contain undefined data.
                pub fn empty_with_format<F>(facade: &F, format: UncompressedFloatFormat, mipmaps: MipmapsOption, width: u32, height: u32, array_size: u32) -> Result<Texture2dArray, TextureCreationError> where F: Facade {
                    let format = format.to_texture_format();
                    let format = TextureFormatRequest::Specific(format);
            
let t = any::new_texture::<_, u8>(facade, format, None, mipmaps.to_regular(), Dimensions::Texture2dArray { width: width, height: height, array_size: array_size });
            t.map(|t| Texture2dArray(t))
}

                /// Creates an empty texture. Specifies whether is has mipmaps.
                ///
                /// The texture (and its mipmaps) will contain undefined data.
                pub fn empty_with_mipmaps<F>(facade: &F, mipmaps: MipmapsOption, width: u32, height: u32, array_size: u32) -> Result<Texture2dArray, TextureCreationError> where F: Facade {
                    let format = TextureFormatRequest::AnyFloatingPoint;
            
any::new_texture::<_, u8>(facade, format, None, mipmaps.to_regular(), Dimensions::Texture2dArray { width: width, height: height, array_size: array_size }).map(|t| Texture2dArray(t))
}

            /// Returns the number of mipmap levels of the texture.
            ///
            /// The minimum value is 1, since there is always a main texture.
            pub fn get_mipmap_levels(&self) -> u32 {
                self.0.get_mipmap_levels()
            }
        
            /// Turns the texture into a `ResidentTexture`.
            ///
            /// This allows you to use the texture in a much more efficient way by storing
            /// a "reference to it" in a buffer (actually not a reference but a raw pointer).
            ///
            /// See the documentation of `ResidentTexture` for more infos.
            pub fn resident(self) -> Result<ResidentTexture, BindlessTexturesNotSupportedError> {
                ResidentTexture::new(self.0)
            }
        
                /// Access a single layer of this texture.
                pub fn layer(&self, layer: u32) -> Option<Texture2dArrayLayer> {
                    if layer < self.0.get_array_size().unwrap_or(1) {
                        Some(Texture2dArrayLayer {
                            texture: self,
                            layer: layer,
                        })
                    } else {
                        None
                    }
                }
            }

                /// Represents a single layer of a `Texture2dArray`.
                ///
                /// Can be obtained by calling `Texture2dArray::layer()`.
                #[derive(Copy, Clone)]
                pub struct Texture2dArrayLayer<'t> {
                    texture: &'t Texture2dArray,
                    layer: u32,
                }
            impl<'t> Texture2dArrayLayer<'t> {

                /// Returns the corresponding texture.
                pub fn get_texture(&self) -> &'t Texture2dArray {
                    self.texture
                }

                /// Returns the layer index.
                pub fn get_layer(&self) -> u32 {
                    self.layer
                }
            
                /// Returns the number of mipmap levels of the texture.
                ///
                /// The minimum value is 1, since there is always a main texture.
                pub fn get_mipmap_levels(&self) -> u32 {
                    self.texture.get_mipmap_levels()
                }
            
                /// Access a single mipmap level of this layer.
                pub fn mipmap(&self, level: u32) -> Option<Texture2dArrayMipmap> {
                    self.texture.0.mipmap(self.layer, level).map(|m| Texture2dArrayMipmap(m, &self.texture))
                }
            
                /// Access the main mipmap level of this layer.
                pub fn main_level(&self) -> Texture2dArrayMipmap {
                    self.mipmap(0).unwrap()
                }
            }

                    /// Represents a single mipmap level of a `Texture2dArray`.
                    ///
                    /// Can be obtained by calling `Texture2dArrayLayer::mipmap()` or
                    /// `Texture2dArrayLayer::main_level()`.
                    #[derive(Copy, Clone)]
                    pub struct Texture2dArrayMipmap<'t>(TextureAnyMipmap<'t>, &'t Texture2dArray);
                impl<'t> Texture2dArrayMipmap<'t> {

                /// Returns the corresponding texture.
                pub fn get_texture(&self) -> &'t Texture2dArray {
                    self.1
                }

                /// Returns the texture level.
                pub fn get_level(&self) -> u32 {
                    self.0.get_level()
                }
            
                    /// Returns the layer index.
                    pub fn get_layer(&self) -> u32 {
                        self.0.get_layer()
                    }
                }
/// An array of compressed two-dimensional textures  containing floating-point data.
pub struct CompressedTexture2dArray(TextureAny);

                impl Texture for CompressedTexture2dArray {
                    fn get_width(&self) -> u32 {
                        self.0.get_width()
                    }

                    fn get_height(&self) -> Option<u32> {
                        self.0.get_height()
                    }

                    fn get_depth(&self) -> Option<u32> {
                        self.0.get_depth()
                    }

                    fn get_array_size(&self) -> Option<u32> {
                        self.0.get_array_size()
                    }
                }
            

                impl GlObject for CompressedTexture2dArray {
                    type Id = gl::types::GLuint;
                    fn get_id(&self) -> gl::types::GLuint {
                        self.0.get_id()
                    }
                }
            

                impl ::std::fmt::Debug for CompressedTexture2dArray {
                    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> Result<(), ::std::fmt::Error>
                    {
                        self.0.fmt(f)
                    }
                }
            

                impl ::std::ops::Deref for CompressedTexture2dArray {
                    type Target = TextureAny;
                    
                    fn deref<'a>(&'a self) -> &'a TextureAny {
                        &self.0
                    }
                }
            

                            impl<'a> AsUniformValue for &'a CompressedTexture2dArray {
                                fn as_uniform_value(&self) -> UniformValue {
                                    UniformValue::CompressedTexture2dArray(*self, None)
                                }
                            }

                            impl<'a> AsUniformValue for Sampler<'a, CompressedTexture2dArray> {
                                fn as_uniform_value(&self) -> UniformValue {
                                    UniformValue::CompressedTexture2dArray(self.0, Some(self.1))
                                }
                            }

                            impl CompressedTexture2dArray {
                                /// Builds a `Sampler` marker object that allows you to indicate
                                /// how the texture should be sampled from inside a shader.
                                ///
                                /// # Example
                                ///
                                /// ```no_run
                                /// # #[macro_use] extern crate glium;
                                /// # fn main() {
                                /// # let texture: glium::texture::Texture2d = unsafe {
                                /// # ::std::mem::uninitialized() };
                                /// let uniforms = uniform! {
                                ///     color_texture: texture.sampled().magnify_filter(glium::uniforms::MagnifySamplerFilter::Nearest)
                                /// };
                                /// # }
                                /// ```
                                pub fn sampled(&self) -> Sampler<CompressedTexture2dArray> {
                                    Sampler(self, Default::default())
                                }
                            }
                        
impl CompressedTexture2dArray {

            /// Determines the internal format of this texture.
            ///
            /// The backend may not support querying the actual format, in which case an error
            /// is returned.
            pub fn get_internal_format(&self) -> Result<InternalFormat, GetFormatError> {
                self.0.get_internal_format()
            }
        

                /// Builds a new texture by uploading data.
                ///
                /// No mipmap level (except for the main level) will be allocator nor generated.
                pub fn new<'a, F, T>(facade: &F, data: Vec<T>)
                              -> Result<CompressedTexture2dArray, TextureCreationError>
                              where T: Texture2dDataSource<'a>, F: Facade
                {
                    CompressedTexture2dArray::new_impl(facade, data, None, CompressedMipmapsOption::NoMipmap)
                }
            

                /// Builds a new texture by uploading data.
                pub fn with_mipmaps<'a, F, T>(facade: &F, data: Vec<T>, mipmaps: CompressedMipmapsOption)
                                              -> Result<CompressedTexture2dArray, TextureCreationError>
                                              where T: Texture2dDataSource<'a>, F: Facade
                {
                    CompressedTexture2dArray::new_impl(facade, data, None, mipmaps)
                }
            

                /// Builds a new texture with a specific format. The input data must also be of the
                /// specified compressed format.
                pub fn with_compressed_data<F>(facade: &F, data: Vec<&[u8]>, width: u32, height: u32, array_size: u32,
                                                      format: CompressedFormat, mipmaps: CompressedMipmapsOption)
                                                      -> Result<CompressedTexture2dArray, TextureCreationError>
                                                       where F: Facade
                {
                    let data = Cow::Borrowed(data.as_ref());
                    let client_format = ClientFormatAny::CompressedFormat(format);
                    Ok(CompressedTexture2dArray(try!(any::new_texture(facade, TextureFormatRequest::AnyCompressed, Some((client_format, data)),
                                                    mipmaps.to_regular(), Dimensions::Texture2dArray { width: width, height: height, array_size: array_size }))))
                }
            

                /// Builds a new texture with a specific format.
                pub fn with_format<'a, F, T>(facade: &F, data: Vec<T>,
                                          format: CompressedFormat, mipmaps: CompressedMipmapsOption)
                                          -> Result<CompressedTexture2dArray, TextureCreationError>
                                          where T: Texture2dDataSource<'a>, F: Facade
                {
                    CompressedTexture2dArray::new_impl(facade, data, Some(format), mipmaps)
                }
            

                fn new_impl<'a, F, T>(facade: &F, data: Vec<T>,
                                   format: Option<CompressedFormat>, mipmaps: CompressedMipmapsOption)
                                   -> Result<CompressedTexture2dArray, TextureCreationError>
                                   where T: Texture2dDataSource<'a>, F: Facade
                {
            
let format = format.map(|f| {
                           TextureFormatRequest::Specific(f.to_texture_format())
                       }).unwrap_or(TextureFormatRequest::AnyCompressed);
                    let vec_raw = data.into_iter().map(|e| e.into_raw()).collect();
                    let RawImage3d {data, width, height, depth: array_size, format: client_format } = RawImage3d::from_vec_raw2d(&vec_raw);
                let client_format = ClientFormatAny::ClientFormat(client_format);Ok(CompressedTexture2dArray(try!(any::new_texture(facade, format, Some((client_format, data)), mipmaps.to_regular(), Dimensions::Texture2dArray { width: width, height: height, array_size: array_size }))))
}

                /// Creates an empty texture with a specific format.
                ///
                /// The texture (and its mipmaps) will contain undefined data.
                pub fn empty_with_format<F>(facade: &F, format: CompressedFormat, mipmaps: CompressedMipmapsOption, width: u32, height: u32, array_size: u32) -> Result<CompressedTexture2dArray, TextureCreationError> where F: Facade {
                    let format = format.to_texture_format();
                    let format = TextureFormatRequest::Specific(format);
            
let t = any::new_texture::<_, u8>(facade, format, None, mipmaps.to_regular(), Dimensions::Texture2dArray { width: width, height: height, array_size: array_size });
            t.map(|t| CompressedTexture2dArray(t))
}

            /// Returns the number of mipmap levels of the texture.
            ///
            /// The minimum value is 1, since there is always a main texture.
            pub fn get_mipmap_levels(&self) -> u32 {
                self.0.get_mipmap_levels()
            }
        
            /// Turns the texture into a `ResidentTexture`.
            ///
            /// This allows you to use the texture in a much more efficient way by storing
            /// a "reference to it" in a buffer (actually not a reference but a raw pointer).
            ///
            /// See the documentation of `ResidentTexture` for more infos.
            pub fn resident(self) -> Result<ResidentTexture, BindlessTexturesNotSupportedError> {
                ResidentTexture::new(self.0)
            }
        
                /// Access a single layer of this texture.
                pub fn layer(&self, layer: u32) -> Option<CompressedTexture2dArrayLayer> {
                    if layer < self.0.get_array_size().unwrap_or(1) {
                        Some(CompressedTexture2dArrayLayer {
                            texture: self,
                            layer: layer,
                        })
                    } else {
                        None
                    }
                }
            }

                /// Represents a single layer of a `CompressedTexture2dArray`.
                ///
                /// Can be obtained by calling `CompressedTexture2dArray::layer()`.
                #[derive(Copy, Clone)]
                pub struct CompressedTexture2dArrayLayer<'t> {
                    texture: &'t CompressedTexture2dArray,
                    layer: u32,
                }
            impl<'t> CompressedTexture2dArrayLayer<'t> {

                /// Returns the corresponding texture.
                pub fn get_texture(&self) -> &'t CompressedTexture2dArray {
                    self.texture
                }

                /// Returns the layer index.
                pub fn get_layer(&self) -> u32 {
                    self.layer
                }
            
                /// Returns the number of mipmap levels of the texture.
                ///
                /// The minimum value is 1, since there is always a main texture.
                pub fn get_mipmap_levels(&self) -> u32 {
                    self.texture.get_mipmap_levels()
                }
            
                /// Access a single mipmap level of this layer.
                pub fn mipmap(&self, level: u32) -> Option<CompressedTexture2dArrayMipmap> {
                    self.texture.0.mipmap(self.layer, level).map(|m| CompressedTexture2dArrayMipmap(m, &self.texture))
                }
            
                /// Access the main mipmap level of this layer.
                pub fn main_level(&self) -> CompressedTexture2dArrayMipmap {
                    self.mipmap(0).unwrap()
                }
            }

                    /// Represents a single mipmap level of a `CompressedTexture2dArray`.
                    ///
                    /// Can be obtained by calling `CompressedTexture2dArrayLayer::mipmap()` or
                    /// `CompressedTexture2dArrayLayer::main_level()`.
                    #[derive(Copy, Clone)]
                    pub struct CompressedTexture2dArrayMipmap<'t>(TextureAnyMipmap<'t>, &'t CompressedTexture2dArray);
                impl<'t> CompressedTexture2dArrayMipmap<'t> {

                /// Returns the corresponding texture.
                pub fn get_texture(&self) -> &'t CompressedTexture2dArray {
                    self.1
                }

                /// Returns the texture level.
                pub fn get_level(&self) -> u32 {
                    self.0.get_level()
                }
            
                    /// Returns the layer index.
                    pub fn get_layer(&self) -> u32 {
                        self.0.get_layer()
                    }
                }
/// An array of two-dimensional textures  containing sRGB floating-point data.
pub struct SrgbTexture2dArray(TextureAny);

                impl Texture for SrgbTexture2dArray {
                    fn get_width(&self) -> u32 {
                        self.0.get_width()
                    }

                    fn get_height(&self) -> Option<u32> {
                        self.0.get_height()
                    }

                    fn get_depth(&self) -> Option<u32> {
                        self.0.get_depth()
                    }

                    fn get_array_size(&self) -> Option<u32> {
                        self.0.get_array_size()
                    }
                }
            

                impl GlObject for SrgbTexture2dArray {
                    type Id = gl::types::GLuint;
                    fn get_id(&self) -> gl::types::GLuint {
                        self.0.get_id()
                    }
                }
            

                impl ::std::fmt::Debug for SrgbTexture2dArray {
                    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> Result<(), ::std::fmt::Error>
                    {
                        self.0.fmt(f)
                    }
                }
            

                impl ::std::ops::Deref for SrgbTexture2dArray {
                    type Target = TextureAny;
                    
                    fn deref<'a>(&'a self) -> &'a TextureAny {
                        &self.0
                    }
                }
            

                            impl<'a> AsUniformValue for &'a SrgbTexture2dArray {
                                fn as_uniform_value(&self) -> UniformValue {
                                    UniformValue::SrgbTexture2dArray(*self, None)
                                }
                            }

                            impl<'a> AsUniformValue for Sampler<'a, SrgbTexture2dArray> {
                                fn as_uniform_value(&self) -> UniformValue {
                                    UniformValue::SrgbTexture2dArray(self.0, Some(self.1))
                                }
                            }

                            impl SrgbTexture2dArray {
                                /// Builds a `Sampler` marker object that allows you to indicate
                                /// how the texture should be sampled from inside a shader.
                                ///
                                /// # Example
                                ///
                                /// ```no_run
                                /// # #[macro_use] extern crate glium;
                                /// # fn main() {
                                /// # let texture: glium::texture::Texture2d = unsafe {
                                /// # ::std::mem::uninitialized() };
                                /// let uniforms = uniform! {
                                ///     color_texture: texture.sampled().magnify_filter(glium::uniforms::MagnifySamplerFilter::Nearest)
                                /// };
                                /// # }
                                /// ```
                                pub fn sampled(&self) -> Sampler<SrgbTexture2dArray> {
                                    Sampler(self, Default::default())
                                }
                            }
                        
impl SrgbTexture2dArray {

            /// Determines the internal format of this texture.
            ///
            /// The backend may not support querying the actual format, in which case an error
            /// is returned.
            pub fn get_internal_format(&self) -> Result<InternalFormat, GetFormatError> {
                self.0.get_internal_format()
            }
        

                /// Builds a new texture by uploading data.
                ///
                /// This function will automatically generate all mipmaps of the texture.
                pub fn new<'a, F, T>(facade: &F, data: Vec<T>)
                              -> Result<SrgbTexture2dArray, TextureCreationError>
                              where T: Texture2dDataSource<'a>, F: Facade
                {
                    SrgbTexture2dArray::new_impl(facade, data, None, MipmapsOption::AutoGeneratedMipmaps)
                }
            

                /// Builds a new texture by uploading data.
                pub fn with_mipmaps<'a, F, T>(facade: &F, data: Vec<T>, mipmaps: MipmapsOption)
                                              -> Result<SrgbTexture2dArray, TextureCreationError>
                                              where T: Texture2dDataSource<'a>, F: Facade
                {
                    SrgbTexture2dArray::new_impl(facade, data, None, mipmaps)
                }
            

                /// Builds a new texture with a specific format.
                pub fn with_format<'a, F, T>(facade: &F, data: Vec<T>,
                                          format: SrgbFormat, mipmaps: MipmapsOption)
                                          -> Result<SrgbTexture2dArray, TextureCreationError>
                                          where T: Texture2dDataSource<'a>, F: Facade
                {
                    SrgbTexture2dArray::new_impl(facade, data, Some(format), mipmaps)
                }
            

                fn new_impl<'a, F, T>(facade: &F, data: Vec<T>,
                                   format: Option<SrgbFormat>, mipmaps: MipmapsOption)
                                   -> Result<SrgbTexture2dArray, TextureCreationError>
                                   where T: Texture2dDataSource<'a>, F: Facade
                {
            
let format = format.map(|f| {
                           TextureFormatRequest::Specific(f.to_texture_format())
                       }).unwrap_or(TextureFormatRequest::AnySrgb);
                    let vec_raw = data.into_iter().map(|e| e.into_raw()).collect();
                    let RawImage3d {data, width, height, depth: array_size, format: client_format } = RawImage3d::from_vec_raw2d(&vec_raw);
                let client_format = ClientFormatAny::ClientFormat(client_format);Ok(SrgbTexture2dArray(try!(any::new_texture(facade, format, Some((client_format, data)), mipmaps.to_regular(), Dimensions::Texture2dArray { width: width, height: height, array_size: array_size }))))
}

                /// Creates an empty texture.
                ///
                /// No mipmap level (except for the main level) will be allocated or generated.
                ///
                /// The texture will contain undefined data.
                pub fn empty<F>(facade: &F, width: u32, height: u32, array_size: u32)
                                -> Result<SrgbTexture2dArray, TextureCreationError>
                                where F: Facade
                {
                    let format = TextureFormatRequest::AnySrgb;
            
any::new_texture::<_, u8>(facade, format, None, MipmapsOption::NoMipmap.to_regular(), Dimensions::Texture2dArray { width: width, height: height, array_size: array_size }).map(|t| SrgbTexture2dArray(t))}

                /// Creates an empty texture with a specific format.
                ///
                /// The texture (and its mipmaps) will contain undefined data.
                pub fn empty_with_format<F>(facade: &F, format: SrgbFormat, mipmaps: MipmapsOption, width: u32, height: u32, array_size: u32) -> Result<SrgbTexture2dArray, TextureCreationError> where F: Facade {
                    let format = format.to_texture_format();
                    let format = TextureFormatRequest::Specific(format);
            
let t = any::new_texture::<_, u8>(facade, format, None, mipmaps.to_regular(), Dimensions::Texture2dArray { width: width, height: height, array_size: array_size });
            t.map(|t| SrgbTexture2dArray(t))
}

                /// Creates an empty texture. Specifies whether is has mipmaps.
                ///
                /// The texture (and its mipmaps) will contain undefined data.
                pub fn empty_with_mipmaps<F>(facade: &F, mipmaps: MipmapsOption, width: u32, height: u32, array_size: u32) -> Result<SrgbTexture2dArray, TextureCreationError> where F: Facade {
                    let format = TextureFormatRequest::AnySrgb;
            
any::new_texture::<_, u8>(facade, format, None, mipmaps.to_regular(), Dimensions::Texture2dArray { width: width, height: height, array_size: array_size }).map(|t| SrgbTexture2dArray(t))
}

            /// Returns the number of mipmap levels of the texture.
            ///
            /// The minimum value is 1, since there is always a main texture.
            pub fn get_mipmap_levels(&self) -> u32 {
                self.0.get_mipmap_levels()
            }
        
            /// Turns the texture into a `ResidentTexture`.
            ///
            /// This allows you to use the texture in a much more efficient way by storing
            /// a "reference to it" in a buffer (actually not a reference but a raw pointer).
            ///
            /// See the documentation of `ResidentTexture` for more infos.
            pub fn resident(self) -> Result<ResidentTexture, BindlessTexturesNotSupportedError> {
                ResidentTexture::new(self.0)
            }
        
                /// Access a single layer of this texture.
                pub fn layer(&self, layer: u32) -> Option<SrgbTexture2dArrayLayer> {
                    if layer < self.0.get_array_size().unwrap_or(1) {
                        Some(SrgbTexture2dArrayLayer {
                            texture: self,
                            layer: layer,
                        })
                    } else {
                        None
                    }
                }
            }

                /// Represents a single layer of a `SrgbTexture2dArray`.
                ///
                /// Can be obtained by calling `SrgbTexture2dArray::layer()`.
                #[derive(Copy, Clone)]
                pub struct SrgbTexture2dArrayLayer<'t> {
                    texture: &'t SrgbTexture2dArray,
                    layer: u32,
                }
            impl<'t> SrgbTexture2dArrayLayer<'t> {

                /// Returns the corresponding texture.
                pub fn get_texture(&self) -> &'t SrgbTexture2dArray {
                    self.texture
                }

                /// Returns the layer index.
                pub fn get_layer(&self) -> u32 {
                    self.layer
                }
            
                /// Returns the number of mipmap levels of the texture.
                ///
                /// The minimum value is 1, since there is always a main texture.
                pub fn get_mipmap_levels(&self) -> u32 {
                    self.texture.get_mipmap_levels()
                }
            
                /// Access a single mipmap level of this layer.
                pub fn mipmap(&self, level: u32) -> Option<SrgbTexture2dArrayMipmap> {
                    self.texture.0.mipmap(self.layer, level).map(|m| SrgbTexture2dArrayMipmap(m, &self.texture))
                }
            
                /// Access the main mipmap level of this layer.
                pub fn main_level(&self) -> SrgbTexture2dArrayMipmap {
                    self.mipmap(0).unwrap()
                }
            }

                    /// Represents a single mipmap level of a `SrgbTexture2dArray`.
                    ///
                    /// Can be obtained by calling `SrgbTexture2dArrayLayer::mipmap()` or
                    /// `SrgbTexture2dArrayLayer::main_level()`.
                    #[derive(Copy, Clone)]
                    pub struct SrgbTexture2dArrayMipmap<'t>(TextureAnyMipmap<'t>, &'t SrgbTexture2dArray);
                impl<'t> SrgbTexture2dArrayMipmap<'t> {

                /// Returns the corresponding texture.
                pub fn get_texture(&self) -> &'t SrgbTexture2dArray {
                    self.1
                }

                /// Returns the texture level.
                pub fn get_level(&self) -> u32 {
                    self.0.get_level()
                }
            
                    /// Returns the layer index.
                    pub fn get_layer(&self) -> u32 {
                        self.0.get_layer()
                    }
                }
/// An array of compressed two-dimensional textures  containing sRGB floating-point data.
pub struct CompressedSrgbTexture2dArray(TextureAny);

                impl Texture for CompressedSrgbTexture2dArray {
                    fn get_width(&self) -> u32 {
                        self.0.get_width()
                    }

                    fn get_height(&self) -> Option<u32> {
                        self.0.get_height()
                    }

                    fn get_depth(&self) -> Option<u32> {
                        self.0.get_depth()
                    }

                    fn get_array_size(&self) -> Option<u32> {
                        self.0.get_array_size()
                    }
                }
            

                impl GlObject for CompressedSrgbTexture2dArray {
                    type Id = gl::types::GLuint;
                    fn get_id(&self) -> gl::types::GLuint {
                        self.0.get_id()
                    }
                }
            

                impl ::std::fmt::Debug for CompressedSrgbTexture2dArray {
                    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> Result<(), ::std::fmt::Error>
                    {
                        self.0.fmt(f)
                    }
                }
            

                impl ::std::ops::Deref for CompressedSrgbTexture2dArray {
                    type Target = TextureAny;
                    
                    fn deref<'a>(&'a self) -> &'a TextureAny {
                        &self.0
                    }
                }
            

                            impl<'a> AsUniformValue for &'a CompressedSrgbTexture2dArray {
                                fn as_uniform_value(&self) -> UniformValue {
                                    UniformValue::CompressedSrgbTexture2dArray(*self, None)
                                }
                            }

                            impl<'a> AsUniformValue for Sampler<'a, CompressedSrgbTexture2dArray> {
                                fn as_uniform_value(&self) -> UniformValue {
                                    UniformValue::CompressedSrgbTexture2dArray(self.0, Some(self.1))
                                }
                            }

                            impl CompressedSrgbTexture2dArray {
                                /// Builds a `Sampler` marker object that allows you to indicate
                                /// how the texture should be sampled from inside a shader.
                                ///
                                /// # Example
                                ///
                                /// ```no_run
                                /// # #[macro_use] extern crate glium;
                                /// # fn main() {
                                /// # let texture: glium::texture::Texture2d = unsafe {
                                /// # ::std::mem::uninitialized() };
                                /// let uniforms = uniform! {
                                ///     color_texture: texture.sampled().magnify_filter(glium::uniforms::MagnifySamplerFilter::Nearest)
                                /// };
                                /// # }
                                /// ```
                                pub fn sampled(&self) -> Sampler<CompressedSrgbTexture2dArray> {
                                    Sampler(self, Default::default())
                                }
                            }
                        
impl CompressedSrgbTexture2dArray {

            /// Determines the internal format of this texture.
            ///
            /// The backend may not support querying the actual format, in which case an error
            /// is returned.
            pub fn get_internal_format(&self) -> Result<InternalFormat, GetFormatError> {
                self.0.get_internal_format()
            }
        

                /// Builds a new texture by uploading data.
                ///
                /// No mipmap level (except for the main level) will be allocator nor generated.
                pub fn new<'a, F, T>(facade: &F, data: Vec<T>)
                              -> Result<CompressedSrgbTexture2dArray, TextureCreationError>
                              where T: Texture2dDataSource<'a>, F: Facade
                {
                    CompressedSrgbTexture2dArray::new_impl(facade, data, None, CompressedMipmapsOption::NoMipmap)
                }
            

                /// Builds a new texture by uploading data.
                pub fn with_mipmaps<'a, F, T>(facade: &F, data: Vec<T>, mipmaps: CompressedMipmapsOption)
                                              -> Result<CompressedSrgbTexture2dArray, TextureCreationError>
                                              where T: Texture2dDataSource<'a>, F: Facade
                {
                    CompressedSrgbTexture2dArray::new_impl(facade, data, None, mipmaps)
                }
            

                /// Builds a new texture with a specific format. The input data must also be of the
                /// specified compressed format.
                pub fn with_compressed_data<F>(facade: &F, data: Vec<&[u8]>, width: u32, height: u32, array_size: u32,
                                                      format: CompressedSrgbFormat, mipmaps: CompressedMipmapsOption)
                                                      -> Result<CompressedSrgbTexture2dArray, TextureCreationError>
                                                       where F: Facade
                {
                    let data = Cow::Borrowed(data.as_ref());
                    let client_format = ClientFormatAny::CompressedSrgbFormat(format);
                    Ok(CompressedSrgbTexture2dArray(try!(any::new_texture(facade, TextureFormatRequest::AnyCompressedSrgb, Some((client_format, data)),
                                                    mipmaps.to_regular(), Dimensions::Texture2dArray { width: width, height: height, array_size: array_size }))))
                }
            

                /// Builds a new texture with a specific format.
                pub fn with_format<'a, F, T>(facade: &F, data: Vec<T>,
                                          format: CompressedSrgbFormat, mipmaps: CompressedMipmapsOption)
                                          -> Result<CompressedSrgbTexture2dArray, TextureCreationError>
                                          where T: Texture2dDataSource<'a>, F: Facade
                {
                    CompressedSrgbTexture2dArray::new_impl(facade, data, Some(format), mipmaps)
                }
            

                fn new_impl<'a, F, T>(facade: &F, data: Vec<T>,
                                   format: Option<CompressedSrgbFormat>, mipmaps: CompressedMipmapsOption)
                                   -> Result<CompressedSrgbTexture2dArray, TextureCreationError>
                                   where T: Texture2dDataSource<'a>, F: Facade
                {
            
let format = format.map(|f| {
                           TextureFormatRequest::Specific(f.to_texture_format())
                       }).unwrap_or(TextureFormatRequest::AnyCompressedSrgb);
                    let vec_raw = data.into_iter().map(|e| e.into_raw()).collect();
                    let RawImage3d {data, width, height, depth: array_size, format: client_format } = RawImage3d::from_vec_raw2d(&vec_raw);
                let client_format = ClientFormatAny::ClientFormat(client_format);Ok(CompressedSrgbTexture2dArray(try!(any::new_texture(facade, format, Some((client_format, data)), mipmaps.to_regular(), Dimensions::Texture2dArray { width: width, height: height, array_size: array_size }))))
}

                /// Creates an empty texture with a specific format.
                ///
                /// The texture (and its mipmaps) will contain undefined data.
                pub fn empty_with_format<F>(facade: &F, format: CompressedSrgbFormat, mipmaps: CompressedMipmapsOption, width: u32, height: u32, array_size: u32) -> Result<CompressedSrgbTexture2dArray, TextureCreationError> where F: Facade {
                    let format = format.to_texture_format();
                    let format = TextureFormatRequest::Specific(format);
            
let t = any::new_texture::<_, u8>(facade, format, None, mipmaps.to_regular(), Dimensions::Texture2dArray { width: width, height: height, array_size: array_size });
            t.map(|t| CompressedSrgbTexture2dArray(t))
}

            /// Returns the number of mipmap levels of the texture.
            ///
            /// The minimum value is 1, since there is always a main texture.
            pub fn get_mipmap_levels(&self) -> u32 {
                self.0.get_mipmap_levels()
            }
        
            /// Turns the texture into a `ResidentTexture`.
            ///
            /// This allows you to use the texture in a much more efficient way by storing
            /// a "reference to it" in a buffer (actually not a reference but a raw pointer).
            ///
            /// See the documentation of `ResidentTexture` for more infos.
            pub fn resident(self) -> Result<ResidentTexture, BindlessTexturesNotSupportedError> {
                ResidentTexture::new(self.0)
            }
        
                /// Access a single layer of this texture.
                pub fn layer(&self, layer: u32) -> Option<CompressedSrgbTexture2dArrayLayer> {
                    if layer < self.0.get_array_size().unwrap_or(1) {
                        Some(CompressedSrgbTexture2dArrayLayer {
                            texture: self,
                            layer: layer,
                        })
                    } else {
                        None
                    }
                }
            }

                /// Represents a single layer of a `CompressedSrgbTexture2dArray`.
                ///
                /// Can be obtained by calling `CompressedSrgbTexture2dArray::layer()`.
                #[derive(Copy, Clone)]
                pub struct CompressedSrgbTexture2dArrayLayer<'t> {
                    texture: &'t CompressedSrgbTexture2dArray,
                    layer: u32,
                }
            impl<'t> CompressedSrgbTexture2dArrayLayer<'t> {

                /// Returns the corresponding texture.
                pub fn get_texture(&self) -> &'t CompressedSrgbTexture2dArray {
                    self.texture
                }

                /// Returns the layer index.
                pub fn get_layer(&self) -> u32 {
                    self.layer
                }
            
                /// Returns the number of mipmap levels of the texture.
                ///
                /// The minimum value is 1, since there is always a main texture.
                pub fn get_mipmap_levels(&self) -> u32 {
                    self.texture.get_mipmap_levels()
                }
            
                /// Access a single mipmap level of this layer.
                pub fn mipmap(&self, level: u32) -> Option<CompressedSrgbTexture2dArrayMipmap> {
                    self.texture.0.mipmap(self.layer, level).map(|m| CompressedSrgbTexture2dArrayMipmap(m, &self.texture))
                }
            
                /// Access the main mipmap level of this layer.
                pub fn main_level(&self) -> CompressedSrgbTexture2dArrayMipmap {
                    self.mipmap(0).unwrap()
                }
            }

                    /// Represents a single mipmap level of a `CompressedSrgbTexture2dArray`.
                    ///
                    /// Can be obtained by calling `CompressedSrgbTexture2dArrayLayer::mipmap()` or
                    /// `CompressedSrgbTexture2dArrayLayer::main_level()`.
                    #[derive(Copy, Clone)]
                    pub struct CompressedSrgbTexture2dArrayMipmap<'t>(TextureAnyMipmap<'t>, &'t CompressedSrgbTexture2dArray);
                impl<'t> CompressedSrgbTexture2dArrayMipmap<'t> {

                /// Returns the corresponding texture.
                pub fn get_texture(&self) -> &'t CompressedSrgbTexture2dArray {
                    self.1
                }

                /// Returns the texture level.
                pub fn get_level(&self) -> u32 {
                    self.0.get_level()
                }
            
                    /// Returns the layer index.
                    pub fn get_layer(&self) -> u32 {
                        self.0.get_layer()
                    }
                }
/// An array of two-dimensional textures  containing signed integral data.
pub struct IntegralTexture2dArray(TextureAny);

                impl Texture for IntegralTexture2dArray {
                    fn get_width(&self) -> u32 {
                        self.0.get_width()
                    }

                    fn get_height(&self) -> Option<u32> {
                        self.0.get_height()
                    }

                    fn get_depth(&self) -> Option<u32> {
                        self.0.get_depth()
                    }

                    fn get_array_size(&self) -> Option<u32> {
                        self.0.get_array_size()
                    }
                }
            

                impl GlObject for IntegralTexture2dArray {
                    type Id = gl::types::GLuint;
                    fn get_id(&self) -> gl::types::GLuint {
                        self.0.get_id()
                    }
                }
            

                impl ::std::fmt::Debug for IntegralTexture2dArray {
                    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> Result<(), ::std::fmt::Error>
                    {
                        self.0.fmt(f)
                    }
                }
            

                impl ::std::ops::Deref for IntegralTexture2dArray {
                    type Target = TextureAny;
                    
                    fn deref<'a>(&'a self) -> &'a TextureAny {
                        &self.0
                    }
                }
            

                            impl<'a> AsUniformValue for &'a IntegralTexture2dArray {
                                fn as_uniform_value(&self) -> UniformValue {
                                    UniformValue::IntegralTexture2dArray(*self, None)
                                }
                            }

                            impl<'a> AsUniformValue for Sampler<'a, IntegralTexture2dArray> {
                                fn as_uniform_value(&self) -> UniformValue {
                                    UniformValue::IntegralTexture2dArray(self.0, Some(self.1))
                                }
                            }

                            impl IntegralTexture2dArray {
                                /// Builds a `Sampler` marker object that allows you to indicate
                                /// how the texture should be sampled from inside a shader.
                                ///
                                /// # Example
                                ///
                                /// ```no_run
                                /// # #[macro_use] extern crate glium;
                                /// # fn main() {
                                /// # let texture: glium::texture::Texture2d = unsafe {
                                /// # ::std::mem::uninitialized() };
                                /// let uniforms = uniform! {
                                ///     color_texture: texture.sampled().magnify_filter(glium::uniforms::MagnifySamplerFilter::Nearest)
                                /// };
                                /// # }
                                /// ```
                                pub fn sampled(&self) -> Sampler<IntegralTexture2dArray> {
                                    Sampler(self, Default::default())
                                }
                            }
                        
impl IntegralTexture2dArray {

            /// Determines the internal format of this texture.
            ///
            /// The backend may not support querying the actual format, in which case an error
            /// is returned.
            pub fn get_internal_format(&self) -> Result<InternalFormat, GetFormatError> {
                self.0.get_internal_format()
            }
        

                /// Builds a new texture by uploading data.
                ///
                /// This function will automatically generate all mipmaps of the texture.
                pub fn new<'a, F, T>(facade: &F, data: Vec<T>)
                              -> Result<IntegralTexture2dArray, TextureCreationError>
                              where T: Texture2dDataSource<'a>, F: Facade
                {
                    IntegralTexture2dArray::new_impl(facade, data, None, MipmapsOption::AutoGeneratedMipmaps)
                }
            

                /// Builds a new texture by uploading data.
                pub fn with_mipmaps<'a, F, T>(facade: &F, data: Vec<T>, mipmaps: MipmapsOption)
                                              -> Result<IntegralTexture2dArray, TextureCreationError>
                                              where T: Texture2dDataSource<'a>, F: Facade
                {
                    IntegralTexture2dArray::new_impl(facade, data, None, mipmaps)
                }
            

                /// Builds a new texture with a specific format.
                pub fn with_format<'a, F, T>(facade: &F, data: Vec<T>,
                                          format: UncompressedIntFormat, mipmaps: MipmapsOption)
                                          -> Result<IntegralTexture2dArray, TextureCreationError>
                                          where T: Texture2dDataSource<'a>, F: Facade
                {
                    IntegralTexture2dArray::new_impl(facade, data, Some(format), mipmaps)
                }
            

                fn new_impl<'a, F, T>(facade: &F, data: Vec<T>,
                                   format: Option<UncompressedIntFormat>, mipmaps: MipmapsOption)
                                   -> Result<IntegralTexture2dArray, TextureCreationError>
                                   where T: Texture2dDataSource<'a>, F: Facade
                {
            
let format = format.map(|f| {
                           TextureFormatRequest::Specific(f.to_texture_format())
                       }).unwrap_or(TextureFormatRequest::AnyIntegral);
                    let vec_raw = data.into_iter().map(|e| e.into_raw()).collect();
                    let RawImage3d {data, width, height, depth: array_size, format: client_format } = RawImage3d::from_vec_raw2d(&vec_raw);
                let client_format = ClientFormatAny::ClientFormat(client_format);Ok(IntegralTexture2dArray(try!(any::new_texture(facade, format, Some((client_format, data)), mipmaps.to_regular(), Dimensions::Texture2dArray { width: width, height: height, array_size: array_size }))))
}

                /// Creates an empty texture.
                ///
                /// No mipmap level (except for the main level) will be allocated or generated.
                ///
                /// The texture will contain undefined data.
                pub fn empty<F>(facade: &F, width: u32, height: u32, array_size: u32)
                                -> Result<IntegralTexture2dArray, TextureCreationError>
                                where F: Facade
                {
                    let format = TextureFormatRequest::AnyIntegral;
            
any::new_texture::<_, u8>(facade, format, None, MipmapsOption::NoMipmap.to_regular(), Dimensions::Texture2dArray { width: width, height: height, array_size: array_size }).map(|t| IntegralTexture2dArray(t))}

                /// Creates an empty texture with a specific format.
                ///
                /// The texture (and its mipmaps) will contain undefined data.
                pub fn empty_with_format<F>(facade: &F, format: UncompressedIntFormat, mipmaps: MipmapsOption, width: u32, height: u32, array_size: u32) -> Result<IntegralTexture2dArray, TextureCreationError> where F: Facade {
                    let format = format.to_texture_format();
                    let format = TextureFormatRequest::Specific(format);
            
let t = any::new_texture::<_, u8>(facade, format, None, mipmaps.to_regular(), Dimensions::Texture2dArray { width: width, height: height, array_size: array_size });
            t.map(|t| IntegralTexture2dArray(t))
}

                /// Creates an empty texture. Specifies whether is has mipmaps.
                ///
                /// The texture (and its mipmaps) will contain undefined data.
                pub fn empty_with_mipmaps<F>(facade: &F, mipmaps: MipmapsOption, width: u32, height: u32, array_size: u32) -> Result<IntegralTexture2dArray, TextureCreationError> where F: Facade {
                    let format = TextureFormatRequest::AnyIntegral;
            
any::new_texture::<_, u8>(facade, format, None, mipmaps.to_regular(), Dimensions::Texture2dArray { width: width, height: height, array_size: array_size }).map(|t| IntegralTexture2dArray(t))
}

            /// Returns the number of mipmap levels of the texture.
            ///
            /// The minimum value is 1, since there is always a main texture.
            pub fn get_mipmap_levels(&self) -> u32 {
                self.0.get_mipmap_levels()
            }
        
            /// Turns the texture into a `ResidentTexture`.
            ///
            /// This allows you to use the texture in a much more efficient way by storing
            /// a "reference to it" in a buffer (actually not a reference but a raw pointer).
            ///
            /// See the documentation of `ResidentTexture` for more infos.
            pub fn resident(self) -> Result<ResidentTexture, BindlessTexturesNotSupportedError> {
                ResidentTexture::new(self.0)
            }
        
                /// Access a single layer of this texture.
                pub fn layer(&self, layer: u32) -> Option<IntegralTexture2dArrayLayer> {
                    if layer < self.0.get_array_size().unwrap_or(1) {
                        Some(IntegralTexture2dArrayLayer {
                            texture: self,
                            layer: layer,
                        })
                    } else {
                        None
                    }
                }
            }

                /// Represents a single layer of a `IntegralTexture2dArray`.
                ///
                /// Can be obtained by calling `IntegralTexture2dArray::layer()`.
                #[derive(Copy, Clone)]
                pub struct IntegralTexture2dArrayLayer<'t> {
                    texture: &'t IntegralTexture2dArray,
                    layer: u32,
                }
            impl<'t> IntegralTexture2dArrayLayer<'t> {

                /// Returns the corresponding texture.
                pub fn get_texture(&self) -> &'t IntegralTexture2dArray {
                    self.texture
                }

                /// Returns the layer index.
                pub fn get_layer(&self) -> u32 {
                    self.layer
                }
            
                /// Returns the number of mipmap levels of the texture.
                ///
                /// The minimum value is 1, since there is always a main texture.
                pub fn get_mipmap_levels(&self) -> u32 {
                    self.texture.get_mipmap_levels()
                }
            
                /// Access a single mipmap level of this layer.
                pub fn mipmap(&self, level: u32) -> Option<IntegralTexture2dArrayMipmap> {
                    self.texture.0.mipmap(self.layer, level).map(|m| IntegralTexture2dArrayMipmap(m, &self.texture))
                }
            
                /// Access the main mipmap level of this layer.
                pub fn main_level(&self) -> IntegralTexture2dArrayMipmap {
                    self.mipmap(0).unwrap()
                }
            }

                    /// Represents a single mipmap level of a `IntegralTexture2dArray`.
                    ///
                    /// Can be obtained by calling `IntegralTexture2dArrayLayer::mipmap()` or
                    /// `IntegralTexture2dArrayLayer::main_level()`.
                    #[derive(Copy, Clone)]
                    pub struct IntegralTexture2dArrayMipmap<'t>(TextureAnyMipmap<'t>, &'t IntegralTexture2dArray);
                impl<'t> IntegralTexture2dArrayMipmap<'t> {

                /// Returns the corresponding texture.
                pub fn get_texture(&self) -> &'t IntegralTexture2dArray {
                    self.1
                }

                /// Returns the texture level.
                pub fn get_level(&self) -> u32 {
                    self.0.get_level()
                }
            
                    /// Returns the layer index.
                    pub fn get_layer(&self) -> u32 {
                        self.0.get_layer()
                    }
                }
/// An array of two-dimensional textures  containing unsigned integral data.
pub struct UnsignedTexture2dArray(TextureAny);

                impl Texture for UnsignedTexture2dArray {
                    fn get_width(&self) -> u32 {
                        self.0.get_width()
                    }

                    fn get_height(&self) -> Option<u32> {
                        self.0.get_height()
                    }

                    fn get_depth(&self) -> Option<u32> {
                        self.0.get_depth()
                    }

                    fn get_array_size(&self) -> Option<u32> {
                        self.0.get_array_size()
                    }
                }
            

                impl GlObject for UnsignedTexture2dArray {
                    type Id = gl::types::GLuint;
                    fn get_id(&self) -> gl::types::GLuint {
                        self.0.get_id()
                    }
                }
            

                impl ::std::fmt::Debug for UnsignedTexture2dArray {
                    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> Result<(), ::std::fmt::Error>
                    {
                        self.0.fmt(f)
                    }
                }
            

                impl ::std::ops::Deref for UnsignedTexture2dArray {
                    type Target = TextureAny;
                    
                    fn deref<'a>(&'a self) -> &'a TextureAny {
                        &self.0
                    }
                }
            

                            impl<'a> AsUniformValue for &'a UnsignedTexture2dArray {
                                fn as_uniform_value(&self) -> UniformValue {
                                    UniformValue::UnsignedTexture2dArray(*self, None)
                                }
                            }

                            impl<'a> AsUniformValue for Sampler<'a, UnsignedTexture2dArray> {
                                fn as_uniform_value(&self) -> UniformValue {
                                    UniformValue::UnsignedTexture2dArray(self.0, Some(self.1))
                                }
                            }

                            impl UnsignedTexture2dArray {
                                /// Builds a `Sampler` marker object that allows you to indicate
                                /// how the texture should be sampled from inside a shader.
                                ///
                                /// # Example
                                ///
                                /// ```no_run
                                /// # #[macro_use] extern crate glium;
                                /// # fn main() {
                                /// # let texture: glium::texture::Texture2d = unsafe {
                                /// # ::std::mem::uninitialized() };
                                /// let uniforms = uniform! {
                                ///     color_texture: texture.sampled().magnify_filter(glium::uniforms::MagnifySamplerFilter::Nearest)
                                /// };
                                /// # }
                                /// ```
                                pub fn sampled(&self) -> Sampler<UnsignedTexture2dArray> {
                                    Sampler(self, Default::default())
                                }
                            }
                        
impl UnsignedTexture2dArray {

            /// Determines the internal format of this texture.
            ///
            /// The backend may not support querying the actual format, in which case an error
            /// is returned.
            pub fn get_internal_format(&self) -> Result<InternalFormat, GetFormatError> {
                self.0.get_internal_format()
            }
        

                /// Builds a new texture by uploading data.
                ///
                /// This function will automatically generate all mipmaps of the texture.
                pub fn new<'a, F, T>(facade: &F, data: Vec<T>)
                              -> Result<UnsignedTexture2dArray, TextureCreationError>
                              where T: Texture2dDataSource<'a>, F: Facade
                {
                    UnsignedTexture2dArray::new_impl(facade, data, None, MipmapsOption::AutoGeneratedMipmaps)
                }
            

                /// Builds a new texture by uploading data.
                pub fn with_mipmaps<'a, F, T>(facade: &F, data: Vec<T>, mipmaps: MipmapsOption)
                                              -> Result<UnsignedTexture2dArray, TextureCreationError>
                                              where T: Texture2dDataSource<'a>, F: Facade
                {
                    UnsignedTexture2dArray::new_impl(facade, data, None, mipmaps)
                }
            

                /// Builds a new texture with a specific format.
                pub fn with_format<'a, F, T>(facade: &F, data: Vec<T>,
                                          format: UncompressedUintFormat, mipmaps: MipmapsOption)
                                          -> Result<UnsignedTexture2dArray, TextureCreationError>
                                          where T: Texture2dDataSource<'a>, F: Facade
                {
                    UnsignedTexture2dArray::new_impl(facade, data, Some(format), mipmaps)
                }
            

                fn new_impl<'a, F, T>(facade: &F, data: Vec<T>,
                                   format: Option<UncompressedUintFormat>, mipmaps: MipmapsOption)
                                   -> Result<UnsignedTexture2dArray, TextureCreationError>
                                   where T: Texture2dDataSource<'a>, F: Facade
                {
            
let format = format.map(|f| {
                           TextureFormatRequest::Specific(f.to_texture_format())
                       }).unwrap_or(TextureFormatRequest::AnyUnsigned);
                    let vec_raw = data.into_iter().map(|e| e.into_raw()).collect();
                    let RawImage3d {data, width, height, depth: array_size, format: client_format } = RawImage3d::from_vec_raw2d(&vec_raw);
                let client_format = ClientFormatAny::ClientFormat(client_format);Ok(UnsignedTexture2dArray(try!(any::new_texture(facade, format, Some((client_format, data)), mipmaps.to_regular(), Dimensions::Texture2dArray { width: width, height: height, array_size: array_size }))))
}

                /// Creates an empty texture.
                ///
                /// No mipmap level (except for the main level) will be allocated or generated.
                ///
                /// The texture will contain undefined data.
                pub fn empty<F>(facade: &F, width: u32, height: u32, array_size: u32)
                                -> Result<UnsignedTexture2dArray, TextureCreationError>
                                where F: Facade
                {
                    let format = TextureFormatRequest::AnyUnsigned;
            
any::new_texture::<_, u8>(facade, format, None, MipmapsOption::NoMipmap.to_regular(), Dimensions::Texture2dArray { width: width, height: height, array_size: array_size }).map(|t| UnsignedTexture2dArray(t))}

                /// Creates an empty texture with a specific format.
                ///
                /// The texture (and its mipmaps) will contain undefined data.
                pub fn empty_with_format<F>(facade: &F, format: UncompressedUintFormat, mipmaps: MipmapsOption, width: u32, height: u32, array_size: u32) -> Result<UnsignedTexture2dArray, TextureCreationError> where F: Facade {
                    let format = format.to_texture_format();
                    let format = TextureFormatRequest::Specific(format);
            
let t = any::new_texture::<_, u8>(facade, format, None, mipmaps.to_regular(), Dimensions::Texture2dArray { width: width, height: height, array_size: array_size });
            t.map(|t| UnsignedTexture2dArray(t))
}

                /// Creates an empty texture. Specifies whether is has mipmaps.
                ///
                /// The texture (and its mipmaps) will contain undefined data.
                pub fn empty_with_mipmaps<F>(facade: &F, mipmaps: MipmapsOption, width: u32, height: u32, array_size: u32) -> Result<UnsignedTexture2dArray, TextureCreationError> where F: Facade {
                    let format = TextureFormatRequest::AnyUnsigned;
            
any::new_texture::<_, u8>(facade, format, None, mipmaps.to_regular(), Dimensions::Texture2dArray { width: width, height: height, array_size: array_size }).map(|t| UnsignedTexture2dArray(t))
}

            /// Returns the number of mipmap levels of the texture.
            ///
            /// The minimum value is 1, since there is always a main texture.
            pub fn get_mipmap_levels(&self) -> u32 {
                self.0.get_mipmap_levels()
            }
        
            /// Turns the texture into a `ResidentTexture`.
            ///
            /// This allows you to use the texture in a much more efficient way by storing
            /// a "reference to it" in a buffer (actually not a reference but a raw pointer).
            ///
            /// See the documentation of `ResidentTexture` for more infos.
            pub fn resident(self) -> Result<ResidentTexture, BindlessTexturesNotSupportedError> {
                ResidentTexture::new(self.0)
            }
        
                /// Access a single layer of this texture.
                pub fn layer(&self, layer: u32) -> Option<UnsignedTexture2dArrayLayer> {
                    if layer < self.0.get_array_size().unwrap_or(1) {
                        Some(UnsignedTexture2dArrayLayer {
                            texture: self,
                            layer: layer,
                        })
                    } else {
                        None
                    }
                }
            }

                /// Represents a single layer of a `UnsignedTexture2dArray`.
                ///
                /// Can be obtained by calling `UnsignedTexture2dArray::layer()`.
                #[derive(Copy, Clone)]
                pub struct UnsignedTexture2dArrayLayer<'t> {
                    texture: &'t UnsignedTexture2dArray,
                    layer: u32,
                }
            impl<'t> UnsignedTexture2dArrayLayer<'t> {

                /// Returns the corresponding texture.
                pub fn get_texture(&self) -> &'t UnsignedTexture2dArray {
                    self.texture
                }

                /// Returns the layer index.
                pub fn get_layer(&self) -> u32 {
                    self.layer
                }
            
                /// Returns the number of mipmap levels of the texture.
                ///
                /// The minimum value is 1, since there is always a main texture.
                pub fn get_mipmap_levels(&self) -> u32 {
                    self.texture.get_mipmap_levels()
                }
            
                /// Access a single mipmap level of this layer.
                pub fn mipmap(&self, level: u32) -> Option<UnsignedTexture2dArrayMipmap> {
                    self.texture.0.mipmap(self.layer, level).map(|m| UnsignedTexture2dArrayMipmap(m, &self.texture))
                }
            
                /// Access the main mipmap level of this layer.
                pub fn main_level(&self) -> UnsignedTexture2dArrayMipmap {
                    self.mipmap(0).unwrap()
                }
            }

                    /// Represents a single mipmap level of a `UnsignedTexture2dArray`.
                    ///
                    /// Can be obtained by calling `UnsignedTexture2dArrayLayer::mipmap()` or
                    /// `UnsignedTexture2dArrayLayer::main_level()`.
                    #[derive(Copy, Clone)]
                    pub struct UnsignedTexture2dArrayMipmap<'t>(TextureAnyMipmap<'t>, &'t UnsignedTexture2dArray);
                impl<'t> UnsignedTexture2dArrayMipmap<'t> {

                /// Returns the corresponding texture.
                pub fn get_texture(&self) -> &'t UnsignedTexture2dArray {
                    self.1
                }

                /// Returns the texture level.
                pub fn get_level(&self) -> u32 {
                    self.0.get_level()
                }
            
                    /// Returns the layer index.
                    pub fn get_layer(&self) -> u32 {
                        self.0.get_layer()
                    }
                }
/// An array of two-dimensional textures  containing depth data.
pub struct DepthTexture2dArray(TextureAny);

                impl Texture for DepthTexture2dArray {
                    fn get_width(&self) -> u32 {
                        self.0.get_width()
                    }

                    fn get_height(&self) -> Option<u32> {
                        self.0.get_height()
                    }

                    fn get_depth(&self) -> Option<u32> {
                        self.0.get_depth()
                    }

                    fn get_array_size(&self) -> Option<u32> {
                        self.0.get_array_size()
                    }
                }
            

                impl GlObject for DepthTexture2dArray {
                    type Id = gl::types::GLuint;
                    fn get_id(&self) -> gl::types::GLuint {
                        self.0.get_id()
                    }
                }
            

                impl ::std::fmt::Debug for DepthTexture2dArray {
                    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> Result<(), ::std::fmt::Error>
                    {
                        self.0.fmt(f)
                    }
                }
            

                impl ::std::ops::Deref for DepthTexture2dArray {
                    type Target = TextureAny;
                    
                    fn deref<'a>(&'a self) -> &'a TextureAny {
                        &self.0
                    }
                }
            

                            impl<'a> AsUniformValue for &'a DepthTexture2dArray {
                                fn as_uniform_value(&self) -> UniformValue {
                                    UniformValue::DepthTexture2dArray(*self, None)
                                }
                            }

                            impl<'a> AsUniformValue for Sampler<'a, DepthTexture2dArray> {
                                fn as_uniform_value(&self) -> UniformValue {
                                    UniformValue::DepthTexture2dArray(self.0, Some(self.1))
                                }
                            }

                            impl DepthTexture2dArray {
                                /// Builds a `Sampler` marker object that allows you to indicate
                                /// how the texture should be sampled from inside a shader.
                                ///
                                /// # Example
                                ///
                                /// ```no_run
                                /// # #[macro_use] extern crate glium;
                                /// # fn main() {
                                /// # let texture: glium::texture::Texture2d = unsafe {
                                /// # ::std::mem::uninitialized() };
                                /// let uniforms = uniform! {
                                ///     color_texture: texture.sampled().magnify_filter(glium::uniforms::MagnifySamplerFilter::Nearest)
                                /// };
                                /// # }
                                /// ```
                                pub fn sampled(&self) -> Sampler<DepthTexture2dArray> {
                                    Sampler(self, Default::default())
                                }
                            }
                        
impl DepthTexture2dArray {

            /// Determines the internal format of this texture.
            ///
            /// The backend may not support querying the actual format, in which case an error
            /// is returned.
            pub fn get_internal_format(&self) -> Result<InternalFormat, GetFormatError> {
                self.0.get_internal_format()
            }
        

                /// Builds a new texture by uploading data.
                ///
                /// This function will automatically generate all mipmaps of the texture.
                pub fn new<'a, F, T>(facade: &F, data: Vec<T>)
                              -> Result<DepthTexture2dArray, TextureCreationError>
                              where T: Texture2dDataSource<'a>, F: Facade
                {
                    DepthTexture2dArray::new_impl(facade, data, None, MipmapsOption::AutoGeneratedMipmaps)
                }
            

                /// Builds a new texture by uploading data.
                pub fn with_mipmaps<'a, F, T>(facade: &F, data: Vec<T>, mipmaps: MipmapsOption)
                                              -> Result<DepthTexture2dArray, TextureCreationError>
                                              where T: Texture2dDataSource<'a>, F: Facade
                {
                    DepthTexture2dArray::new_impl(facade, data, None, mipmaps)
                }
            

                /// Builds a new texture with a specific format.
                pub fn with_format<'a, F, T>(facade: &F, data: Vec<T>,
                                          format: DepthFormat, mipmaps: MipmapsOption)
                                          -> Result<DepthTexture2dArray, TextureCreationError>
                                          where T: Texture2dDataSource<'a>, F: Facade
                {
                    DepthTexture2dArray::new_impl(facade, data, Some(format), mipmaps)
                }
            

                fn new_impl<'a, F, T>(facade: &F, data: Vec<T>,
                                   format: Option<DepthFormat>, mipmaps: MipmapsOption)
                                   -> Result<DepthTexture2dArray, TextureCreationError>
                                   where T: Texture2dDataSource<'a>, F: Facade
                {
            
let format = format.map(|f| {
                           TextureFormatRequest::Specific(f.to_texture_format())
                       }).unwrap_or(TextureFormatRequest::AnyDepth);
                    let vec_raw = data.into_iter().map(|e| e.into_raw()).collect();
                    let RawImage3d {data, width, height, depth: array_size, format: client_format } = RawImage3d::from_vec_raw2d(&vec_raw);
                let client_format = ClientFormatAny::ClientFormat(client_format);Ok(DepthTexture2dArray(try!(any::new_texture(facade, format, Some((client_format, data)), mipmaps.to_regular(), Dimensions::Texture2dArray { width: width, height: height, array_size: array_size }))))
}

                /// Creates an empty texture.
                ///
                /// No mipmap level (except for the main level) will be allocated or generated.
                ///
                /// The texture will contain undefined data.
                pub fn empty<F>(facade: &F, width: u32, height: u32, array_size: u32)
                                -> Result<DepthTexture2dArray, TextureCreationError>
                                where F: Facade
                {
                    let format = TextureFormatRequest::AnyDepth;
            
any::new_texture::<_, u8>(facade, format, None, MipmapsOption::NoMipmap.to_regular(), Dimensions::Texture2dArray { width: width, height: height, array_size: array_size }).map(|t| DepthTexture2dArray(t))}

                /// Creates an empty texture with a specific format.
                ///
                /// The texture (and its mipmaps) will contain undefined data.
                pub fn empty_with_format<F>(facade: &F, format: DepthFormat, mipmaps: MipmapsOption, width: u32, height: u32, array_size: u32) -> Result<DepthTexture2dArray, TextureCreationError> where F: Facade {
                    let format = format.to_texture_format();
                    let format = TextureFormatRequest::Specific(format);
            
let t = any::new_texture::<_, u8>(facade, format, None, mipmaps.to_regular(), Dimensions::Texture2dArray { width: width, height: height, array_size: array_size });
            t.map(|t| DepthTexture2dArray(t))
}

                /// Creates an empty texture. Specifies whether is has mipmaps.
                ///
                /// The texture (and its mipmaps) will contain undefined data.
                pub fn empty_with_mipmaps<F>(facade: &F, mipmaps: MipmapsOption, width: u32, height: u32, array_size: u32) -> Result<DepthTexture2dArray, TextureCreationError> where F: Facade {
                    let format = TextureFormatRequest::AnyDepth;
            
any::new_texture::<_, u8>(facade, format, None, mipmaps.to_regular(), Dimensions::Texture2dArray { width: width, height: height, array_size: array_size }).map(|t| DepthTexture2dArray(t))
}

            /// Returns the number of mipmap levels of the texture.
            ///
            /// The minimum value is 1, since there is always a main texture.
            pub fn get_mipmap_levels(&self) -> u32 {
                self.0.get_mipmap_levels()
            }
        
            /// Turns the texture into a `ResidentTexture`.
            ///
            /// This allows you to use the texture in a much more efficient way by storing
            /// a "reference to it" in a buffer (actually not a reference but a raw pointer).
            ///
            /// See the documentation of `ResidentTexture` for more infos.
            pub fn resident(self) -> Result<ResidentTexture, BindlessTexturesNotSupportedError> {
                ResidentTexture::new(self.0)
            }
        
                /// Access a single layer of this texture.
                pub fn layer(&self, layer: u32) -> Option<DepthTexture2dArrayLayer> {
                    if layer < self.0.get_array_size().unwrap_or(1) {
                        Some(DepthTexture2dArrayLayer {
                            texture: self,
                            layer: layer,
                        })
                    } else {
                        None
                    }
                }
            }

                /// Represents a single layer of a `DepthTexture2dArray`.
                ///
                /// Can be obtained by calling `DepthTexture2dArray::layer()`.
                #[derive(Copy, Clone)]
                pub struct DepthTexture2dArrayLayer<'t> {
                    texture: &'t DepthTexture2dArray,
                    layer: u32,
                }
            impl<'t> DepthTexture2dArrayLayer<'t> {

                /// Returns the corresponding texture.
                pub fn get_texture(&self) -> &'t DepthTexture2dArray {
                    self.texture
                }

                /// Returns the layer index.
                pub fn get_layer(&self) -> u32 {
                    self.layer
                }
            
                /// Returns the number of mipmap levels of the texture.
                ///
                /// The minimum value is 1, since there is always a main texture.
                pub fn get_mipmap_levels(&self) -> u32 {
                    self.texture.get_mipmap_levels()
                }
            
                /// Access a single mipmap level of this layer.
                pub fn mipmap(&self, level: u32) -> Option<DepthTexture2dArrayMipmap> {
                    self.texture.0.mipmap(self.layer, level).map(|m| DepthTexture2dArrayMipmap(m, &self.texture))
                }
            
                /// Access the main mipmap level of this layer.
                pub fn main_level(&self) -> DepthTexture2dArrayMipmap {
                    self.mipmap(0).unwrap()
                }
            }

                    /// Represents a single mipmap level of a `DepthTexture2dArray`.
                    ///
                    /// Can be obtained by calling `DepthTexture2dArrayLayer::mipmap()` or
                    /// `DepthTexture2dArrayLayer::main_level()`.
                    #[derive(Copy, Clone)]
                    pub struct DepthTexture2dArrayMipmap<'t>(TextureAnyMipmap<'t>, &'t DepthTexture2dArray);
                impl<'t> DepthTexture2dArrayMipmap<'t> {

                /// Returns the corresponding texture.
                pub fn get_texture(&self) -> &'t DepthTexture2dArray {
                    self.1
                }

                /// Returns the texture level.
                pub fn get_level(&self) -> u32 {
                    self.0.get_level()
                }
            
                    /// Returns the layer index.
                    pub fn get_layer(&self) -> u32 {
                        self.0.get_layer()
                    }
                }
/// An array of two-dimensional textures  containing stencil data.
pub struct StencilTexture2dArray(TextureAny);

                impl Texture for StencilTexture2dArray {
                    fn get_width(&self) -> u32 {
                        self.0.get_width()
                    }

                    fn get_height(&self) -> Option<u32> {
                        self.0.get_height()
                    }

                    fn get_depth(&self) -> Option<u32> {
                        self.0.get_depth()
                    }

                    fn get_array_size(&self) -> Option<u32> {
                        self.0.get_array_size()
                    }
                }
            

                impl GlObject for StencilTexture2dArray {
                    type Id = gl::types::GLuint;
                    fn get_id(&self) -> gl::types::GLuint {
                        self.0.get_id()
                    }
                }
            

                impl ::std::fmt::Debug for StencilTexture2dArray {
                    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> Result<(), ::std::fmt::Error>
                    {
                        self.0.fmt(f)
                    }
                }
            

                impl ::std::ops::Deref for StencilTexture2dArray {
                    type Target = TextureAny;
                    
                    fn deref<'a>(&'a self) -> &'a TextureAny {
                        &self.0
                    }
                }
            
impl StencilTexture2dArray {

            /// Determines the internal format of this texture.
            ///
            /// The backend may not support querying the actual format, in which case an error
            /// is returned.
            pub fn get_internal_format(&self) -> Result<InternalFormat, GetFormatError> {
                self.0.get_internal_format()
            }
        

                /// Builds a new texture by uploading data.
                ///
                /// This function will automatically generate all mipmaps of the texture.
                pub fn new<'a, F, T>(facade: &F, data: Vec<T>)
                              -> Result<StencilTexture2dArray, TextureCreationError>
                              where T: Texture2dDataSource<'a>, F: Facade
                {
                    StencilTexture2dArray::new_impl(facade, data, None, MipmapsOption::AutoGeneratedMipmaps)
                }
            

                /// Builds a new texture by uploading data.
                pub fn with_mipmaps<'a, F, T>(facade: &F, data: Vec<T>, mipmaps: MipmapsOption)
                                              -> Result<StencilTexture2dArray, TextureCreationError>
                                              where T: Texture2dDataSource<'a>, F: Facade
                {
                    StencilTexture2dArray::new_impl(facade, data, None, mipmaps)
                }
            

                /// Builds a new texture with a specific format.
                pub fn with_format<'a, F, T>(facade: &F, data: Vec<T>,
                                          format: StencilFormat, mipmaps: MipmapsOption)
                                          -> Result<StencilTexture2dArray, TextureCreationError>
                                          where T: Texture2dDataSource<'a>, F: Facade
                {
                    StencilTexture2dArray::new_impl(facade, data, Some(format), mipmaps)
                }
            

                fn new_impl<'a, F, T>(facade: &F, data: Vec<T>,
                                   format: Option<StencilFormat>, mipmaps: MipmapsOption)
                                   -> Result<StencilTexture2dArray, TextureCreationError>
                                   where T: Texture2dDataSource<'a>, F: Facade
                {
            
let format = format.map(|f| {
                           TextureFormatRequest::Specific(f.to_texture_format())
                       }).unwrap_or(TextureFormatRequest::AnyStencil);
                    let vec_raw = data.into_iter().map(|e| e.into_raw()).collect();
                    let RawImage3d {data, width, height, depth: array_size, format: client_format } = RawImage3d::from_vec_raw2d(&vec_raw);
                let client_format = ClientFormatAny::ClientFormat(client_format);Ok(StencilTexture2dArray(try!(any::new_texture(facade, format, Some((client_format, data)), mipmaps.to_regular(), Dimensions::Texture2dArray { width: width, height: height, array_size: array_size }))))
}

                /// Creates an empty texture.
                ///
                /// No mipmap level (except for the main level) will be allocated or generated.
                ///
                /// The texture will contain undefined data.
                pub fn empty<F>(facade: &F, width: u32, height: u32, array_size: u32)
                                -> Result<StencilTexture2dArray, TextureCreationError>
                                where F: Facade
                {
                    let format = TextureFormatRequest::AnyStencil;
            
any::new_texture::<_, u8>(facade, format, None, MipmapsOption::NoMipmap.to_regular(), Dimensions::Texture2dArray { width: width, height: height, array_size: array_size }).map(|t| StencilTexture2dArray(t))}

                /// Creates an empty texture with a specific format.
                ///
                /// The texture (and its mipmaps) will contain undefined data.
                pub fn empty_with_format<F>(facade: &F, format: StencilFormat, mipmaps: MipmapsOption, width: u32, height: u32, array_size: u32) -> Result<StencilTexture2dArray, TextureCreationError> where F: Facade {
                    let format = format.to_texture_format();
                    let format = TextureFormatRequest::Specific(format);
            
let t = any::new_texture::<_, u8>(facade, format, None, mipmaps.to_regular(), Dimensions::Texture2dArray { width: width, height: height, array_size: array_size });
            t.map(|t| StencilTexture2dArray(t))
}

                /// Creates an empty texture. Specifies whether is has mipmaps.
                ///
                /// The texture (and its mipmaps) will contain undefined data.
                pub fn empty_with_mipmaps<F>(facade: &F, mipmaps: MipmapsOption, width: u32, height: u32, array_size: u32) -> Result<StencilTexture2dArray, TextureCreationError> where F: Facade {
                    let format = TextureFormatRequest::AnyStencil;
            
any::new_texture::<_, u8>(facade, format, None, mipmaps.to_regular(), Dimensions::Texture2dArray { width: width, height: height, array_size: array_size }).map(|t| StencilTexture2dArray(t))
}

            /// Returns the number of mipmap levels of the texture.
            ///
            /// The minimum value is 1, since there is always a main texture.
            pub fn get_mipmap_levels(&self) -> u32 {
                self.0.get_mipmap_levels()
            }
        
            /// Turns the texture into a `ResidentTexture`.
            ///
            /// This allows you to use the texture in a much more efficient way by storing
            /// a "reference to it" in a buffer (actually not a reference but a raw pointer).
            ///
            /// See the documentation of `ResidentTexture` for more infos.
            pub fn resident(self) -> Result<ResidentTexture, BindlessTexturesNotSupportedError> {
                ResidentTexture::new(self.0)
            }
        
                /// Access a single layer of this texture.
                pub fn layer(&self, layer: u32) -> Option<StencilTexture2dArrayLayer> {
                    if layer < self.0.get_array_size().unwrap_or(1) {
                        Some(StencilTexture2dArrayLayer {
                            texture: self,
                            layer: layer,
                        })
                    } else {
                        None
                    }
                }
            }

                /// Represents a single layer of a `StencilTexture2dArray`.
                ///
                /// Can be obtained by calling `StencilTexture2dArray::layer()`.
                #[derive(Copy, Clone)]
                pub struct StencilTexture2dArrayLayer<'t> {
                    texture: &'t StencilTexture2dArray,
                    layer: u32,
                }
            impl<'t> StencilTexture2dArrayLayer<'t> {

                /// Returns the corresponding texture.
                pub fn get_texture(&self) -> &'t StencilTexture2dArray {
                    self.texture
                }

                /// Returns the layer index.
                pub fn get_layer(&self) -> u32 {
                    self.layer
                }
            
                /// Returns the number of mipmap levels of the texture.
                ///
                /// The minimum value is 1, since there is always a main texture.
                pub fn get_mipmap_levels(&self) -> u32 {
                    self.texture.get_mipmap_levels()
                }
            
                /// Access a single mipmap level of this layer.
                pub fn mipmap(&self, level: u32) -> Option<StencilTexture2dArrayMipmap> {
                    self.texture.0.mipmap(self.layer, level).map(|m| StencilTexture2dArrayMipmap(m, &self.texture))
                }
            
                /// Access the main mipmap level of this layer.
                pub fn main_level(&self) -> StencilTexture2dArrayMipmap {
                    self.mipmap(0).unwrap()
                }
            }

                    /// Represents a single mipmap level of a `StencilTexture2dArray`.
                    ///
                    /// Can be obtained by calling `StencilTexture2dArrayLayer::mipmap()` or
                    /// `StencilTexture2dArrayLayer::main_level()`.
                    #[derive(Copy, Clone)]
                    pub struct StencilTexture2dArrayMipmap<'t>(TextureAnyMipmap<'t>, &'t StencilTexture2dArray);
                impl<'t> StencilTexture2dArrayMipmap<'t> {

                /// Returns the corresponding texture.
                pub fn get_texture(&self) -> &'t StencilTexture2dArray {
                    self.1
                }

                /// Returns the texture level.
                pub fn get_level(&self) -> u32 {
                    self.0.get_level()
                }
            
                    /// Returns the layer index.
                    pub fn get_layer(&self) -> u32 {
                        self.0.get_layer()
                    }
                }
/// An array of two-dimensional textures  containing both depth and stencil data.
pub struct DepthStencilTexture2dArray(TextureAny);

                impl Texture for DepthStencilTexture2dArray {
                    fn get_width(&self) -> u32 {
                        self.0.get_width()
                    }

                    fn get_height(&self) -> Option<u32> {
                        self.0.get_height()
                    }

                    fn get_depth(&self) -> Option<u32> {
                        self.0.get_depth()
                    }

                    fn get_array_size(&self) -> Option<u32> {
                        self.0.get_array_size()
                    }
                }
            

                impl GlObject for DepthStencilTexture2dArray {
                    type Id = gl::types::GLuint;
                    fn get_id(&self) -> gl::types::GLuint {
                        self.0.get_id()
                    }
                }
            

                impl ::std::fmt::Debug for DepthStencilTexture2dArray {
                    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> Result<(), ::std::fmt::Error>
                    {
                        self.0.fmt(f)
                    }
                }
            

                impl ::std::ops::Deref for DepthStencilTexture2dArray {
                    type Target = TextureAny;
                    
                    fn deref<'a>(&'a self) -> &'a TextureAny {
                        &self.0
                    }
                }
            
impl DepthStencilTexture2dArray {

            /// Determines the internal format of this texture.
            ///
            /// The backend may not support querying the actual format, in which case an error
            /// is returned.
            pub fn get_internal_format(&self) -> Result<InternalFormat, GetFormatError> {
                self.0.get_internal_format()
            }
        

                /// Builds a new texture by uploading data.
                ///
                /// This function will automatically generate all mipmaps of the texture.
                pub fn new<'a, F, T>(facade: &F, data: Vec<T>)
                              -> Result<DepthStencilTexture2dArray, TextureCreationError>
                              where T: Texture2dDataSource<'a>, F: Facade
                {
                    DepthStencilTexture2dArray::new_impl(facade, data, None, MipmapsOption::AutoGeneratedMipmaps)
                }
            

                /// Builds a new texture by uploading data.
                pub fn with_mipmaps<'a, F, T>(facade: &F, data: Vec<T>, mipmaps: MipmapsOption)
                                              -> Result<DepthStencilTexture2dArray, TextureCreationError>
                                              where T: Texture2dDataSource<'a>, F: Facade
                {
                    DepthStencilTexture2dArray::new_impl(facade, data, None, mipmaps)
                }
            

                /// Builds a new texture with a specific format.
                pub fn with_format<'a, F, T>(facade: &F, data: Vec<T>,
                                          format: DepthStencilFormat, mipmaps: MipmapsOption)
                                          -> Result<DepthStencilTexture2dArray, TextureCreationError>
                                          where T: Texture2dDataSource<'a>, F: Facade
                {
                    DepthStencilTexture2dArray::new_impl(facade, data, Some(format), mipmaps)
                }
            

                fn new_impl<'a, F, T>(facade: &F, data: Vec<T>,
                                   format: Option<DepthStencilFormat>, mipmaps: MipmapsOption)
                                   -> Result<DepthStencilTexture2dArray, TextureCreationError>
                                   where T: Texture2dDataSource<'a>, F: Facade
                {
            
let format = format.map(|f| {
                           TextureFormatRequest::Specific(f.to_texture_format())
                       }).unwrap_or(TextureFormatRequest::AnyDepthStencil);
                    let vec_raw = data.into_iter().map(|e| e.into_raw()).collect();
                    let RawImage3d {data, width, height, depth: array_size, format: client_format } = RawImage3d::from_vec_raw2d(&vec_raw);
                let client_format = ClientFormatAny::ClientFormat(client_format);Ok(DepthStencilTexture2dArray(try!(any::new_texture(facade, format, Some((client_format, data)), mipmaps.to_regular(), Dimensions::Texture2dArray { width: width, height: height, array_size: array_size }))))
}

                /// Creates an empty texture.
                ///
                /// No mipmap level (except for the main level) will be allocated or generated.
                ///
                /// The texture will contain undefined data.
                pub fn empty<F>(facade: &F, width: u32, height: u32, array_size: u32)
                                -> Result<DepthStencilTexture2dArray, TextureCreationError>
                                where F: Facade
                {
                    let format = TextureFormatRequest::AnyDepthStencil;
            
any::new_texture::<_, u8>(facade, format, None, MipmapsOption::NoMipmap.to_regular(), Dimensions::Texture2dArray { width: width, height: height, array_size: array_size }).map(|t| DepthStencilTexture2dArray(t))}

                /// Creates an empty texture with a specific format.
                ///
                /// The texture (and its mipmaps) will contain undefined data.
                pub fn empty_with_format<F>(facade: &F, format: DepthStencilFormat, mipmaps: MipmapsOption, width: u32, height: u32, array_size: u32) -> Result<DepthStencilTexture2dArray, TextureCreationError> where F: Facade {
                    let format = format.to_texture_format();
                    let format = TextureFormatRequest::Specific(format);
            
let t = any::new_texture::<_, u8>(facade, format, None, mipmaps.to_regular(), Dimensions::Texture2dArray { width: width, height: height, array_size: array_size });
            t.map(|t| DepthStencilTexture2dArray(t))
}

                /// Creates an empty texture. Specifies whether is has mipmaps.
                ///
                /// The texture (and its mipmaps) will contain undefined data.
                pub fn empty_with_mipmaps<F>(facade: &F, mipmaps: MipmapsOption, width: u32, height: u32, array_size: u32) -> Result<DepthStencilTexture2dArray, TextureCreationError> where F: Facade {
                    let format = TextureFormatRequest::AnyDepthStencil;
            
any::new_texture::<_, u8>(facade, format, None, mipmaps.to_regular(), Dimensions::Texture2dArray { width: width, height: height, array_size: array_size }).map(|t| DepthStencilTexture2dArray(t))
}

            /// Returns the number of mipmap levels of the texture.
            ///
            /// The minimum value is 1, since there is always a main texture.
            pub fn get_mipmap_levels(&self) -> u32 {
                self.0.get_mipmap_levels()
            }
        
            /// Turns the texture into a `ResidentTexture`.
            ///
            /// This allows you to use the texture in a much more efficient way by storing
            /// a "reference to it" in a buffer (actually not a reference but a raw pointer).
            ///
            /// See the documentation of `ResidentTexture` for more infos.
            pub fn resident(self) -> Result<ResidentTexture, BindlessTexturesNotSupportedError> {
                ResidentTexture::new(self.0)
            }
        
                /// Access a single layer of this texture.
                pub fn layer(&self, layer: u32) -> Option<DepthStencilTexture2dArrayLayer> {
                    if layer < self.0.get_array_size().unwrap_or(1) {
                        Some(DepthStencilTexture2dArrayLayer {
                            texture: self,
                            layer: layer,
                        })
                    } else {
                        None
                    }
                }
            }

                /// Represents a single layer of a `DepthStencilTexture2dArray`.
                ///
                /// Can be obtained by calling `DepthStencilTexture2dArray::layer()`.
                #[derive(Copy, Clone)]
                pub struct DepthStencilTexture2dArrayLayer<'t> {
                    texture: &'t DepthStencilTexture2dArray,
                    layer: u32,
                }
            impl<'t> DepthStencilTexture2dArrayLayer<'t> {

                /// Returns the corresponding texture.
                pub fn get_texture(&self) -> &'t DepthStencilTexture2dArray {
                    self.texture
                }

                /// Returns the layer index.
                pub fn get_layer(&self) -> u32 {
                    self.layer
                }
            
                /// Returns the number of mipmap levels of the texture.
                ///
                /// The minimum value is 1, since there is always a main texture.
                pub fn get_mipmap_levels(&self) -> u32 {
                    self.texture.get_mipmap_levels()
                }
            
                /// Access a single mipmap level of this layer.
                pub fn mipmap(&self, level: u32) -> Option<DepthStencilTexture2dArrayMipmap> {
                    self.texture.0.mipmap(self.layer, level).map(|m| DepthStencilTexture2dArrayMipmap(m, &self.texture))
                }
            
                /// Access the main mipmap level of this layer.
                pub fn main_level(&self) -> DepthStencilTexture2dArrayMipmap {
                    self.mipmap(0).unwrap()
                }
            }

                    /// Represents a single mipmap level of a `DepthStencilTexture2dArray`.
                    ///
                    /// Can be obtained by calling `DepthStencilTexture2dArrayLayer::mipmap()` or
                    /// `DepthStencilTexture2dArrayLayer::main_level()`.
                    #[derive(Copy, Clone)]
                    pub struct DepthStencilTexture2dArrayMipmap<'t>(TextureAnyMipmap<'t>, &'t DepthStencilTexture2dArray);
                impl<'t> DepthStencilTexture2dArrayMipmap<'t> {

                /// Returns the corresponding texture.
                pub fn get_texture(&self) -> &'t DepthStencilTexture2dArray {
                    self.1
                }

                /// Returns the texture level.
                pub fn get_level(&self) -> u32 {
                    self.0.get_level()
                }
            
                    /// Returns the layer index.
                    pub fn get_layer(&self) -> u32 {
                        self.0.get_layer()
                    }
                }
/// An array of two-dimensional textures  containing floating-point data.
pub struct Texture2dMultisampleArray(TextureAny);

                impl Texture for Texture2dMultisampleArray {
                    fn get_width(&self) -> u32 {
                        self.0.get_width()
                    }

                    fn get_height(&self) -> Option<u32> {
                        self.0.get_height()
                    }

                    fn get_depth(&self) -> Option<u32> {
                        self.0.get_depth()
                    }

                    fn get_array_size(&self) -> Option<u32> {
                        self.0.get_array_size()
                    }
                }
            

                impl GlObject for Texture2dMultisampleArray {
                    type Id = gl::types::GLuint;
                    fn get_id(&self) -> gl::types::GLuint {
                        self.0.get_id()
                    }
                }
            

                impl ::std::fmt::Debug for Texture2dMultisampleArray {
                    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> Result<(), ::std::fmt::Error>
                    {
                        self.0.fmt(f)
                    }
                }
            

                impl ::std::ops::Deref for Texture2dMultisampleArray {
                    type Target = TextureAny;
                    
                    fn deref<'a>(&'a self) -> &'a TextureAny {
                        &self.0
                    }
                }
            

                            impl<'a> AsUniformValue for &'a Texture2dMultisampleArray {
                                fn as_uniform_value(&self) -> UniformValue {
                                    UniformValue::Texture2dMultisampleArray(*self, None)
                                }
                            }

                            impl<'a> AsUniformValue for Sampler<'a, Texture2dMultisampleArray> {
                                fn as_uniform_value(&self) -> UniformValue {
                                    UniformValue::Texture2dMultisampleArray(self.0, Some(self.1))
                                }
                            }

                            impl Texture2dMultisampleArray {
                                /// Builds a `Sampler` marker object that allows you to indicate
                                /// how the texture should be sampled from inside a shader.
                                ///
                                /// # Example
                                ///
                                /// ```no_run
                                /// # #[macro_use] extern crate glium;
                                /// # fn main() {
                                /// # let texture: glium::texture::Texture2d = unsafe {
                                /// # ::std::mem::uninitialized() };
                                /// let uniforms = uniform! {
                                ///     color_texture: texture.sampled().magnify_filter(glium::uniforms::MagnifySamplerFilter::Nearest)
                                /// };
                                /// # }
                                /// ```
                                pub fn sampled(&self) -> Sampler<Texture2dMultisampleArray> {
                                    Sampler(self, Default::default())
                                }
                            }
                        
impl Texture2dMultisampleArray {

            /// Determines the internal format of this texture.
            ///
            /// The backend may not support querying the actual format, in which case an error
            /// is returned.
            pub fn get_internal_format(&self) -> Result<InternalFormat, GetFormatError> {
                self.0.get_internal_format()
            }
        

                /// Creates an empty texture.
                ///
                /// No mipmap level (except for the main level) will be allocated or generated.
                ///
                /// The texture will contain undefined data.
                pub fn empty<F>(facade: &F, width: u32, height: u32, array_size: u32, samples: u32)
                                -> Result<Texture2dMultisampleArray, TextureCreationError>
                                where F: Facade
                {
                    let format = TextureFormatRequest::AnyFloatingPoint;
            
any::new_texture::<_, u8>(facade, format, None, MipmapsOption::NoMipmap.to_regular(), Dimensions::Texture2dMultisampleArray { width: width, height: height, array_size: array_size, samples: samples }).map(|t| Texture2dMultisampleArray(t))}

                /// Creates an empty texture with a specific format.
                ///
                /// The texture (and its mipmaps) will contain undefined data.
                pub fn empty_with_format<F>(facade: &F, format: UncompressedFloatFormat, mipmaps: MipmapsOption, width: u32, height: u32, array_size: u32, samples: u32) -> Result<Texture2dMultisampleArray, TextureCreationError> where F: Facade {
                    let format = format.to_texture_format();
                    let format = TextureFormatRequest::Specific(format);
            
let t = any::new_texture::<_, u8>(facade, format, None, mipmaps.to_regular(), Dimensions::Texture2dMultisampleArray { width: width, height: height, array_size: array_size, samples: samples });
            t.map(|t| Texture2dMultisampleArray(t))
}

                /// Creates an empty texture. Specifies whether is has mipmaps.
                ///
                /// The texture (and its mipmaps) will contain undefined data.
                pub fn empty_with_mipmaps<F>(facade: &F, mipmaps: MipmapsOption, width: u32, height: u32, array_size: u32, samples: u32) -> Result<Texture2dMultisampleArray, TextureCreationError> where F: Facade {
                    let format = TextureFormatRequest::AnyFloatingPoint;
            
any::new_texture::<_, u8>(facade, format, None, mipmaps.to_regular(), Dimensions::Texture2dMultisampleArray { width: width, height: height, array_size: array_size, samples: samples }).map(|t| Texture2dMultisampleArray(t))
}

            /// Returns the number of mipmap levels of the texture.
            ///
            /// The minimum value is 1, since there is always a main texture.
            pub fn get_mipmap_levels(&self) -> u32 {
                self.0.get_mipmap_levels()
            }
        
            /// Turns the texture into a `ResidentTexture`.
            ///
            /// This allows you to use the texture in a much more efficient way by storing
            /// a "reference to it" in a buffer (actually not a reference but a raw pointer).
            ///
            /// See the documentation of `ResidentTexture` for more infos.
            pub fn resident(self) -> Result<ResidentTexture, BindlessTexturesNotSupportedError> {
                ResidentTexture::new(self.0)
            }
        
                /// Access a single mipmap level of this texture.
                pub fn mipmap(&self, level: u32) -> Option<Texture2dMultisampleArrayMipmap> {
                    self.0.mipmap(0, level).map(|m| Texture2dMultisampleArrayMipmap(m, self))
                }
            
                /// Access the main mipmap level of this texture.
                pub fn main_level(&self) -> Texture2dMultisampleArrayMipmap {
                    self.mipmap(0).unwrap()
                }
            }

                    /// Represents a single mipmap level of a `Texture2dMultisampleArray`.
                    ///
                    /// Can be obtained by calling `Texture2dMultisampleArray::mipmap()` or `Texture2dMultisampleArray::main_level()`.
                    #[derive(Copy, Clone)]
                    pub struct Texture2dMultisampleArrayMipmap<'t>(TextureAnyMipmap<'t>, &'t Texture2dMultisampleArray);
                impl<'t> Texture2dMultisampleArrayMipmap<'t> {

                /// Returns the corresponding texture.
                pub fn get_texture(&self) -> &'t Texture2dMultisampleArray {
                    self.1
                }

                /// Returns the texture level.
                pub fn get_level(&self) -> u32 {
                    self.0.get_level()
                }
            }
/// An array of two-dimensional textures  containing sRGB floating-point data.
pub struct SrgbTexture2dMultisampleArray(TextureAny);

                impl Texture for SrgbTexture2dMultisampleArray {
                    fn get_width(&self) -> u32 {
                        self.0.get_width()
                    }

                    fn get_height(&self) -> Option<u32> {
                        self.0.get_height()
                    }

                    fn get_depth(&self) -> Option<u32> {
                        self.0.get_depth()
                    }

                    fn get_array_size(&self) -> Option<u32> {
                        self.0.get_array_size()
                    }
                }
            

                impl GlObject for SrgbTexture2dMultisampleArray {
                    type Id = gl::types::GLuint;
                    fn get_id(&self) -> gl::types::GLuint {
                        self.0.get_id()
                    }
                }
            

                impl ::std::fmt::Debug for SrgbTexture2dMultisampleArray {
                    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> Result<(), ::std::fmt::Error>
                    {
                        self.0.fmt(f)
                    }
                }
            

                impl ::std::ops::Deref for SrgbTexture2dMultisampleArray {
                    type Target = TextureAny;
                    
                    fn deref<'a>(&'a self) -> &'a TextureAny {
                        &self.0
                    }
                }
            

                            impl<'a> AsUniformValue for &'a SrgbTexture2dMultisampleArray {
                                fn as_uniform_value(&self) -> UniformValue {
                                    UniformValue::SrgbTexture2dMultisampleArray(*self, None)
                                }
                            }

                            impl<'a> AsUniformValue for Sampler<'a, SrgbTexture2dMultisampleArray> {
                                fn as_uniform_value(&self) -> UniformValue {
                                    UniformValue::SrgbTexture2dMultisampleArray(self.0, Some(self.1))
                                }
                            }

                            impl SrgbTexture2dMultisampleArray {
                                /// Builds a `Sampler` marker object that allows you to indicate
                                /// how the texture should be sampled from inside a shader.
                                ///
                                /// # Example
                                ///
                                /// ```no_run
                                /// # #[macro_use] extern crate glium;
                                /// # fn main() {
                                /// # let texture: glium::texture::Texture2d = unsafe {
                                /// # ::std::mem::uninitialized() };
                                /// let uniforms = uniform! {
                                ///     color_texture: texture.sampled().magnify_filter(glium::uniforms::MagnifySamplerFilter::Nearest)
                                /// };
                                /// # }
                                /// ```
                                pub fn sampled(&self) -> Sampler<SrgbTexture2dMultisampleArray> {
                                    Sampler(self, Default::default())
                                }
                            }
                        
impl SrgbTexture2dMultisampleArray {

            /// Determines the internal format of this texture.
            ///
            /// The backend may not support querying the actual format, in which case an error
            /// is returned.
            pub fn get_internal_format(&self) -> Result<InternalFormat, GetFormatError> {
                self.0.get_internal_format()
            }
        

                /// Creates an empty texture.
                ///
                /// No mipmap level (except for the main level) will be allocated or generated.
                ///
                /// The texture will contain undefined data.
                pub fn empty<F>(facade: &F, width: u32, height: u32, array_size: u32, samples: u32)
                                -> Result<SrgbTexture2dMultisampleArray, TextureCreationError>
                                where F: Facade
                {
                    let format = TextureFormatRequest::AnySrgb;
            
any::new_texture::<_, u8>(facade, format, None, MipmapsOption::NoMipmap.to_regular(), Dimensions::Texture2dMultisampleArray { width: width, height: height, array_size: array_size, samples: samples }).map(|t| SrgbTexture2dMultisampleArray(t))}

                /// Creates an empty texture with a specific format.
                ///
                /// The texture (and its mipmaps) will contain undefined data.
                pub fn empty_with_format<F>(facade: &F, format: SrgbFormat, mipmaps: MipmapsOption, width: u32, height: u32, array_size: u32, samples: u32) -> Result<SrgbTexture2dMultisampleArray, TextureCreationError> where F: Facade {
                    let format = format.to_texture_format();
                    let format = TextureFormatRequest::Specific(format);
            
let t = any::new_texture::<_, u8>(facade, format, None, mipmaps.to_regular(), Dimensions::Texture2dMultisampleArray { width: width, height: height, array_size: array_size, samples: samples });
            t.map(|t| SrgbTexture2dMultisampleArray(t))
}

                /// Creates an empty texture. Specifies whether is has mipmaps.
                ///
                /// The texture (and its mipmaps) will contain undefined data.
                pub fn empty_with_mipmaps<F>(facade: &F, mipmaps: MipmapsOption, width: u32, height: u32, array_size: u32, samples: u32) -> Result<SrgbTexture2dMultisampleArray, TextureCreationError> where F: Facade {
                    let format = TextureFormatRequest::AnySrgb;
            
any::new_texture::<_, u8>(facade, format, None, mipmaps.to_regular(), Dimensions::Texture2dMultisampleArray { width: width, height: height, array_size: array_size, samples: samples }).map(|t| SrgbTexture2dMultisampleArray(t))
}

            /// Returns the number of mipmap levels of the texture.
            ///
            /// The minimum value is 1, since there is always a main texture.
            pub fn get_mipmap_levels(&self) -> u32 {
                self.0.get_mipmap_levels()
            }
        
            /// Turns the texture into a `ResidentTexture`.
            ///
            /// This allows you to use the texture in a much more efficient way by storing
            /// a "reference to it" in a buffer (actually not a reference but a raw pointer).
            ///
            /// See the documentation of `ResidentTexture` for more infos.
            pub fn resident(self) -> Result<ResidentTexture, BindlessTexturesNotSupportedError> {
                ResidentTexture::new(self.0)
            }
        
                /// Access a single mipmap level of this texture.
                pub fn mipmap(&self, level: u32) -> Option<SrgbTexture2dMultisampleArrayMipmap> {
                    self.0.mipmap(0, level).map(|m| SrgbTexture2dMultisampleArrayMipmap(m, self))
                }
            
                /// Access the main mipmap level of this texture.
                pub fn main_level(&self) -> SrgbTexture2dMultisampleArrayMipmap {
                    self.mipmap(0).unwrap()
                }
            }

                    /// Represents a single mipmap level of a `SrgbTexture2dMultisampleArray`.
                    ///
                    /// Can be obtained by calling `SrgbTexture2dMultisampleArray::mipmap()` or `SrgbTexture2dMultisampleArray::main_level()`.
                    #[derive(Copy, Clone)]
                    pub struct SrgbTexture2dMultisampleArrayMipmap<'t>(TextureAnyMipmap<'t>, &'t SrgbTexture2dMultisampleArray);
                impl<'t> SrgbTexture2dMultisampleArrayMipmap<'t> {

                /// Returns the corresponding texture.
                pub fn get_texture(&self) -> &'t SrgbTexture2dMultisampleArray {
                    self.1
                }

                /// Returns the texture level.
                pub fn get_level(&self) -> u32 {
                    self.0.get_level()
                }
            }
/// An array of two-dimensional textures  containing signed integral data.
pub struct IntegralTexture2dMultisampleArray(TextureAny);

                impl Texture for IntegralTexture2dMultisampleArray {
                    fn get_width(&self) -> u32 {
                        self.0.get_width()
                    }

                    fn get_height(&self) -> Option<u32> {
                        self.0.get_height()
                    }

                    fn get_depth(&self) -> Option<u32> {
                        self.0.get_depth()
                    }

                    fn get_array_size(&self) -> Option<u32> {
                        self.0.get_array_size()
                    }
                }
            

                impl GlObject for IntegralTexture2dMultisampleArray {
                    type Id = gl::types::GLuint;
                    fn get_id(&self) -> gl::types::GLuint {
                        self.0.get_id()
                    }
                }
            

                impl ::std::fmt::Debug for IntegralTexture2dMultisampleArray {
                    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> Result<(), ::std::fmt::Error>
                    {
                        self.0.fmt(f)
                    }
                }
            

                impl ::std::ops::Deref for IntegralTexture2dMultisampleArray {
                    type Target = TextureAny;
                    
                    fn deref<'a>(&'a self) -> &'a TextureAny {
                        &self.0
                    }
                }
            

                            impl<'a> AsUniformValue for &'a IntegralTexture2dMultisampleArray {
                                fn as_uniform_value(&self) -> UniformValue {
                                    UniformValue::IntegralTexture2dMultisampleArray(*self, None)
                                }
                            }

                            impl<'a> AsUniformValue for Sampler<'a, IntegralTexture2dMultisampleArray> {
                                fn as_uniform_value(&self) -> UniformValue {
                                    UniformValue::IntegralTexture2dMultisampleArray(self.0, Some(self.1))
                                }
                            }

                            impl IntegralTexture2dMultisampleArray {
                                /// Builds a `Sampler` marker object that allows you to indicate
                                /// how the texture should be sampled from inside a shader.
                                ///
                                /// # Example
                                ///
                                /// ```no_run
                                /// # #[macro_use] extern crate glium;
                                /// # fn main() {
                                /// # let texture: glium::texture::Texture2d = unsafe {
                                /// # ::std::mem::uninitialized() };
                                /// let uniforms = uniform! {
                                ///     color_texture: texture.sampled().magnify_filter(glium::uniforms::MagnifySamplerFilter::Nearest)
                                /// };
                                /// # }
                                /// ```
                                pub fn sampled(&self) -> Sampler<IntegralTexture2dMultisampleArray> {
                                    Sampler(self, Default::default())
                                }
                            }
                        
impl IntegralTexture2dMultisampleArray {

            /// Determines the internal format of this texture.
            ///
            /// The backend may not support querying the actual format, in which case an error
            /// is returned.
            pub fn get_internal_format(&self) -> Result<InternalFormat, GetFormatError> {
                self.0.get_internal_format()
            }
        

                /// Creates an empty texture.
                ///
                /// No mipmap level (except for the main level) will be allocated or generated.
                ///
                /// The texture will contain undefined data.
                pub fn empty<F>(facade: &F, width: u32, height: u32, array_size: u32, samples: u32)
                                -> Result<IntegralTexture2dMultisampleArray, TextureCreationError>
                                where F: Facade
                {
                    let format = TextureFormatRequest::AnyIntegral;
            
any::new_texture::<_, u8>(facade, format, None, MipmapsOption::NoMipmap.to_regular(), Dimensions::Texture2dMultisampleArray { width: width, height: height, array_size: array_size, samples: samples }).map(|t| IntegralTexture2dMultisampleArray(t))}

                /// Creates an empty texture with a specific format.
                ///
                /// The texture (and its mipmaps) will contain undefined data.
                pub fn empty_with_format<F>(facade: &F, format: UncompressedIntFormat, mipmaps: MipmapsOption, width: u32, height: u32, array_size: u32, samples: u32) -> Result<IntegralTexture2dMultisampleArray, TextureCreationError> where F: Facade {
                    let format = format.to_texture_format();
                    let format = TextureFormatRequest::Specific(format);
            
let t = any::new_texture::<_, u8>(facade, format, None, mipmaps.to_regular(), Dimensions::Texture2dMultisampleArray { width: width, height: height, array_size: array_size, samples: samples });
            t.map(|t| IntegralTexture2dMultisampleArray(t))
}

                /// Creates an empty texture. Specifies whether is has mipmaps.
                ///
                /// The texture (and its mipmaps) will contain undefined data.
                pub fn empty_with_mipmaps<F>(facade: &F, mipmaps: MipmapsOption, width: u32, height: u32, array_size: u32, samples: u32) -> Result<IntegralTexture2dMultisampleArray, TextureCreationError> where F: Facade {
                    let format = TextureFormatRequest::AnyIntegral;
            
any::new_texture::<_, u8>(facade, format, None, mipmaps.to_regular(), Dimensions::Texture2dMultisampleArray { width: width, height: height, array_size: array_size, samples: samples }).map(|t| IntegralTexture2dMultisampleArray(t))
}

            /// Returns the number of mipmap levels of the texture.
            ///
            /// The minimum value is 1, since there is always a main texture.
            pub fn get_mipmap_levels(&self) -> u32 {
                self.0.get_mipmap_levels()
            }
        
            /// Turns the texture into a `ResidentTexture`.
            ///
            /// This allows you to use the texture in a much more efficient way by storing
            /// a "reference to it" in a buffer (actually not a reference but a raw pointer).
            ///
            /// See the documentation of `ResidentTexture` for more infos.
            pub fn resident(self) -> Result<ResidentTexture, BindlessTexturesNotSupportedError> {
                ResidentTexture::new(self.0)
            }
        
                /// Access a single mipmap level of this texture.
                pub fn mipmap(&self, level: u32) -> Option<IntegralTexture2dMultisampleArrayMipmap> {
                    self.0.mipmap(0, level).map(|m| IntegralTexture2dMultisampleArrayMipmap(m, self))
                }
            
                /// Access the main mipmap level of this texture.
                pub fn main_level(&self) -> IntegralTexture2dMultisampleArrayMipmap {
                    self.mipmap(0).unwrap()
                }
            }

                    /// Represents a single mipmap level of a `IntegralTexture2dMultisampleArray`.
                    ///
                    /// Can be obtained by calling `IntegralTexture2dMultisampleArray::mipmap()` or `IntegralTexture2dMultisampleArray::main_level()`.
                    #[derive(Copy, Clone)]
                    pub struct IntegralTexture2dMultisampleArrayMipmap<'t>(TextureAnyMipmap<'t>, &'t IntegralTexture2dMultisampleArray);
                impl<'t> IntegralTexture2dMultisampleArrayMipmap<'t> {

                /// Returns the corresponding texture.
                pub fn get_texture(&self) -> &'t IntegralTexture2dMultisampleArray {
                    self.1
                }

                /// Returns the texture level.
                pub fn get_level(&self) -> u32 {
                    self.0.get_level()
                }
            }
/// An array of two-dimensional textures  containing unsigned integral data.
pub struct UnsignedTexture2dMultisampleArray(TextureAny);

                impl Texture for UnsignedTexture2dMultisampleArray {
                    fn get_width(&self) -> u32 {
                        self.0.get_width()
                    }

                    fn get_height(&self) -> Option<u32> {
                        self.0.get_height()
                    }

                    fn get_depth(&self) -> Option<u32> {
                        self.0.get_depth()
                    }

                    fn get_array_size(&self) -> Option<u32> {
                        self.0.get_array_size()
                    }
                }
            

                impl GlObject for UnsignedTexture2dMultisampleArray {
                    type Id = gl::types::GLuint;
                    fn get_id(&self) -> gl::types::GLuint {
                        self.0.get_id()
                    }
                }
            

                impl ::std::fmt::Debug for UnsignedTexture2dMultisampleArray {
                    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> Result<(), ::std::fmt::Error>
                    {
                        self.0.fmt(f)
                    }
                }
            

                impl ::std::ops::Deref for UnsignedTexture2dMultisampleArray {
                    type Target = TextureAny;
                    
                    fn deref<'a>(&'a self) -> &'a TextureAny {
                        &self.0
                    }
                }
            

                            impl<'a> AsUniformValue for &'a UnsignedTexture2dMultisampleArray {
                                fn as_uniform_value(&self) -> UniformValue {
                                    UniformValue::UnsignedTexture2dMultisampleArray(*self, None)
                                }
                            }

                            impl<'a> AsUniformValue for Sampler<'a, UnsignedTexture2dMultisampleArray> {
                                fn as_uniform_value(&self) -> UniformValue {
                                    UniformValue::UnsignedTexture2dMultisampleArray(self.0, Some(self.1))
                                }
                            }

                            impl UnsignedTexture2dMultisampleArray {
                                /// Builds a `Sampler` marker object that allows you to indicate
                                /// how the texture should be sampled from inside a shader.
                                ///
                                /// # Example
                                ///
                                /// ```no_run
                                /// # #[macro_use] extern crate glium;
                                /// # fn main() {
                                /// # let texture: glium::texture::Texture2d = unsafe {
                                /// # ::std::mem::uninitialized() };
                                /// let uniforms = uniform! {
                                ///     color_texture: texture.sampled().magnify_filter(glium::uniforms::MagnifySamplerFilter::Nearest)
                                /// };
                                /// # }
                                /// ```
                                pub fn sampled(&self) -> Sampler<UnsignedTexture2dMultisampleArray> {
                                    Sampler(self, Default::default())
                                }
                            }
                        
impl UnsignedTexture2dMultisampleArray {

            /// Determines the internal format of this texture.
            ///
            /// The backend may not support querying the actual format, in which case an error
            /// is returned.
            pub fn get_internal_format(&self) -> Result<InternalFormat, GetFormatError> {
                self.0.get_internal_format()
            }
        

                /// Creates an empty texture.
                ///
                /// No mipmap level (except for the main level) will be allocated or generated.
                ///
                /// The texture will contain undefined data.
                pub fn empty<F>(facade: &F, width: u32, height: u32, array_size: u32, samples: u32)
                                -> Result<UnsignedTexture2dMultisampleArray, TextureCreationError>
                                where F: Facade
                {
                    let format = TextureFormatRequest::AnyUnsigned;
            
any::new_texture::<_, u8>(facade, format, None, MipmapsOption::NoMipmap.to_regular(), Dimensions::Texture2dMultisampleArray { width: width, height: height, array_size: array_size, samples: samples }).map(|t| UnsignedTexture2dMultisampleArray(t))}

                /// Creates an empty texture with a specific format.
                ///
                /// The texture (and its mipmaps) will contain undefined data.
                pub fn empty_with_format<F>(facade: &F, format: UncompressedUintFormat, mipmaps: MipmapsOption, width: u32, height: u32, array_size: u32, samples: u32) -> Result<UnsignedTexture2dMultisampleArray, TextureCreationError> where F: Facade {
                    let format = format.to_texture_format();
                    let format = TextureFormatRequest::Specific(format);
            
let t = any::new_texture::<_, u8>(facade, format, None, mipmaps.to_regular(), Dimensions::Texture2dMultisampleArray { width: width, height: height, array_size: array_size, samples: samples });
            t.map(|t| UnsignedTexture2dMultisampleArray(t))
}

                /// Creates an empty texture. Specifies whether is has mipmaps.
                ///
                /// The texture (and its mipmaps) will contain undefined data.
                pub fn empty_with_mipmaps<F>(facade: &F, mipmaps: MipmapsOption, width: u32, height: u32, array_size: u32, samples: u32) -> Result<UnsignedTexture2dMultisampleArray, TextureCreationError> where F: Facade {
                    let format = TextureFormatRequest::AnyUnsigned;
            
any::new_texture::<_, u8>(facade, format, None, mipmaps.to_regular(), Dimensions::Texture2dMultisampleArray { width: width, height: height, array_size: array_size, samples: samples }).map(|t| UnsignedTexture2dMultisampleArray(t))
}

            /// Returns the number of mipmap levels of the texture.
            ///
            /// The minimum value is 1, since there is always a main texture.
            pub fn get_mipmap_levels(&self) -> u32 {
                self.0.get_mipmap_levels()
            }
        
            /// Turns the texture into a `ResidentTexture`.
            ///
            /// This allows you to use the texture in a much more efficient way by storing
            /// a "reference to it" in a buffer (actually not a reference but a raw pointer).
            ///
            /// See the documentation of `ResidentTexture` for more infos.
            pub fn resident(self) -> Result<ResidentTexture, BindlessTexturesNotSupportedError> {
                ResidentTexture::new(self.0)
            }
        
                /// Access a single mipmap level of this texture.
                pub fn mipmap(&self, level: u32) -> Option<UnsignedTexture2dMultisampleArrayMipmap> {
                    self.0.mipmap(0, level).map(|m| UnsignedTexture2dMultisampleArrayMipmap(m, self))
                }
            
                /// Access the main mipmap level of this texture.
                pub fn main_level(&self) -> UnsignedTexture2dMultisampleArrayMipmap {
                    self.mipmap(0).unwrap()
                }
            }

                    /// Represents a single mipmap level of a `UnsignedTexture2dMultisampleArray`.
                    ///
                    /// Can be obtained by calling `UnsignedTexture2dMultisampleArray::mipmap()` or `UnsignedTexture2dMultisampleArray::main_level()`.
                    #[derive(Copy, Clone)]
                    pub struct UnsignedTexture2dMultisampleArrayMipmap<'t>(TextureAnyMipmap<'t>, &'t UnsignedTexture2dMultisampleArray);
                impl<'t> UnsignedTexture2dMultisampleArrayMipmap<'t> {

                /// Returns the corresponding texture.
                pub fn get_texture(&self) -> &'t UnsignedTexture2dMultisampleArray {
                    self.1
                }

                /// Returns the texture level.
                pub fn get_level(&self) -> u32 {
                    self.0.get_level()
                }
            }
/// An array of two-dimensional textures  containing depth data.
pub struct DepthTexture2dMultisampleArray(TextureAny);

                impl Texture for DepthTexture2dMultisampleArray {
                    fn get_width(&self) -> u32 {
                        self.0.get_width()
                    }

                    fn get_height(&self) -> Option<u32> {
                        self.0.get_height()
                    }

                    fn get_depth(&self) -> Option<u32> {
                        self.0.get_depth()
                    }

                    fn get_array_size(&self) -> Option<u32> {
                        self.0.get_array_size()
                    }
                }
            

                impl GlObject for DepthTexture2dMultisampleArray {
                    type Id = gl::types::GLuint;
                    fn get_id(&self) -> gl::types::GLuint {
                        self.0.get_id()
                    }
                }
            

                impl ::std::fmt::Debug for DepthTexture2dMultisampleArray {
                    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> Result<(), ::std::fmt::Error>
                    {
                        self.0.fmt(f)
                    }
                }
            

                impl ::std::ops::Deref for DepthTexture2dMultisampleArray {
                    type Target = TextureAny;
                    
                    fn deref<'a>(&'a self) -> &'a TextureAny {
                        &self.0
                    }
                }
            

                            impl<'a> AsUniformValue for &'a DepthTexture2dMultisampleArray {
                                fn as_uniform_value(&self) -> UniformValue {
                                    UniformValue::DepthTexture2dMultisampleArray(*self, None)
                                }
                            }

                            impl<'a> AsUniformValue for Sampler<'a, DepthTexture2dMultisampleArray> {
                                fn as_uniform_value(&self) -> UniformValue {
                                    UniformValue::DepthTexture2dMultisampleArray(self.0, Some(self.1))
                                }
                            }

                            impl DepthTexture2dMultisampleArray {
                                /// Builds a `Sampler` marker object that allows you to indicate
                                /// how the texture should be sampled from inside a shader.
                                ///
                                /// # Example
                                ///
                                /// ```no_run
                                /// # #[macro_use] extern crate glium;
                                /// # fn main() {
                                /// # let texture: glium::texture::Texture2d = unsafe {
                                /// # ::std::mem::uninitialized() };
                                /// let uniforms = uniform! {
                                ///     color_texture: texture.sampled().magnify_filter(glium::uniforms::MagnifySamplerFilter::Nearest)
                                /// };
                                /// # }
                                /// ```
                                pub fn sampled(&self) -> Sampler<DepthTexture2dMultisampleArray> {
                                    Sampler(self, Default::default())
                                }
                            }
                        
impl DepthTexture2dMultisampleArray {

            /// Determines the internal format of this texture.
            ///
            /// The backend may not support querying the actual format, in which case an error
            /// is returned.
            pub fn get_internal_format(&self) -> Result<InternalFormat, GetFormatError> {
                self.0.get_internal_format()
            }
        

                /// Creates an empty texture.
                ///
                /// No mipmap level (except for the main level) will be allocated or generated.
                ///
                /// The texture will contain undefined data.
                pub fn empty<F>(facade: &F, width: u32, height: u32, array_size: u32, samples: u32)
                                -> Result<DepthTexture2dMultisampleArray, TextureCreationError>
                                where F: Facade
                {
                    let format = TextureFormatRequest::AnyDepth;
            
any::new_texture::<_, u8>(facade, format, None, MipmapsOption::NoMipmap.to_regular(), Dimensions::Texture2dMultisampleArray { width: width, height: height, array_size: array_size, samples: samples }).map(|t| DepthTexture2dMultisampleArray(t))}

                /// Creates an empty texture with a specific format.
                ///
                /// The texture (and its mipmaps) will contain undefined data.
                pub fn empty_with_format<F>(facade: &F, format: DepthFormat, mipmaps: MipmapsOption, width: u32, height: u32, array_size: u32, samples: u32) -> Result<DepthTexture2dMultisampleArray, TextureCreationError> where F: Facade {
                    let format = format.to_texture_format();
                    let format = TextureFormatRequest::Specific(format);
            
let t = any::new_texture::<_, u8>(facade, format, None, mipmaps.to_regular(), Dimensions::Texture2dMultisampleArray { width: width, height: height, array_size: array_size, samples: samples });
            t.map(|t| DepthTexture2dMultisampleArray(t))
}

                /// Creates an empty texture. Specifies whether is has mipmaps.
                ///
                /// The texture (and its mipmaps) will contain undefined data.
                pub fn empty_with_mipmaps<F>(facade: &F, mipmaps: MipmapsOption, width: u32, height: u32, array_size: u32, samples: u32) -> Result<DepthTexture2dMultisampleArray, TextureCreationError> where F: Facade {
                    let format = TextureFormatRequest::AnyDepth;
            
any::new_texture::<_, u8>(facade, format, None, mipmaps.to_regular(), Dimensions::Texture2dMultisampleArray { width: width, height: height, array_size: array_size, samples: samples }).map(|t| DepthTexture2dMultisampleArray(t))
}

            /// Returns the number of mipmap levels of the texture.
            ///
            /// The minimum value is 1, since there is always a main texture.
            pub fn get_mipmap_levels(&self) -> u32 {
                self.0.get_mipmap_levels()
            }
        
            /// Turns the texture into a `ResidentTexture`.
            ///
            /// This allows you to use the texture in a much more efficient way by storing
            /// a "reference to it" in a buffer (actually not a reference but a raw pointer).
            ///
            /// See the documentation of `ResidentTexture` for more infos.
            pub fn resident(self) -> Result<ResidentTexture, BindlessTexturesNotSupportedError> {
                ResidentTexture::new(self.0)
            }
        
                /// Access a single mipmap level of this texture.
                pub fn mipmap(&self, level: u32) -> Option<DepthTexture2dMultisampleArrayMipmap> {
                    self.0.mipmap(0, level).map(|m| DepthTexture2dMultisampleArrayMipmap(m, self))
                }
            
                /// Access the main mipmap level of this texture.
                pub fn main_level(&self) -> DepthTexture2dMultisampleArrayMipmap {
                    self.mipmap(0).unwrap()
                }
            }

                    /// Represents a single mipmap level of a `DepthTexture2dMultisampleArray`.
                    ///
                    /// Can be obtained by calling `DepthTexture2dMultisampleArray::mipmap()` or `DepthTexture2dMultisampleArray::main_level()`.
                    #[derive(Copy, Clone)]
                    pub struct DepthTexture2dMultisampleArrayMipmap<'t>(TextureAnyMipmap<'t>, &'t DepthTexture2dMultisampleArray);
                impl<'t> DepthTexture2dMultisampleArrayMipmap<'t> {

                /// Returns the corresponding texture.
                pub fn get_texture(&self) -> &'t DepthTexture2dMultisampleArray {
                    self.1
                }

                /// Returns the texture level.
                pub fn get_level(&self) -> u32 {
                    self.0.get_level()
                }
            }
/// An array of two-dimensional textures  containing stencil data.
pub struct StencilTexture2dMultisampleArray(TextureAny);

                impl Texture for StencilTexture2dMultisampleArray {
                    fn get_width(&self) -> u32 {
                        self.0.get_width()
                    }

                    fn get_height(&self) -> Option<u32> {
                        self.0.get_height()
                    }

                    fn get_depth(&self) -> Option<u32> {
                        self.0.get_depth()
                    }

                    fn get_array_size(&self) -> Option<u32> {
                        self.0.get_array_size()
                    }
                }
            

                impl GlObject for StencilTexture2dMultisampleArray {
                    type Id = gl::types::GLuint;
                    fn get_id(&self) -> gl::types::GLuint {
                        self.0.get_id()
                    }
                }
            

                impl ::std::fmt::Debug for StencilTexture2dMultisampleArray {
                    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> Result<(), ::std::fmt::Error>
                    {
                        self.0.fmt(f)
                    }
                }
            

                impl ::std::ops::Deref for StencilTexture2dMultisampleArray {
                    type Target = TextureAny;
                    
                    fn deref<'a>(&'a self) -> &'a TextureAny {
                        &self.0
                    }
                }
            
impl StencilTexture2dMultisampleArray {

            /// Determines the internal format of this texture.
            ///
            /// The backend may not support querying the actual format, in which case an error
            /// is returned.
            pub fn get_internal_format(&self) -> Result<InternalFormat, GetFormatError> {
                self.0.get_internal_format()
            }
        

                /// Creates an empty texture.
                ///
                /// No mipmap level (except for the main level) will be allocated or generated.
                ///
                /// The texture will contain undefined data.
                pub fn empty<F>(facade: &F, width: u32, height: u32, array_size: u32, samples: u32)
                                -> Result<StencilTexture2dMultisampleArray, TextureCreationError>
                                where F: Facade
                {
                    let format = TextureFormatRequest::AnyStencil;
            
any::new_texture::<_, u8>(facade, format, None, MipmapsOption::NoMipmap.to_regular(), Dimensions::Texture2dMultisampleArray { width: width, height: height, array_size: array_size, samples: samples }).map(|t| StencilTexture2dMultisampleArray(t))}

                /// Creates an empty texture with a specific format.
                ///
                /// The texture (and its mipmaps) will contain undefined data.
                pub fn empty_with_format<F>(facade: &F, format: StencilFormat, mipmaps: MipmapsOption, width: u32, height: u32, array_size: u32, samples: u32) -> Result<StencilTexture2dMultisampleArray, TextureCreationError> where F: Facade {
                    let format = format.to_texture_format();
                    let format = TextureFormatRequest::Specific(format);
            
let t = any::new_texture::<_, u8>(facade, format, None, mipmaps.to_regular(), Dimensions::Texture2dMultisampleArray { width: width, height: height, array_size: array_size, samples: samples });
            t.map(|t| StencilTexture2dMultisampleArray(t))
}

                /// Creates an empty texture. Specifies whether is has mipmaps.
                ///
                /// The texture (and its mipmaps) will contain undefined data.
                pub fn empty_with_mipmaps<F>(facade: &F, mipmaps: MipmapsOption, width: u32, height: u32, array_size: u32, samples: u32) -> Result<StencilTexture2dMultisampleArray, TextureCreationError> where F: Facade {
                    let format = TextureFormatRequest::AnyStencil;
            
any::new_texture::<_, u8>(facade, format, None, mipmaps.to_regular(), Dimensions::Texture2dMultisampleArray { width: width, height: height, array_size: array_size, samples: samples }).map(|t| StencilTexture2dMultisampleArray(t))
}

            /// Returns the number of mipmap levels of the texture.
            ///
            /// The minimum value is 1, since there is always a main texture.
            pub fn get_mipmap_levels(&self) -> u32 {
                self.0.get_mipmap_levels()
            }
        
            /// Turns the texture into a `ResidentTexture`.
            ///
            /// This allows you to use the texture in a much more efficient way by storing
            /// a "reference to it" in a buffer (actually not a reference but a raw pointer).
            ///
            /// See the documentation of `ResidentTexture` for more infos.
            pub fn resident(self) -> Result<ResidentTexture, BindlessTexturesNotSupportedError> {
                ResidentTexture::new(self.0)
            }
        
                /// Access a single mipmap level of this texture.
                pub fn mipmap(&self, level: u32) -> Option<StencilTexture2dMultisampleArrayMipmap> {
                    self.0.mipmap(0, level).map(|m| StencilTexture2dMultisampleArrayMipmap(m, self))
                }
            
                /// Access the main mipmap level of this texture.
                pub fn main_level(&self) -> StencilTexture2dMultisampleArrayMipmap {
                    self.mipmap(0).unwrap()
                }
            }

                    /// Represents a single mipmap level of a `StencilTexture2dMultisampleArray`.
                    ///
                    /// Can be obtained by calling `StencilTexture2dMultisampleArray::mipmap()` or `StencilTexture2dMultisampleArray::main_level()`.
                    #[derive(Copy, Clone)]
                    pub struct StencilTexture2dMultisampleArrayMipmap<'t>(TextureAnyMipmap<'t>, &'t StencilTexture2dMultisampleArray);
                impl<'t> StencilTexture2dMultisampleArrayMipmap<'t> {

                /// Returns the corresponding texture.
                pub fn get_texture(&self) -> &'t StencilTexture2dMultisampleArray {
                    self.1
                }

                /// Returns the texture level.
                pub fn get_level(&self) -> u32 {
                    self.0.get_level()
                }
            }
/// An array of two-dimensional textures  containing both depth and stencil data.
pub struct DepthStencilTexture2dMultisampleArray(TextureAny);

                impl Texture for DepthStencilTexture2dMultisampleArray {
                    fn get_width(&self) -> u32 {
                        self.0.get_width()
                    }

                    fn get_height(&self) -> Option<u32> {
                        self.0.get_height()
                    }

                    fn get_depth(&self) -> Option<u32> {
                        self.0.get_depth()
                    }

                    fn get_array_size(&self) -> Option<u32> {
                        self.0.get_array_size()
                    }
                }
            

                impl GlObject for DepthStencilTexture2dMultisampleArray {
                    type Id = gl::types::GLuint;
                    fn get_id(&self) -> gl::types::GLuint {
                        self.0.get_id()
                    }
                }
            

                impl ::std::fmt::Debug for DepthStencilTexture2dMultisampleArray {
                    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> Result<(), ::std::fmt::Error>
                    {
                        self.0.fmt(f)
                    }
                }
            

                impl ::std::ops::Deref for DepthStencilTexture2dMultisampleArray {
                    type Target = TextureAny;
                    
                    fn deref<'a>(&'a self) -> &'a TextureAny {
                        &self.0
                    }
                }
            
impl DepthStencilTexture2dMultisampleArray {

            /// Determines the internal format of this texture.
            ///
            /// The backend may not support querying the actual format, in which case an error
            /// is returned.
            pub fn get_internal_format(&self) -> Result<InternalFormat, GetFormatError> {
                self.0.get_internal_format()
            }
        

                /// Creates an empty texture.
                ///
                /// No mipmap level (except for the main level) will be allocated or generated.
                ///
                /// The texture will contain undefined data.
                pub fn empty<F>(facade: &F, width: u32, height: u32, array_size: u32, samples: u32)
                                -> Result<DepthStencilTexture2dMultisampleArray, TextureCreationError>
                                where F: Facade
                {
                    let format = TextureFormatRequest::AnyDepthStencil;
            
any::new_texture::<_, u8>(facade, format, None, MipmapsOption::NoMipmap.to_regular(), Dimensions::Texture2dMultisampleArray { width: width, height: height, array_size: array_size, samples: samples }).map(|t| DepthStencilTexture2dMultisampleArray(t))}

                /// Creates an empty texture with a specific format.
                ///
                /// The texture (and its mipmaps) will contain undefined data.
                pub fn empty_with_format<F>(facade: &F, format: DepthStencilFormat, mipmaps: MipmapsOption, width: u32, height: u32, array_size: u32, samples: u32) -> Result<DepthStencilTexture2dMultisampleArray, TextureCreationError> where F: Facade {
                    let format = format.to_texture_format();
                    let format = TextureFormatRequest::Specific(format);
            
let t = any::new_texture::<_, u8>(facade, format, None, mipmaps.to_regular(), Dimensions::Texture2dMultisampleArray { width: width, height: height, array_size: array_size, samples: samples });
            t.map(|t| DepthStencilTexture2dMultisampleArray(t))
}

                /// Creates an empty texture. Specifies whether is has mipmaps.
                ///
                /// The texture (and its mipmaps) will contain undefined data.
                pub fn empty_with_mipmaps<F>(facade: &F, mipmaps: MipmapsOption, width: u32, height: u32, array_size: u32, samples: u32) -> Result<DepthStencilTexture2dMultisampleArray, TextureCreationError> where F: Facade {
                    let format = TextureFormatRequest::AnyDepthStencil;
            
any::new_texture::<_, u8>(facade, format, None, mipmaps.to_regular(), Dimensions::Texture2dMultisampleArray { width: width, height: height, array_size: array_size, samples: samples }).map(|t| DepthStencilTexture2dMultisampleArray(t))
}

            /// Returns the number of mipmap levels of the texture.
            ///
            /// The minimum value is 1, since there is always a main texture.
            pub fn get_mipmap_levels(&self) -> u32 {
                self.0.get_mipmap_levels()
            }
        
            /// Turns the texture into a `ResidentTexture`.
            ///
            /// This allows you to use the texture in a much more efficient way by storing
            /// a "reference to it" in a buffer (actually not a reference but a raw pointer).
            ///
            /// See the documentation of `ResidentTexture` for more infos.
            pub fn resident(self) -> Result<ResidentTexture, BindlessTexturesNotSupportedError> {
                ResidentTexture::new(self.0)
            }
        
                /// Access a single mipmap level of this texture.
                pub fn mipmap(&self, level: u32) -> Option<DepthStencilTexture2dMultisampleArrayMipmap> {
                    self.0.mipmap(0, level).map(|m| DepthStencilTexture2dMultisampleArrayMipmap(m, self))
                }
            
                /// Access the main mipmap level of this texture.
                pub fn main_level(&self) -> DepthStencilTexture2dMultisampleArrayMipmap {
                    self.mipmap(0).unwrap()
                }
            }

                    /// Represents a single mipmap level of a `DepthStencilTexture2dMultisampleArray`.
                    ///
                    /// Can be obtained by calling `DepthStencilTexture2dMultisampleArray::mipmap()` or `DepthStencilTexture2dMultisampleArray::main_level()`.
                    #[derive(Copy, Clone)]
                    pub struct DepthStencilTexture2dMultisampleArrayMipmap<'t>(TextureAnyMipmap<'t>, &'t DepthStencilTexture2dMultisampleArray);
                impl<'t> DepthStencilTexture2dMultisampleArrayMipmap<'t> {

                /// Returns the corresponding texture.
                pub fn get_texture(&self) -> &'t DepthStencilTexture2dMultisampleArray {
                    self.1
                }

                /// Returns the texture level.
                pub fn get_level(&self) -> u32 {
                    self.0.get_level()
                }
            }
